<!DOCTYPE html>
<html lang="nl" class="scroll-smooth">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ERD-Modellering: Examenvoorbereiding</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Chosen Palette: Emerald/Teal/Slate -->
    <!-- 
    Application Structure Plan: 
    Interactieve studiegids met sidebar navigatie, interactieve elementen voor actief leren, en volledige integratie van uitgebreide content met referenties.
    -->
    <!-- CONFIRMATION: NO SVG graphics used. NO Mermaid JS used. -->
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');

        body {
            font-family: 'Inter', sans-serif;
        }

        .nav-link {
            transition: all 0.3s ease;
            border-left: 4px solid transparent;
        }

        .nav-link.active {
            border-left-color: #059669;
            /* emerald-600 */
            background-color: #ecfdf5;
            /* emerald-50 */
            color: #064e3b;
            /* emerald-900 */
            font-weight: 600;
        }

        .nav-link:hover {
            background-color: #f1f5f9;
            /* slate-100 */
        }

        .entity-box {
            border: 2px solid #1e293b;
            /* slate-800 */
            background-color: white;
            padding: 1rem 1.5rem;
            border-radius: 0.5rem;
            font-weight: 600;
            text-align: center;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            transition: all 0.3s ease;
        }

        .entity-box.interactive-box:hover {
            cursor: pointer;
            transform: translateY(-2px);
            box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        .entity-box.active-sql {
            background-color: #a7f3d0;
            /* emerald-200 */
            border-color: #059669;
            /* emerald-600 */
        }

        .rel-line {
            display: flex;
            align-items: center;
            justify-content: center;
            color: #475569;
            /* slate-600 */
            padding: 0 0.5rem;
            font-family: 'Courier New', Courier, monospace;
            font-size: 0.875rem;
            flex-shrink: 0;
        }

        .solution-box {
            display: none;
            background-color: #ecfdf5;
            /* emerald-50 */
            border: 1px dashed #059669;
            /* emerald-600 */
            border-radius: 0.5rem;
            padding: 1rem;
            margin-top: 1rem;
        }

        .quiz-choice {
            transition: all 0.2s ease;
        }

        .quiz-choice:hover {
            transform: scale(1.05);
        }

        .feedback-correct {
            color: #15803d;
            /* green-700 */
            background-color: #f0fdf4;
            /* green-50 */
            border-left: 4px solid #22c55e;
            /* green-500 */
        }

        .feedback-incorrect {
            color: #b91c1c;
            /* red-700 */
            background-color: #fef2f2;
            /* red-50 */
            border-left: 4px solid #ef4444;
            /* red-500 */
        }

        code {
            background-color: #1e293b;
            /* slate-800 */
            color: #e2e8f0;
            /* slate-200 */
            padding: 1rem;
            border-radius: 0.5rem;
            display: block;
            white-space: pre-wrap;
            font-family: 'Courier New', Courier, monospace;
        }

        .read-more-link {
            color: #059669;
            /* emerald-600 */
            text-decoration: underline;
            font-weight: 500;
        }

        .read-more-link:hover {
            color: #047857;
            /* emerald-700 */
        }

        /* ERD Builder Styles */
        .erd-canvas {
            position: relative;
            width: 100%;
            min-height: 600px;
            background-color: #f8fafc;
            border: 2px solid #cbd5e1;
            border-radius: 0.5rem;
            overflow: visible;
            cursor: crosshair;
        }

        #model-solution-erd {
            min-height: 900px;
            position: relative;
            width: 100%;
        }

        #model-solution-image {
            max-width: 100%;
        }

        #model-solution-image img {
            max-width: 100%;
            height: auto;
        }

        @media (min-width: 768px) {
            #model-solution-image img {
                max-width: 1400px;
                width: 100%;
                height: auto;
                margin: 0 auto;
                display: block;
            }
        }

        .erd-canvas.select-mode {
            cursor: default;
        }

        .erd-canvas.relationship-mode {
            cursor: crosshair;
        }

        .erd-toolbar {
            display: flex;
            gap: 0.5rem;
            padding: 1rem;
            background-color: white;
            border-bottom: 2px solid #e2e8f0;
            flex-wrap: wrap;
        }

        .erd-toolbar-btn {
            padding: 0.5rem 1rem;
            border: 2px solid #cbd5e1;
            border-radius: 0.375rem;
            background-color: white;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.2s;
        }

        .erd-toolbar-btn:hover {
            background-color: #f1f5f9;
            border-color: #94a3b8;
        }

        .erd-toolbar-btn.active {
            background-color: #059669;
            color: white;
            border-color: #059669;
        }

        .erd-entity {
            position: absolute;
            min-width: 180px;
            background-color: white;
            border: 2px solid #1e293b;
            border-radius: 0.5rem;
            cursor: move;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1);
            user-select: none;
            z-index: 10;
        }

        .erd-entity.selected {
            border-color: #059669;
            border-width: 3px;
            box-shadow: 0 0 0 3px rgba(5, 150, 105, 0.1);
        }

        .erd-entity.relationship-selected {
            border-color: #8b5cf6;
            border-width: 3px;
            box-shadow: 0 0 0 3px rgba(139, 92, 246, 0.3);
        }

        .erd-entity-header {
            background-color: #1e293b;
            color: white;
            padding: 0.5rem;
            font-weight: 600;
            border-radius: 0.375rem 0.375rem 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        /* Moderne codeblok look (site-breed) */
        pre {
            position: relative;
            background: linear-gradient(180deg, #0b1220 0%, #0f172a 100%) !important;
            color: #e5e7eb !important;
            padding: 2.75rem 1.25rem 1.25rem 1.25rem;
            /* ruimte voor de header */
            border-radius: 0.75rem;
            border: 1px solid #334155;
            /* slate-700 */
            box-shadow: 0 10px 20px rgba(2, 6, 23, 0.35), inset 0 1px 0 rgba(255, 255, 255, 0.03);
            overflow: auto;
            -webkit-overflow-scrolling: touch;
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
            font-size: 0.95rem;
        }

        pre::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 2.25rem;
            border-radius: 0.75rem 0.75rem 0 0;
            background: linear-gradient(90deg, rgba(15, 23, 42, 0.95) 0%, rgba(20, 83, 45, 0.95) 100%);
            border-bottom: 1px solid rgba(148, 163, 184, 0.2);
        }

        pre::after {
            content: "";
            position: absolute;
            top: 0.65rem;
            left: 0.9rem;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #ef4444;
            /* rood */
            box-shadow: 18px 0 0 #f59e0b, 36px 0 0 #10b981;
            /* geel, groen */
            opacity: 0.9;
        }

        pre code {
            color: inherit !important;
            background: transparent !important;
            text-shadow: 0 0 1px rgba(255, 255, 255, 0.02);
        }

        /* Subtiele grid overlay voor diepte */
        pre {
            background-image:
                radial-gradient(circle at 10% 10%, rgba(16, 185, 129, 0.08), transparent 25%),
                radial-gradient(circle at 90% 20%, rgba(99, 102, 241, 0.08), transparent 25%),
                linear-gradient(180deg, #0b1220 0%, #0f172a 100%) !important;
            background-blend-mode: overlay, overlay, normal;
        }

        /* Scrollbar styling (webkit) */
        pre::-webkit-scrollbar {
            height: 10px;
            width: 10px;
        }

        pre::-webkit-scrollbar-track {
            background: rgba(15, 23, 42, 0.6);
            border-radius: 8px;
        }

        pre::-webkit-scrollbar-thumb {
            background: rgba(148, 163, 184, 0.35);
            border-radius: 8px;
        }

        pre::-webkit-scrollbar-thumb:hover {
            background: rgba(148, 163, 184, 0.55);
        }

        /* Volledige Tekst - moderne typografie en layout */
        #volledige-tekst {
            background: linear-gradient(180deg, #f8fafc 0%, #ffffff 100%);
            border: 1px solid #e2e8f0;
            border-radius: 0.75rem;
            box-shadow: 0 8px 24px rgba(2, 6, 23, 0.06);
            padding: 1rem;
        }

        /* Beperk leesbreedte voor prettige typografie */
        #volledige-tekst>* {
            max-width: 82ch;
            margin-left: auto;
            margin-right: auto;
        }

        #volledige-tekst p {
            color: #334155;
            /* slate-700 */
            line-height: 1.8;
            font-size: 1.05rem;
        }

        #volledige-tekst h3 {
            color: #065f46;
            /* emerald-800 */
            font-weight: 800;
            letter-spacing: 0.01em;
            margin-top: 2.5rem;
            margin-bottom: 0.75rem;
            position: relative;
        }

        #volledige-tekst h3::after {
            content: "";
            position: absolute;
            left: 0;
            bottom: -8px;
            width: 120px;
            height: 4px;
            border-radius: 9999px;
            background: linear-gradient(90deg, #10b981 0%, #14b8a6 100%);
        }

        #volledige-tekst h4 {
            color: #0f766e;
            /* teal-800 */
            font-weight: 700;
            margin-top: 1.75rem;
            margin-bottom: 0.5rem;
        }

        #volledige-tekst h5 {
            color: #334155;
            /* slate-700 */
            font-weight: 700;
            text-transform: none;
            margin-top: 1.25rem;
            margin-bottom: 0.5rem;
        }

        /* Lijsten met mooie bullets/counters */
        #volledige-tekst ul {
            list-style: none;
            padding-left: 0;
        }

        #volledige-tekst ul li {
            position: relative;
            padding-left: 1.25rem;
            margin: 0.4rem 0;
        }

        #volledige-tekst ul li::before {
            content: "";
            position: absolute;
            left: 0;
            top: 0.68em;
            width: 7px;
            height: 7px;
            border-radius: 50%;
            background: linear-gradient(135deg, #10b981, #14b8a6);
            box-shadow: 0 0 0 2px rgba(16, 185, 129, 0.15);
        }

        #volledige-tekst ol {
            counter-reset: vtx-counter;
            padding-left: 0;
        }

        #volledige-tekst ol li {
            counter-increment: vtx-counter;
            position: relative;
            padding-left: 2rem;
            margin: 0.4rem 0;
        }

        #volledige-tekst ol li::before {
            content: counter(vtx-counter) ".";
            position: absolute;
            left: 0;
            top: 0.1rem;
            color: #0f766e;
            font-weight: 700;
            background: rgba(16, 185, 129, 0.08);
            border: 1px solid rgba(16, 185, 129, 0.25);
            border-radius: 0.375rem;
            padding: 0.1rem 0.4rem;
        }

        /* Tabellen (indien aanwezig) */
        #volledige-tekst table {
            width: 100%;
            border-collapse: collapse;
            overflow: hidden;
            border-radius: 0.5rem;
            border: 1px solid #e2e8f0;
        }

        #volledige-tekst th,
        #volledige-tekst td {
            padding: 0.6rem 0.8rem;
            border-bottom: 1px solid #e2e8f0;
        }

        #volledige-tekst thead th {
            background: #f1f5f9;
            color: #0f172a;
        }

        #volledige-tekst tbody tr:nth-child(odd) {
            background: #f8fafc;
        }

        /* Inline code in tekst */
        #volledige-tekst :not(pre)>code {
            background: #f1f5f9;
            /* lichte slate */
            color: #0f172a;
            /* donkere slate */
            padding: 0.15rem 0.35rem;
            border-radius: 0.25rem;
            border: 1px solid #cbd5e1;
            /* lichte rand */
        }

        .erd-entity-type-badge {
            font-size: 0.75rem;
            padding: 0.125rem 0.5rem;
            border-radius: 0.25rem;
            background-color: rgba(255, 255, 255, 0.2);
        }

        .erd-entity-type-badge.kern {
            background-color: #10b981;
        }

        .erd-entity-type-badge.karakteristiek {
            background-color: #3b82f6;
        }

        .erd-entity-type-badge.associatie {
            background-color: #8b5cf6;
        }

        .erd-entity-attributes {
            padding: 0.5rem;
        }

        .erd-attribute {
            padding: 0.25rem 0.5rem;
            font-size: 0.875rem;
            border-bottom: 1px solid #e2e8f0;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .erd-attribute:last-child {
            border-bottom: none;
        }

        .erd-attribute.pk {
            text-decoration: underline;
            font-weight: 600;
        }

        .erd-attribute.fk {
            font-style: italic;
            color: #64748b;
        }

        .erd-attribute.ak {
            border-left: 3px solid #f59e0b;
            padding-left: 0.75rem;
        }

        .erd-relationship-line {
            stroke: #475569;
            stroke-width: 2;
            fill: none;
            marker-end: url(#arrowhead);
        }

        .erd-relationship-label {
            font-size: 0.75rem;
            fill: #1e293b;
            background-color: white;
            padding: 0.125rem 0.25rem;
        }

        .erd-editor-panel {
            position: fixed;
            right: -400px;
            top: 0;
            width: 400px;
            height: 100vh;
            background-color: white;
            box-shadow: -4px 0 6px -1px rgb(0 0 0 / 0.1);
            transition: right 0.3s ease;
            z-index: 100;
            overflow-y: auto;
        }

        .erd-editor-panel.open {
            right: 0;
        }

        .feedback-dashboard {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin-bottom: 2rem;
        }

        .feedback-card {
            padding: 1rem;
            border-radius: 0.5rem;
            border-left: 4px solid;
        }

        .feedback-card.correct {
            background-color: #f0fdf4;
            border-color: #22c55e;
        }

        .feedback-card.incorrect {
            background-color: #fef2f2;
            border-color: #ef4444;
        }

        .feedback-card.warning {
            background-color: #fffbeb;
            border-color: #f59e0b;
        }

        .progress-bar {
            width: 100%;
            height: 0.5rem;
            background-color: #e2e8f0;
            border-radius: 0.25rem;
            overflow: hidden;
            margin-top: 0.5rem;
        }

        .progress-fill {
            height: 100%;
            background-color: #22c55e;
            transition: width 0.3s ease;
        }

        .collapsible-section {
            cursor: pointer;
        }

        .collapsible-content {
            display: none;
        }

        .collapsible-content.active {
            display: block;
        }

        .mobile-menu-button {
            display: none;
        }

        @media (max-width: 768px) {
            .mobile-menu-button {
                display: block;
            }

            .sidebar-nav {
                position: fixed;
                top: 0;
                left: 0;
                height: 100vh;
                width: 80vw;
                /* neem nooit hele breedte in */
                max-width: 18rem;
                /* cap op desktop-achtige maat */
                transform: translateX(-105%);
                transition: transform 0.3s ease;
                z-index: 50;
                display: none !important;
                /* standaard onzichtbaar op mobiel */
            }

            /* Portrait: iets smaller om content niet te overlappen */
            @media (orientation: portrait) {
                .sidebar-nav {
                    width: 76vw;
                }
            }

            /* Landscape: sidebar mag iets breder, maar nog geen full width */
            @media (orientation: landscape) {
                .sidebar-nav {
                    width: 60vw;
                    max-width: 20rem;
                }
            }

            .sidebar-nav.open {
                display: block !important;
                transform: translateX(0);
            }

            /* Overlay achter sidebar wanneer open */
            .sidebar-overlay {
                display: none;
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background-color: rgba(0, 0, 0, 0.5);
                z-index: 40;
            }

            .sidebar-overlay.active {
                display: block;
            }
        }

        #volledige-tekst h3 {
            font-size: 1.875rem;
            /* 3xl */
            font-weight: 600;
            color: #374151;
            /* gray-700 */
            margin-top: 2rem;
            margin-bottom: 1rem;
            border-bottom: 1px solid #D1D5DB;
            /* gray-300 */
            padding-bottom: 0.5rem;
        }

        #volledige-tekst h4 {
            font-size: 1.5rem;
            /* 2xl */
            font-weight: 600;
            color: #1F2937;
            /* gray-800 */
            margin-top: 1.5rem;
            margin-bottom: 0.75rem;
        }

        #volledige-tekst h5 {
            font-size: 1.25rem;
            /* xl */
            font-weight: 500;
            color: #4B5563;
            /* gray-600 */
            margin-top: 1rem;
            margin-bottom: 0.5rem;
        }

        #volledige-tekst p {
            margin-bottom: 1rem;
            line-height: 1.625;
            color: #374151;
            /* gray-700 */
        }

        #volledige-tekst ul {
            list-style-type: disc;
            list-style-position: outside;
            margin-left: 1.5rem;
            margin-bottom: 1rem;
        }

        #volledige-tekst code {
            font-family: 'Courier New', Courier, monospace;
            background-color: #F3F4F6;
            /* gray-100 */
            padding: 0.25rem 0.5rem;
            border-radius: 0.375rem;
            /* rounded-md */
            font-size: 0.9em;
            color: #1F2937;
            /* gray-800 - donkerder voor betere leesbaarheid */
        }

        /* Specifieke styling voor datatype mentions */
        #volledige-tekst p code,
        #volledige-tekst li code {
            color: #111827;
            /* gray-900 - nog donkerder voor datatypes */
            font-weight: 500;
        }

        #volledige-tekst pre {
            background-color: #1F2937;
            /* gray-800 */
            color: #F9FAFB;
            /* gray-50 */
            padding: 1rem;
            border-radius: 0.5rem;
            /* rounded-lg */
            overflow-x: auto;
            margin-bottom: 1rem;
        }

        #volledige-tekst pre code {
            background-color: transparent;
            padding: 0;
            font-size: 0.875rem;
            /* text-sm */
        }

        #volledige-tekst table {
            width: 100%;
            margin-bottom: 1rem;
            border-collapse: collapse;
        }

        #volledige-tekst th,
        #volledige-tekst td {
            border: 1px solid #D1D5DB;
            /* gray-300 */
            padding: 0.75rem;
            text-align: left;
        }

        #volledige-tekst th {
            background-color: #F9FAFB;
            /* gray-50 */
            font-weight: 600;
        }

        /* ========== QUIZ STYLES ========== */
        .quiz-card {
            border: 1px solid #e2e8f0;
            border-radius: 0.75rem;
            background: #ffffff;
            box-shadow: 0 10px 20px rgba(2, 6, 23, 0.04);
        }

        .quiz-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.75rem 1rem;
            border-bottom: 1px solid #e2e8f0;
            background: linear-gradient(90deg, #ecfdf5 0%, #f0f9ff 100%);
            border-radius: 0.75rem 0.75rem 0 0;
        }

        .quiz-title {
            font-weight: 700;
            color: #065f46;
        }

        .quiz-body {
            padding: 1rem;
        }

        .quiz-actions {
            padding: 0.75rem 1rem;
            border-top: 1px solid #e2e8f0;
            display: flex;
            gap: .5rem;
        }

        .quiz-choice {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 0.75rem;
            border: 1px solid #e2e8f0;
            border-radius: 0.5rem;
            cursor: pointer;
            background: #ffffff;
        }

        .quiz-choice:hover {
            border-color: #a7f3d0;
            background: #f0fdf4;
        }

        .quiz-choice.selected {
            border-color: #10b981;
            box-shadow: 0 0 0 3px rgba(16, 185, 129, .15);
        }

        .quiz-choice.correct {
            background: #ecfdf5;
            border-color: #10b981;
        }

        .quiz-choice.incorrect {
            background: #fff1f2;
            border-color: #f43f5e;
        }

        .quiz-explanation {
            margin-top: .5rem;
            padding: .5rem .75rem;
            border-radius: .5rem;
            background: #f8fafc;
            border: 1px solid #e2e8f0;
        }

        .quiz-progress {
            height: 8px;
            background: #e2e8f0;
            border-radius: 9999px;
            overflow: hidden;
        }

        .quiz-progress>div {
            height: 100%;
            background: linear-gradient(90deg, #10b981, #14b8a6);
        }

        .quiz-badge {
            display: inline-block;
            margin-left: .375rem;
            padding: .125rem .375rem;
            font-size: .75rem;
            border-radius: .375rem;
            background: #ecfdf5;
            color: #065f46;
            border: 1px solid #a7f3d0;
        }
    </style>
</head>

<body class="bg-stone-100 text-slate-800">

    <div class="flex">
        <!-- Overlay voor mobile menu -->
        <div id="sidebar-overlay" class="sidebar-overlay"></div>

        <!-- Sidebar Navigatie -->
        <nav id="sidebar-nav" class="sidebar-nav sticky top-0 h-screen w-64 bg-white shadow-lg hidden md:block z-40">
            <div class="p-6">
                <h2 class="text-2xl font-bold text-emerald-800">ERD Studiegids</h2>
                <p class="text-sm text-slate-500">Interactieve Samenvatting</p>
            </div>
            <ul class="space-y-2 p-4 overflow-y-auto max-h-[calc(100vh-120px)]">
                <li><a href="#deel-1" data-target="deel-1"
                        class="nav-link block p-3 rounded-md font-medium text-slate-700">Deel 1: Fundamenten</a></li>
                <li><a href="#deel-2" data-target="deel-2"
                        class="nav-link block p-3 rounded-md font-medium text-slate-700">Deel 2: Modellen</a></li>
                <li><a href="#deel-3" data-target="deel-3"
                        class="nav-link block p-3 rounded-md font-medium text-slate-700">Deel 3: Sleutels</a></li>
                <li><a href="#deel-4" data-target="deel-4"
                        class="nav-link block p-3 rounded-md font-medium text-slate-700">Deel 4: Relaties</a></li>
                <li><a href="#deel-5" data-target="deel-5"
                        class="nav-link block p-3 rounded-md font-medium text-slate-700">Deel 5: Constraints</a></li>
                <li><a href="#deel-6" data-target="deel-6"
                        class="nav-link block p-3 rounded-md font-medium text-slate-700">Deel 6: SQL Impl.</a></li>
                <li><a href="#conclusie" data-target="conclusie"
                        class="nav-link block p-3 rounded-md font-medium text-slate-700">Conclusie</a></li>
                <li><a href="#examenopdracht" data-target="examenopdracht"
                        class="nav-link block p-3 rounded-md font-medium text-slate-700">Examenopdracht</a></li>
                <li><a href="#examen-erd-builder" data-target="examen-erd-builder"
                        class="nav-link block p-3 rounded-md font-medium text-slate-700">ERD Builder</a></li>
                <li><a href="#volledige-tekst" data-target="volledige-tekst"
                        class="nav-link block p-3 rounded-md font-medium text-slate-700">Volledige Tekst</a></li>
            </ul>
        </nav>

        <!-- Mobile Menu Button -->
        <button id="mobile-menu-btn"
            class="mobile-menu-button fixed top-4 left-4 z-50 bg-white p-2 rounded-md shadow-lg md:hidden">
            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16">
                </path>
            </svg>
        </button>

        <!-- Main Content -->
        <main class="flex-1 p-6 md:p-12 overflow-y-auto">
            <div class="max-w-4xl mx-auto">
                <header class="mb-12">
                    <h1 class="text-4xl md:text-5xl font-bold text-slate-900">De Principes van Relationele
                        Datamodellering</h1>
                    <p class="mt-4 text-xl text-slate-600">Een Theoretische Uiteenzetting ter Voorbereiding op Examen
                    </p>
                </header>

                <section id="deel-1" class="mb-16 space-y-8 scroll-mt-20">
                    <h2 class="text-3xl font-bold text-emerald-800 border-b-4 border-emerald-200 pb-2">Deel 1: De
                        Fundamenten van Relationele
                        Datamodellering</h2>
                    <p class="mb-4">
                        Voordat het ontwerp van een datamodel kan beginnen, is een helder begrip van de basisconcepten
                        essentieel. Deze sectie legt de basis door de kernbegrippen data, informatie en databases te
                        definiëren.
                    </p>
                    <h3 class="text-2xl font-medium text-gray-700 mb-3">1.1 De Essentie: Van Data naar Informatie en
                        Databases
                    </h3>
                    <p class="mb-3 text-gray-600 leading-relaxed">
                        De concepten 'data' en 'informatie' worden vaak door elkaar gebruikt, maar vertegenwoordigen
                        fundamenteel verschillende niveaus van abstractie.
                    </p>
                    <ul class="list-disc list-outside space-y-2 ml-6 mb-4 text-gray-600">
                        <li>
                            <strong>Data</strong> zijn de ruwe, ongeorganiseerde feiten die worden verzameld. Dit kunnen
                            cijfers, tekst of andere observaties zijn die op zichzelf geen interpretatie of context
                            bieden. Een
                            voorbeeld is een lange lijst van productprijzen die wekelijks wordt genoteerd.
                        </li>
                        <li>
                            <strong>Informatie</strong> ontstaat wanneer data wordt verwerkt, georganiseerd,
                            gestructureerd en
                            gepresenteerd binnen een specifieke context om het nuttig te maken. Informatie is
                            geïnterpreteerde
                            data. In het voorbeeld van de productprijzen zou de informatie de conclusie kunnen zijn dat
                            de
                            gemiddelde prijs van een product het afgelopen jaar is gestegen.
                        </li>
                    </ul>
                    <p class="mb-3 text-gray-600 leading-relaxed">
                        De brug tussen ruwe data en bruikbare informatie wordt vaak geslagen door een
                        <strong>database</strong>.
                        Een database (of databank) wordt gedefinieerd als een verzameling van permanente (of
                        persistente)
                        gegevens die zijn opgeslagen in een logische structuur. Deze verzameling gegevens wordt beheerd
                        door een
                        softwarepakket dat bekend staat als een <strong>Database Management System (DBMS)</strong>.
                    </p>

                    <div class="bg-white rounded-lg shadow-md p-6 mt-6">
                        <h4 class="text-xl font-semibold text-slate-900 mb-3">1.2 Het Relationele Model: Eigenschappen
                            van Tabellen, Rijen en Kolommen</h4>
                        <p class="mb-3 text-slate-700">Het meest gebruikte model voor het structureren van databases is
                            het relationele model, geïntroduceerd door E.F. Codd in 1970. In dit model worden gegevens
                            opgeslagen in tabellen, die de conceptuele basis vormen van de structuur.</p>
                        <p class="mb-3 text-slate-700">Een <strong>tabel</strong> bestaat uit:</p>
                        <ul class="list-disc list-outside space-y-2 ml-6 mb-4 text-slate-700">
                            <li><strong>Rijen</strong> (ook wel records genoemd): Elke rij vertegenwoordigt één uniek
                                exemplaar van het object dat de tabel beschrijft (bv. één specifieke klant, één
                                specifieke bestelling).</li>
                            <li><strong>Kolommen</strong> (ook wel attributen of velden genoemd): Elke kolom beschrijft
                                een specifieke eigenschap van dat object (bv. de voornaam, het adres, de besteldatum).
                            </li>
                        </ul>
                        <p class="mb-3 text-slate-700">Het relationele model is niet zomaar een willekeurige
                            spreadsheet; het wordt beheerst door strikte, fundamentele eigenschappen die de
                            data-integriteit waarborgen:</p>
                        <ul class="list-disc list-outside space-y-2 ml-6 mb-4 text-slate-700">
                            <li>De volgorde van de rijen in een tabel is onbelangrijk.</li>
                            <li>De volgorde van de kolommen in een tabel is onbelangrijk.</li>
                            <li>Elke waarde in een specifieke kolom moet van hetzelfde type (datatype) zijn.</li>
                            <li>De kruising van een specifieke rij en een specifieke kolom kan maar één waarde bevatten
                                (atomische waarden). Dit principe verklaart waarom samengestelde gegevens, zoals het
                                opslaan van "Jan Peeters" in één veld, problematisch zijn.</li>
                            <li><strong>Cruciale Eigenschap:</strong> Identieke rijen mogen niet voorkomen in een tabel.
                            </li>
                        </ul>
                        <p class="mb-3 text-slate-700">Deze regel vormt de fundamentele rechtvaardiging voor het bestaan
                            van sleutels: als geen twee rijen identiek mogen zijn, moet er een mechanisme bestaan om
                            elke rij uniek te identificeren. Dit leidt direct tot het concept van de Primaire Sleutel.
                        </p>
                        <p class="text-sm text-slate-600 mt-4"><a href="#volledige-tekst-1-2"
                                class="read-more-link">Lees meer over het relationele model →</a></p>
                    </div>
                </section>

                <section id="deel-2" class="mb-16 space-y-8 scroll-mt-20">
                    <h2 class="text-3xl font-bold text-emerald-800 border-b-4 border-emerald-200 pb-2">Deel 2: De Drie
                        Abstra-niveaus van
                        Datamodellering</h2>
                    <p class="mb-6 text-gray-600 leading-relaxed">
                        Het ontwerpen van een database is een proces dat in meerdere fasen verloopt, van een abstract
                        idee tot
                        een concrete implementatie. Deze fasen worden vertegenwoordigd door drie modellen: het
                        conceptuele, het
                        logische en het fysieke model.
                    </p>

                    <h3 class="text-2xl font-medium text-gray-700 mb-3">2.1 Het Conceptuele Model</h3>
                    <p class="mb-3 text-gray-600 leading-relaxed">
                        Dit is het hoogste abstractieniveau. Het beschrijft de 'wat'-vraag: welke informatie moet het
                        systeem
                        bevatten?
                    </p>
                    <ul class="list-disc list-outside space-y-2 ml-6 mb-4 text-gray-600">
                        <li><strong>Doel:</strong> Begrijpen van de business-vereisten en communiceren met stakeholders
                            (niet-technisch).</li>
                        <li><strong>Focus:</strong> Entiteiten (bv. Klant, Product) en de relaties daartussen (bv. Klant
                            'koopt'
                            Product).</li>
                        <li><strong>Details:</strong> Geen attributen, geen sleutels, geen datatypes.</li>
                    </ul>
                    <div class="my-4 p-4 bg-gray-100 rounded-lg shadow-inner">
                        <h4 class="font-semibold text-center text-gray-700 mb-3">Visueel Voorbeeld: Conceptueel Model
                        </h4>
                        <div
                            class="flex flex-col sm:flex-row justify-center items-center space-y-4 sm:space-y-0 sm:space-x-8">
                            <div class="border-2 border-blue-400 rounded-lg p-4 font-medium bg-white">
                                Klant
                            </div>
                            <div class="flex items-center">
                                <div class="border-t-2 border-gray-400 border-dashed w-12 hidden sm:block"></div>
                                <div class="px-3 py-1 bg-gray-200 rounded-full text-sm font-medium text-gray-700">heeft
                                </div>
                                <div class="border-t-2 border-gray-400 border-dashed w-12 hidden sm:block"></div>
                            </div>
                            <div class="border-2 border-blue-400 rounded-lg p-4 font-medium bg-white">
                                Bestelling
                            </div>
                        </div>
                    </div>

                    <h3 class="text-2xl font-medium text-gray-700 mb-3 mt-6">2.2 Het Logische Model</h3>
                    <p class="mb-3 text-gray-600 leading-relaxed">
                        Dit model is een gedetailleerdere uitwerking van het conceptuele model. Het beschrijft de
                        structuur van
                        de data, onafhankelijk van een specifieke database-technologie. Het <strong>relationele
                            model</strong>
                        is het meest voorkomende type logisch model.
                    </p>
                    <ul class="list-disc list-outside space-y-2 ml-6 mb-4 text-gray-600">
                        <li><strong>Doel:</strong> Een 'blauwdruk' maken voor de database die door ontwikkelaars en
                            DBA's kan
                            worden begrepen.</li>
                        <li><strong>Focus:</strong> Alle attributen (kolommen) voor elke entiteit. Definiëren van
                            Primaire
                            Sleutels (PK) en Refererende Sleutels (FK) om relaties te implementeren.</li>
                        <li><strong>Relationele Model:</strong> Data wordt georganiseerd in tabellen (relaties). Elke
                            tabel
                            bestaat uit rijen (tuples) en kolommen (attributen). Relaties tussen tabellen worden gelegd
                            via
                            sleutels.</li>
                    </ul>
                    <div class="my-4 p-4 bg-gray-100 rounded-lg shadow-inner">
                        <h4 class="font-semibold text-center text-gray-700 mb-3">Visueel Voorbeeld: Logisch Model
                            (Relationeel)
                        </h4>
                        <div
                            class="flex flex-col sm:flex-row justify-center items-center space-y-4 sm:space-y-0 sm:space-x-8">
                            <div class="border-2 border-green-500 rounded-lg p-4 bg-white shadow-sm">
                                <h5 class="font-bold border-b border-gray-300 pb-1 mb-1">Klant</h5>
                                <ul class="text-sm">
                                    <li><strong class="text-green-700">KlantID (PK)</strong></li>
                                    <li>Naam</li>
                                    <li>Email</li>
                                </ul>
                            </div>
                            <div class="flex items-center">
                                <div class="border-t-2 border-gray-400 border-dashed w-12 hidden sm:block"></div>
                                <div class="px-3 py-1 bg-gray-200 rounded-full text-sm font-medium text-gray-700">1..N
                                </div>
                                <div class="border-t-2 border-gray-400 border-dashed w-12 hidden sm:block"></div>
                            </div>
                            <div class="border-2 border-green-500 rounded-lg p-4 bg-white shadow-sm">
                                <h5 class="font-bold border-b border-gray-300 pb-1 mb-1">Bestelling</h5>
                                <ul class="text-sm">
                                    <li><strong class="text-green-700">BestellingID (PK)</strong></li>
                                    <li>Datum</li>
                                    <li><em class="text-purple-700">KlantID (FK)</em></li>
                                </ul>
                            </div>
                        </div>
                    </div>

                    <h3 class="text-2xl font-medium text-gray-700 mb-3 mt-6">2.3 Het Fysieke Model</h3>
                    <p class="mb-3 text-gray-600 leading-relaxed">
                        Dit is de concrete implementatie van het logische model in een specifieke DBMS (bv. MySQL,
                        PostgreSQL,
                        SQL Server). Het beschrijft 'hoe' de data fysiek wordt opgeslagen.
                    </p>
                    <ul class="list-disc list-outside space-y-2 ml-6 mb-4 text-gray-600">
                        <li><strong>Doel:</strong> Het daadwerkelijk genereren van de database-schema.</li>
                        <li><strong>Focus:</strong> Specifieke datatypes (bv. `VARCHAR(100)`, `INT`, `DATETIME`).
                            Definiëren van
                            indexen, constraints, partities en andere opslag-specifieke details.</li>
                    </ul>
                    <div class="my-4 p-4 bg-gray-100 rounded-lg shadow-inner">
                        <h4 class="font-semibold text-center text-gray-700 mb-3">Visueel Voorbeeld: Fysiek Model (SQL)
                        </h4>
                        <code
                            class="font-mono bg-gray-800 text-white p-4 rounded-md overflow-x-auto block text-sm shadow-lg">
<pre><code>CREATE TABLE Klant (
    KlantID INT NOT NULL AUTO_INCREMENT,
    Naam VARCHAR(100) NOT NULL,
    Email VARCHAR(150) NOT NULL,
    PRIMARY KEY (KlantID),
    UNIQUE (Email)
);

CREATE TABLE Bestelling (
    BestellingID INT NOT NULL AUTO_INCREMENT,
    Datum DATE NOT NULL,
    KlantID INT NOT NULL,
    PRIMARY KEY (BestellingID),
    FOREIGN KEY (KlantID) REFERENCES Klant(KlantID)
);</code></pre>
                        </code>
                    </div>

                    <!-- Interactieve Model Vergelijker -->
                    <div class="bg-white rounded-lg shadow-md p-6 mt-8">
                        <h3 class="text-2xl font-semibold text-slate-900 mb-4">Interactieve Model Vergelijker</h3>
                        <p class="text-slate-700 mb-4">Vergelijk de drie modellen side-by-side. Selecteer een modeltype
                            om de details te zien.</p>

                        <div class="flex gap-2 mb-6">
                            <button id="model-btn-conceptueel"
                                class="model-toggle-btn flex-1 bg-emerald-500 hover:bg-emerald-600 text-white font-bold py-3 px-4 rounded-md transition-colors">Conceptueel</button>
                            <button id="model-btn-logisch"
                                class="model-toggle-btn flex-1 bg-teal-500 hover:bg-teal-600 text-white font-bold py-3 px-4 rounded-md transition-colors">Logisch</button>
                            <button id="model-btn-fysiek"
                                class="model-toggle-btn flex-1 bg-slate-500 hover:bg-slate-600 text-white font-bold py-3 px-4 rounded-md transition-colors">Fysiek</button>
                            <button id="model-btn-vergelijk"
                                class="model-toggle-btn flex-1 bg-purple-500 hover:bg-purple-600 text-white font-bold py-3 px-4 rounded-md transition-colors">Vergelijk</button>
                        </div>

                        <div id="model-comparison-content"
                            class="border border-slate-200 rounded-lg p-6 bg-slate-50 min-h-[200px]">
                            <p class="text-slate-600">Selecteer een modeltype om de details te zien.</p>
                        </div>
                    </div>

                    <!-- Interactieve Naam Checker -->
                    <div class="bg-white rounded-lg shadow-md p-6 mt-8">
                        <h3 class="text-2xl font-semibold text-slate-900 mb-4">Interactieve Naam Checker</h3>
                        <p class="text-slate-700 mb-4">Test je kennis van naamgeving. Geef een naam voor een attribuut
                            in de entiteit 'Klant'.</p>
                        <input type="text" id="name-checker-input" class="w-full p-2 border border-slate-300 rounded-md"
                            placeholder="bv. klant naam, klantnummer, ...">
                        <div id="name-checker-feedback" class="mt-3 p-3 rounded-md text-sm"></div>
                    </div>
                    <p class="text-sm text-slate-600 mt-4"><a href="#volledige-tekst-2-1" class="read-more-link">Lees
                            meer over entiteiten en attributen →</a></p>
                </section>

                <section id="deel-3" class="mb-16 space-y-8 scroll-mt-20">
                    <h2 class="text-3xl font-bold text-emerald-800 border-b-4 border-emerald-200 pb-2">Deel 3: De
                        Architectuur van Sleutels
                    </h2>
                    <p class="mb-6 text-gray-600 leading-relaxed">
                        Sleutels (Keys) zijn de fundamentele bouwstenen die entiteiten uniek identificeren en relaties
                        tussen
                        entiteiten mogelijk maken. Een correcte sleutelarchitectuur is cruciaal voor de integriteit van
                        de
                        database.
                    </p>

                    <h3 class="text-2xl font-medium text-gray-700 mb-3">3.1 Primaire Sleutel (Primary Key - PK)</h3>
                    <p class="mb-3 text-gray-600 leading-relaxed">
                        De primaire sleutel is een kolom (of een set kolommen) die elke rij in een tabel uniek
                        identificeert.
                    </p>
                    <ul class="list-disc list-outside space-y-2 ml-6 mb-4 text-gray-600">
                        <li><strong>Regels:</strong> Moet <strong>uniek</strong> zijn voor elke rij en mag <strong>nooit
                                `NULL`</strong> (leeg) zijn (NNA).</li>
                        <li><strong>Keuze:</strong> Kan een 'natuurlijke' sleutel zijn (bv. Rijksregisternummer) of een
                            'surrogaat' sleutel.</li>
                        <li><strong>Praktijk:</strong> Er kan maar één primaire sleutel per tabel zijn.</li>
                    </ul>
                    <code class="font-mono bg-gray-100 text-gray-900 p-4 rounded-md overflow-x-auto block text-sm">
<pre><code>-- KlantID is de Primaire Sleutel
CREATE TABLE Klant (
    KlantID INT NOT NULL,
    Naam VARCHAR(100),
    PRIMARY KEY (KlantID)
);</code></pre>
                    </code>

                    <h3 class="text-2xl font-medium text-gray-700 mb-3 mt-6">3.2 Surrogaat Sleutel (Surrogate Key)</h3>
                    <p class="mb-3 text-gray-600 leading-relaxed">
                        Een surrogaat sleutel is een kunstmatige sleutel die wordt toegevoegd aan een tabel om als
                        primaire
                        sleutel te dienen. Het heeft geen 'business' betekenis.
                    </p>
                    <ul class="list-disc list-outside space-y-2 ml-6 mb-4 text-gray-600">
                        <li><strong>Kenmerken:</strong> Meestal een auto-incrementing integer (bv. `AUTO_INCREMENT` in
                            MySQL,
                            `IDENTITY` in SQL Server).</li>
                        <li><strong>Voordeel:</strong> Sterk aanbevolen. Ze zijn stabiel (veranderen nooit), uniek en
                            eenvoudig.
                            Een natuurlijke sleutel (zoals een e-mailadres) kan veranderen, wat desastreus is voor
                            relaties.
                        </li>
                    </ul>
                    <code class="font-mono bg-gray-100 text-gray-900 p-4 rounded-md overflow-x-auto block text-sm">
<pre><code>-- KlantID is een Surrogaat Sleutel
CREATE TABLE Klant (
    KlantID INT NOT NULL AUTO_INCREMENT,
    Email VARCHAR(100) NOT NULL,
    PRIMARY KEY (KlantID)
);</code></pre>
                    </code>

                    <h3 class="text-2xl font-medium text-gray-700 mb-3 mt-6">3.3 Alternatieve Sleutel (Alternate Key -
                        AK)</h3>
                    <p class="mb-3 text-gray-600 leading-relaxed">
                        Een alternatieve sleutel is een kolom (of set kolommen) die ook uniek is, maar niet gekozen is
                        als
                        primaire sleutel. Dit zijn andere 'kandidaat-sleutels'.
                    </p>
                    <ul class="list-disc list-outside space-y-2 ml-6 mb-4 text-gray-600">
                        <li><strong>Implementatie:</strong> Wordt afgedwongen met een `UNIQUE` constraint.</li>
                        <li><strong>Voorbeeld:</strong> In de tabel `Klant` met `KlantID` als PK (surrogaat), is `Email`
                            of
                            `Rijksregisternummer` een perfecte kandidaat voor een Alternatieve Sleutel, omdat deze ook
                            uniek
                            moeten zijn.</li>
                    </ul>
                    <code class="font-mono bg-gray-100 text-gray-900 p-4 rounded-md overflow-x-auto block text-sm">
<pre><code>CREATE TABLE Klant (
    KlantID INT NOT NULL AUTO_INCREMENT,
    Email VARCHAR(100) NOT NULL,
    PRIMARY KEY (KlantID),
    UNIQUE (Email)  -- Email is een Alternatieve Sleutel
);</code></pre>
                    </code>

                    <h3 class="text-2xl font-medium text-gray-700 mb-3 mt-6">3.4 Refererende Sleutel (Foreign Key - FK)
                    </h3>
                    <p class="mb-3 text-gray-600 leading-relaxed">
                        Een refererende sleutel is een kolom (of set kolommen) in één tabel die verwijst naar de
                        primaire
                        sleutel in een andere tabel. Dit is hoe relaties fysiek worden gelegd.
                    </p>
                    <ul class="list-disc list-outside space-y-2 ml-6 mb-4 text-gray-600">
                        <li><strong>Doel:</strong> Garandeert referentiële integriteit. Het zorgt ervoor dat je geen
                            'zwevende'
                            data krijgt (bv. een bestelling zonder klant).</li>
                        <li><strong>Regel:</strong> De waarde in de FK-kolom moet overeenkomen met een bestaande waarde
                            in de
                            PK-kolom waarnaar het verwijst, of het moet `NULL` zijn (indien toegestaan).</li>
                    </ul>
                    <code class="font-mono bg-gray-100 text-gray-900 p-4 rounded-md overflow-x-auto block text-sm">
<pre><code>CREATE TABLE Bestelling (
    BestellingID INT NOT NULL AUTO_INCREMENT,
    Datum DATE,
    KlantID INT,  -- Dit is de Foreign Key kolom
    PRIMARY KEY (BestellingID),
    
    -- Dit legt de relatie vast:
    FOREIGN KEY (KlantID) REFERENCES Klant(KlantID)
);</code></pre>
                    </code>

                    <!-- Interactieve Sleutel Hiërarchie Visualisatie -->
                    <div class="bg-white rounded-lg shadow-md p-6 mt-8">
                        <h3 class="text-2xl font-semibold text-slate-900 mb-4">Interactieve Sleutel Hiërarchie</h3>
                        <p class="text-slate-700 mb-4">Bekijk hoe sleutels worden geselecteerd van Superkey naar
                            Candidate Key naar Primary Key. Klik op elke stap voor meer details.</p>

                        <div class="space-y-4">
                            <div id="key-hierarchy-step-1"
                                class="key-hierarchy-step p-4 border-2 border-slate-300 rounded-lg cursor-pointer hover:bg-slate-50 transition-colors">
                                <h4 class="font-bold text-lg mb-2">1. Superkey (Supersleutel)</h4>
                                <p class="text-sm text-slate-600 mb-2">Elke set attributen die een rij uniek
                                    identificeert (mag overbodige attributen bevatten).</p>
                                <div class="key-hierarchy-detail hidden mt-2 p-3 bg-slate-100 rounded">
                                    <p class="text-sm mb-2"><strong>Voorbeeld tabel Student:</strong></p>
                                    <table class="text-xs border-collapse w-full mb-2">
                                        <tr class="border-b">
                                            <td class="p-1"><strong>id</strong></td>
                                            <td class="p-1"><strong>studentenNummer</strong></td>
                                            <td class="p-1"><strong>email</strong></td>
                                            <td class="p-1"><strong>naam</strong></td>
                                        </tr>
                                        <tr class="border-b">
                                            <td class="p-1">1</td>
                                            <td class="p-1">S001</td>
                                            <td class="p-1">jan@example.com</td>
                                            <td class="p-1">Jan</td>
                                        </tr>
                                    </table>
                                    <p class="text-sm"><strong>Superkeys:</strong> {id}, {id, naam}, {studentenNummer,
                                        email, naam}, {id, studentenNummer, email, naam}</p>
                                    <p class="text-sm mt-1 text-slate-500">Allemaal identificeren ze uniek, maar sommige
                                        bevatten overbodige attributen.</p>
                                </div>
                            </div>

                            <div class="text-center text-slate-500 font-bold">↓</div>

                            <div id="key-hierarchy-step-2"
                                class="key-hierarchy-step p-4 border-2 border-slate-300 rounded-lg cursor-pointer hover:bg-slate-50 transition-colors">
                                <h4 class="font-bold text-lg mb-2">2. Candidate Key (Kandidaatsleutel)</h4>
                                <p class="text-sm text-slate-600 mb-2">Een minimale superkey - geen attributen kunnen
                                    worden verwijderd zonder uniciteit te verliezen.</p>
                                <div class="key-hierarchy-detail hidden mt-2 p-3 bg-slate-100 rounded">
                                    <p class="text-sm mb-2"><strong>Voorbeeld tabel Student:</strong></p>
                                    <p class="text-sm mb-2"><strong>Candidate Keys:</strong> {id}, {studentenNummer},
                                        {email}</p>
                                    <p class="text-sm mb-2">Elk van deze kan uniek identificeren, maar geen enkel
                                        attribuut kan worden verwijderd.</p>
                                    <div class="mt-2 p-2 bg-white rounded border border-slate-300">
                                        <p class="text-xs font-semibold mb-1">Waarom {id, naam} GEEN candidate key is:
                                        </p>
                                        <p class="text-xs">Als je 'naam' verwijdert, blijft {id} nog steeds uniek.
                                            Daarom is {id, naam} een superkey maar geen candidate key.</p>
                                    </div>
                                </div>
                            </div>

                            <div class="text-center text-slate-500 font-bold">↓</div>

                            <div id="key-hierarchy-step-3"
                                class="key-hierarchy-step p-4 border-2 border-emerald-500 rounded-lg cursor-pointer hover:bg-emerald-50 transition-colors">
                                <h4 class="font-bold text-lg mb-2 text-emerald-700">3. Primary Key (PK)</h4>
                                <p class="text-sm text-slate-600 mb-2">De gekozen kandidaatsleutel die als officiële
                                    identifier dient.</p>
                                <div class="key-hierarchy-detail hidden mt-2 p-3 bg-emerald-100 rounded">
                                    <p class="text-sm mb-2"><strong>Keuze uit Candidate Keys:</strong> {id},
                                        {studentenNummer}, {email}</p>
                                    <p class="text-sm mb-2"><strong>Gekozen PK:</strong> {id} (surrogaat sleutel)</p>
                                    <div class="mt-2 p-2 bg-white rounded border border-emerald-300">
                                        <p class="text-xs font-semibold mb-1">Waarom {id}?</p>
                                        <ul class="text-xs list-disc list-inside space-y-1">
                                            <li>Stabiel: verandert nooit (studentenNummer kan veranderen)</li>
                                            <li>Eenvoudig: één attribuut</li>
                                            <li>Efficiënt: integer is sneller dan string</li>
                                            <li>Geen business betekenis: geen privacy issues</li>
                                        </ul>
                                    </div>
                                </div>
                            </div>

                            <div class="text-center text-slate-500 font-bold">↓</div>

                            <div id="key-hierarchy-step-4"
                                class="key-hierarchy-step p-4 border-2 border-teal-300 rounded-lg cursor-pointer hover:bg-teal-50 transition-colors">
                                <h4 class="font-bold text-lg mb-2 text-teal-700">4. Alternate Key (AK)</h4>
                                <p class="text-sm text-slate-600 mb-2">Andere kandidaatsleutels die niet als PK zijn
                                    gekozen.</p>
                                <div class="key-hierarchy-detail hidden mt-2 p-3 bg-teal-100 rounded">
                                    <p class="text-sm mb-2"><strong>Alternate Keys:</strong> {studentenNummer}, {email}
                                    </p>
                                    <p class="text-sm mb-2">Deze krijgen een <code>UNIQUE</code> constraint in SQL om te
                                        garanderen dat ze uniek blijven.</p>
                                    <div class="mt-2 p-2 bg-white rounded border border-teal-300">
                                        <p class="text-xs font-semibold mb-1">SQL Implementatie:</p>
                                        <pre class="text-xs bg-slate-800 text-slate-200 p-2 rounded overflow-x-auto"><code>CREATE TABLE Student (
    id INT PRIMARY KEY,
    studentenNummer VARCHAR(20) UNIQUE,  -- AK
    email VARCHAR(100) UNIQUE,            -- AK
    naam VARCHAR(100)
);</code></pre>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <p class="text-sm text-slate-600 mt-4"><a href="#volledige-tekst-3-1" class="read-more-link">Lees
                            meer over sleutels en hun hiërarchie →</a></p>
                </section>

                <section id="deel-4" class="mb-16 space-y-8 scroll-mt-20">
                    <h2 class="text-3xl font-bold text-emerald-800 border-b-4 border-emerald-200 pb-2">Deel 4: Relaties
                        en Kardinaliteit</h2>
                    <p class="mb-6 text-gray-600 leading-relaxed">
                        Relaties definiëren hoe entiteiten met elkaar verbonden zijn. Kardinaliteit beschrijft het
                        aantal
                        instanties in de ene entiteit dat kan worden gerelateerd aan het aantal instanties in een andere
                        entiteit. De correcte implementatie hangt af van de kardinaliteit.
                    </p>

                    <h3 class="text-2xl font-medium text-gray-700 mb-3">4.1 Eén-op-één (1:1)</h3>
                    <p class="mb-3 text-gray-600 leading-relaxed">
                        Elke rij in Tabel A is gekoppeld aan maximaal één rij in Tabel B, en vice versa.
                    </p>
                    <ul class="list-disc list-outside space-y-2 ml-6 mb-4 text-gray-600">
                        <li><strong>Voorbeeld:</strong> `Werknemer` en `Bureau`. Eén werknemer heeft één bureau; één
                            bureau
                            hoort bij één werknemer.</li>
                        <li><strong>Implementatie:</strong> De Foreign Key kan in beide tabellen worden geplaatst, maar
                            wordt
                            meestal geplaatst in de tabel die 'optioneel' is (bv. niet elke werknemer *heeft* een
                            bureau). De
                            FK-kolom moet ook een `UNIQUE` constraint hebben om de 1:1-relatie af te dwingen.</li>
                    </ul>

                    <h3 class="text-2xl font-medium text-gray-700 mb-3 mt-6">4.2 Eén-op-veel (1:N)</h3>
                    <p class="mb-3 text-gray-600 leading-relaxed">
                        De meest voorkomende relatie. Eén rij in Tabel A kan worden gekoppeld aan vele rijen in Tabel B,
                        maar
                        elke rij in Tabel B is gekoppeld aan slechts één rij in Tabel A.
                    </p>
                    <ul class="list-disc list-outside space-y-2 ml-6 mb-4 text-gray-600">
                        <li><strong>Voorbeeld:</strong> `Klant` en `Bestelling`. Eén klant kan vele bestellingen hebben;
                            elke
                            bestelling hoort bij exact één klant.</li>
                        <li><strong>Implementatie (Gouden Regel):</strong> De Foreign Key wordt <strong>altijd</strong>
                            geplaatst aan de 'N' (veel) kant van de relatie. De tabel `Bestelling` ('veel'-kant) krijgt
                            een
                            `KlantID` (FK) die verwijst naar de `Klant` ('één'-kant).</li>
                    </ul>

                    <h3 class="text-2xl font-medium text-gray-700 mb-3 mt-6">4.3 Veel-op-veel (M:N)</h3>
                    <p class="mb-3 text-gray-600 leading-relaxed">
                        Eén rij in Tabel A kan worden gekoppeld aan vele rijen in Tabel B, en één rij in Tabel B kan
                        worden
                        gekoppeld aan vele rijen in Tabel A.
                    </p>
                    <ul class="list-disc list-outside space-y-2 ml-6 mb-4 text-gray-600">
                        <li><strong>Voorbeeld:</strong> `Student` en `Cursus`. Eén student volgt vele cursussen; één
                            cursus
                            wordt gevolgd door vele studenten.</li>
                        <li><strong>Implementatie (Gouden Regel):</strong> Een M:N-relatie kan <strong>nooit</strong>
                            direct
                            worden geïmplementeerd. Het wordt <strong>altijd</strong> opgelost door een derde tabel te
                            creëren,
                            een zogenaamde <strong>associatietabel</strong> (of junction/link table).</li>
                        <li><strong>Associatietabel:</strong> Deze tabel (bv. `StudentCursus`) bevat minimaal twee
                            Foreign Keys:
                            één die verwijst naar `Student(PK)` en één die verwijst naar `Cursus(PK)`. De combinatie van
                            deze
                            twee FK's vormt vaak de Primaire Sleutel van de associatietabel.</li>
                    </ul>
                    <div class="my-4 p-4 bg-gray-100 rounded-lg shadow-inner">
                        <h4 class="font-semibold text-center text-gray-700 mb-3">Voorbeeld: Oplossen van M:N Relatie
                        </h4>
                        <div
                            class="flex flex-col sm:flex-row justify-center items-center space-y-4 sm:space-y-0 sm:space-x-4">
                            <div class="border-2 border-orange-500 rounded-lg p-3 bg-white shadow-sm">
                                <h5 class="font-bold border-b border-gray-300 pb-1 mb-1">Student</h5>
                                <ul class="text-sm">
                                    <li><strong class="text-orange-700">StudentID (PK)</strong></li>
                                </ul>
                            </div>
                            <div class="px-2 py-1 bg-gray-200 rounded-full text-sm font-medium text-gray-700">&lt;--&gt;
                            </div>
                            <div
                                class="border-2 border-purple-500 rounded-lg p-3 bg-white shadow-sm font-bold text-purple-700">
                                StudentCursus (Associatietabel)
                            </div>
                            <div class="px-2 py-1 bg-gray-200 rounded-full text-sm font-medium text-gray-700">&lt;--&gt;
                            </div>
                            <div class="border-2 border-orange-500 rounded-lg p-3 bg-white shadow-sm">
                                <h5 class="font-bold border-b border-gray-300 pb-1 mb-1">Cursus</h5>
                                <ul class="text-sm">
                                    <li><strong class="text-orange-700">CursusID (PK)</strong></li>
                                </ul>
                            </div>
                        </div>
                    </div>


                    <h3 class="text-2xl font-medium text-gray-700 mb-3 mt-6">4.4 Recursieve Relatie</h3>
                    <p class="mb-3 text-gray-600 leading-relaxed">
                        Een relatie waarbij een tabel naar zichzelf verwijst. Dit wordt ook wel een 'unary' relatie
                        genoemd.
                    </p>
                    <ul class="list-disc list-outside space-y-2 ml-6 mb-4 text-gray-600">
                        <li><strong>Voorbeeld:</strong> `Werknemer` en `Manager`. Een manager is ook een werknemer. De
                            relatie
                            is 'Werknemer *wordt gemanaged door* Werknemer'.</li>
                        <li><strong>Implementatie:</strong> Er wordt een Foreign Key-kolom (bv. `ManagerID`) aan de
                            tabel
                            `Werknemer` toegevoegd, die verwijst naar de Primaire Sleutel (`WerknemerID`) van dezelfde
                            tabel.
                            Deze FK-kolom moet `NULL` toegestaan (NA) zijn, want de hoogste baas heeft geen manager.
                        </li>
                    </ul>

                    <!-- Interactieve Relatie Oplosser -->
                    <div class="bg-white rounded-lg shadow-md p-6 mt-8">
                        <h3 class="text-2xl font-semibold text-slate-900 mb-4">Interactieve Relatie Oplosser</h3>
                        <p class="text-slate-700 mb-4">Dit is het moeilijkste deel. Kies een scenario om het 'probleem'
                            en de 'oplossing' te zien.</p>

                        <select id="scenario-select"
                            class="w-full p-2 border border-slate-300 rounded-md bg-white mb-4">
                            <option value="default" disabled selected>Kies een scenario...</option>
                            <option value="1n">Scenario 1: Een 1-op-N Relatie (Klant & Bestellingen)</option>
                            <option value="nm">Scenario 2: Een N-op-M Relatie (Student & Cursus)</option>
                            <option value="multi">Scenario 3: Een Multi-valued Attribuut (Klant & Telefoonnummers)
                            </option>
                            <option value="recursive">Scenario 4: Een Recursieve Relatie (Werknemer & Manager)</option>
                            <option value="ternary">Scenario 5: Een Ternaire Relatie (Gebruiker, Tag & Boek)</option>
                            <option value="identifying">Scenario 6: Identificerende vs Niet-Identificerende Relatie
                            </option>
                            <option value="complex">Scenario 7: Complex Voorbeeld (E-commerce Systeem)</option>
                        </select>

                        <div id="problem-container" class="mt-6">
                            <h4 class="font-semibold text-lg mb-2">Het Probleem:</h4>
                            <p id="problem-text" class="text-sm text-slate-600 mb-4">Selecteer een scenario om het
                                probleem te zien.</p>
                            <div id="problem-diagram"
                                class="mt-4 p-4 border border-slate-200 rounded-md bg-slate-50 min-h-[100px]"></div>
                        </div>

                        <button id="solve-button"
                            class="mt-4 bg-emerald-600 text-white font-bold py-2 px-4 rounded-md hover:bg-emerald-700 transition-colors hidden">Toon
                            Oplossing</button>

                        <div id="solution-container" class="solution-box mt-6">
                            <h4 class="font-semibold text-lg text-emerald-800 mb-2">De Oplossing:</h4>
                            <p id="solution-rule" class="text-sm text-slate-700 mb-4"></p>
                            <div id="solution-diagram" class="mt-4 p-4 min-h-[100px]"></div>
                        </div>
                    </div>
                    <p class="text-sm text-slate-600 mt-4"><a href="#volledige-tekst-4-1" class="read-more-link">Lees
                            meer over relaties en multipliciteit →</a></p>
                </section>

                <section id="deel-5" class="mb-16 space-y-8 scroll-mt-20">
                    <h2 class="text-3xl font-bold text-emerald-800 border-b-4 border-emerald-200 pb-2">Deel 5:
                        Integriteit en Constraints</h2>
                    <p class="mb-6 text-gray-600 leading-relaxed">
                        Constraints zijn regels die worden opgelegd aan datakolommen om de integriteit, nauwkeurigheid
                        en
                        betrouwbaarheid van de data te garanderen. Ze voorkomen dat ongeldige data in de database wordt
                        ingevoerd.
                    </p>

                    <h3 class="text-2xl font-medium text-gray-700 mb-3">5.1 Null Allowed (NA) / Nulls Not Allowed (NNA)
                    </h3>
                    <p class="mb-3 text-gray-600 leading-relaxed">
                        Dit definieert of een kolom een `NULL`-waarde mag bevatten of niet.
                    </p>
                    <ul class="list-disc list-outside space-y-2 ml-6 mb-4 text-gray-600">
                        <li><strong>NULL (NA - Null Allowed):</strong> Betekent 'een onbekende of ontbrekende waarde'.
                            Dit is de
                            standaard voor de meeste kolommen. Een kolom `TweedeTelefoon` mag `NULL` zijn, want niet
                            iedereen
                            heeft een tweede telefoon.</li>
                        <li><strong>NOT NULL (NNA - Nulls Not Allowed):</strong> Dwingt af dat de kolom altijd een
                            waarde moet
                            hebben. Kan niet leeg gelaten worden. Primaire sleutels zijn *altijd* NNA. Velden zoals
                            `Naam` of
                            `Email` zijn meestal ook NNA.</li>
                    </ul>
                    <code class="font-mono bg-gray-100 text-gray-900 p-4 rounded-md overflow-x-auto block text-sm">
<pre><code>CREATE TABLE Werknemer (
    WerknemerID INT NOT NULL PRIMARY KEY,
    Naam VARCHAR(100) NOT NULL,          -- NNA: Verplicht veld
    Email VARCHAR(100) NOT NULL,          -- NNA: Verplicht veld
    BureauNummer VARCHAR(10) NULL            -- NA: Optioneel veld
);</code></pre>
                    </code>

                    <h3 class="text-2xl font-medium text-gray-700 mb-3 mt-6">5.2 On Delete Specificaties (Referentiële
                        Integriteit)</h3>
                    <p class="mb-3 text-gray-600 leading-relaxed">
                        Deze regels specificeren wat er moet gebeuren met de 'kind'-records (in de tabel met de FK)
                        wanneer het
                        bijbehorende 'ouder'-record (in de tabel met de PK) wordt verwijderd.
                    </p>

                    <h4 class="text-xl font-medium text-gray-600 mb-2 mt-4">On Delete Restrict (DTR)</h4>
                    <ul class="list-disc list-outside space-y-2 ml-6 mb-4 text-gray-600">
                        <li><strong>Gedrag:</strong> Voorkomt de verwijdering van het ouder-record zolang er nog
                            kind-records
                            bestaan die ernaar verwijzen.</li>
                        <li><strong>Voorbeeld:</strong> Je kunt `Klant` 'Jan' niet verwijderen als er nog `Bestellingen`
                            op zijn
                            naam staan. Je moet eerst zijn bestellingen verwijderen (of aan een andere klant koppelen).
                        </li>
                        <li><strong>Wanneer:</strong> Dit is de veiligste en meestal de standaardinstelling. Het dwingt
                            de
                            applicatie om de data-integriteit te beheren.</li>
                    </ul>

                    <h4 class="text-xl font-medium text-gray-600 mb-2 mt-4">On Delete Cascade (DTC)</h4>
                    <ul class="list-disc list-outside space-y-2 ml-6 mb-4 text-gray-600">
                        <li><strong>Gedrag:</strong> Als het ouder-record wordt verwijderd, worden alle bijbehorende
                            kind-records automatisch <strong>ook verwijderd</strong>.</li>
                        <li><strong>Voorbeeld:</strong> Als je `Klant` 'Jan' verwijdert, worden al zijn `Bestellingen`
                            automatisch ook uit de database verwijderd.</li>
                        <li><strong>Wanneer:</strong> Handig, maar gevaarlijk. Wordt gebruikt als de kind-records geen
                            bestaansrecht hebben zonder het ouder-record (bv. de items in een factuur; verwijder factuur
                            ->
                            verwijder ook de factuurlijnen).</li>
                    </ul>

                    <h4 class="text-xl font-medium text-gray-600 mb-2 mt-4">On Delete Set Null (DTN)</h4>
                    <ul class="list-disc list-outside space-y-2 ml-6 mb-4 text-gray-600">
                        <li><strong>Gedrag:</strong> Als het ouder-record wordt verwijderd, wordt de Foreign Key-kolom
                            in de
                            kind-records op `NULL` gezet.</li>
                        <li><strong>Voorbeeld:</strong> Een `Werknemer` is de `Manager` van een `Afdeling`. Als de
                            manager
                            (werknemer) wordt verwijderd, wordt het `ManagerID` veld in de `Afdeling` tabel `NULL` gezet
                            (de
                            afdeling bestaat nog, maar heeft tijdelijk geen manager).</li>
                        <li><strong>Vereiste:</strong> Dit werkt alleen als de Foreign Key-kolom `NULL` mag bevatten
                            (NA).</li>
                    </ul>

                    <code class="font-mono bg-gray-100 text-gray-900 p-4 rounded-md overflow-x-auto block text-sm mt-4">
<pre><code>CREATE TABLE Bestelling (
    BestellingID INT PRIMARY KEY,
    KlantID INT NOT NULL,
    FOREIGN KEY (KlantID) REFERENCES Klant(KlantID)
        ON DELETE RESTRICT  -- (DTR) Veiligste optie
);

CREATE TABLE FactuurLijn (
    LijnID INT PRIMARY KEY,
    FactuurID INT NOT NULL,
    FOREIGN KEY (FactuurID) REFERENCES Factuur(FactuurID)
        ON DELETE CASCADE   -- (DTC) Lijnen horen bij factuur
);

CREATE TABLE Afdeling (
    AfdelingID INT PRIMARY KEY,
    ManagerID INT NULL,     -- Moet NA (NULL) zijn!
    FOREIGN KEY (ManagerID) REFERENCES Werknemer(WerknemerID)
        ON DELETE SET NULL  -- (DTN) Afdeling blijft bestaan
);</code></pre>
                    </code>

                    <!-- Interactieve Datatype Kiezer -->
                    <div class="bg-white rounded-lg shadow-md p-6 mt-8">
                        <h3 class="text-2xl font-semibold text-slate-900 mb-4">Datatype Kiezer</h3>
                        <p class="text-slate-700 mb-4">De belangrijkste regel: <strong>Gebruik enkel een numeriek type
                                (int, float) als je van plan bent om er wiskundige berekeningen mee te doen.</strong>
                            Test je kennis!</p>

                        <div id="datatype-quiz">
                            <h4 id="quiz-question" class="text-lg font-semibold text-slate-800 mb-4"></h4>
                            <div id="quiz-choices" class="flex gap-4">
                                <button data-choice="string"
                                    class="quiz-choice w-full bg-emerald-500 hover:bg-emerald-600 text-white font-bold py-3 px-4 rounded-md">String
                                    (tekst)</button>
                                <button data-choice="number"
                                    class="quiz-choice w-full bg-teal-500 hover:bg-teal-600 text-white font-bold py-3 px-4 rounded-md">Number
                                    (int/float)</button>
                            </div>
                            <div id="quiz-feedback" class="mt-4 p-3 rounded-md text-sm hidden"></div>
                        </div>
                    </div>

                    <!-- Constraint Builder -->
                    <div class="bg-white rounded-lg shadow-md p-6 mt-8">
                        <h3 class="text-2xl font-semibold text-slate-900 mb-4">Constraint Builder</h3>
                        <p class="text-slate-700 mb-4">Bouw interactief een constraint en zie de SQL output.</p>

                        <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                            <div>
                                <label class="block text-sm font-medium text-slate-700 mb-2">Tabelnaam:</label>
                                <input type="text" id="constraint-table-name"
                                    class="w-full p-2 border border-slate-300 rounded-md" placeholder="bv. Klant"
                                    value="Klant">
                            </div>
                            <div>
                                <label class="block text-sm font-medium text-slate-700 mb-2">Kolomnaam:</label>
                                <input type="text" id="constraint-column-name"
                                    class="w-full p-2 border border-slate-300 rounded-md" placeholder="bv. email"
                                    value="email">
                            </div>
                        </div>

                        <div class="mb-4">
                            <label class="block text-sm font-medium text-slate-700 mb-2">Constraint Type:</label>
                            <select id="constraint-type" class="w-full p-2 border border-slate-300 rounded-md">
                                <option value="unique">UNIQUE (Alternatieve Sleutel)</option>
                                <option value="check">CHECK (Waardebeperking)</option>
                                <option value="default">DEFAULT (Standaardwaarde)</option>
                            </select>
                        </div>

                        <div id="constraint-value-container" class="mb-4">
                            <label class="block text-sm font-medium text-slate-700 mb-2">Waarde/Voorwaarde:</label>
                            <input type="text" id="constraint-value"
                                class="w-full p-2 border border-slate-300 rounded-md"
                                placeholder="Voor CHECK: prijs > 0, Voor DEFAULT: 'In behandeling'">
                        </div>

                        <button id="generate-constraint-btn"
                            class="bg-emerald-600 text-white font-bold py-2 px-4 rounded-md hover:bg-emerald-700 transition-colors mb-4">Genereer
                            SQL</button>

                        <div id="constraint-sql-output"
                            class="mt-4 p-4 bg-slate-800 text-slate-200 rounded-md font-mono text-sm hidden">
                            <div class="flex justify-between items-center mb-2">
                                <span class="text-slate-400">SQL Output:</span>
                                <button id="copy-constraint-sql"
                                    class="text-emerald-400 hover:text-emerald-300 text-xs">Kopieer</button>
                            </div>
                            <pre id="constraint-sql-code"></pre>
                        </div>
                    </div>
                    <p class="text-sm text-slate-600 mt-4"><a href="#volledige-tekst-5-1" class="read-more-link">Lees
                            meer over constraints en integriteit →</a></p>
                </section>

                <section id="deel-6" class="mb-16 space-y-8 scroll-mt-20">
                    <h2 class="text-3xl font-bold text-emerald-800 border-b-4 border-emerald-200 pb-2">Deel 6: SQL
                        Implementatie Volgorde</h2>
                    <p class="mb-6 text-gray-600 leading-relaxed">
                        De volgorde waarin tabellen worden aangemaakt (`CREATE`) en verwijderd (`DROP`) is cruciaal
                        vanwege de
                        Foreign Key-afhankelijkheden.
                    </p>

                    <h3 class="text-2xl font-medium text-gray-700 mb-3">CREATE TABLE Volgorde (Top-Down)</h3>
                    <p class="mb-3 text-gray-600 leading-relaxed">
                        Je moet tabellen aanmaken in een 'top-down' volgorde. Een tabel waarnaar wordt verwezen (de
                        'ouder'
                        tabel) moet bestaan voordat de tabel die ernaar verwijst (de 'kind' tabel) kan worden
                        aangemaakt.
                    </p>
                    <ol class="list-decimal list-outside space-y-2 ml-6 mb-4 text-gray-600">
                        <li>Maak eerst de 'parent' tabellen (de 'één'-kant, bv. `Klant`, `Gerecht`).</li>
                        <li>Maak daarna de 'child' tabellen die ernaar verwijzen (de 'veel'-kant, bv. `Bestelling`).
                        </li>
                        <li>Maak als laatste de associatietabellen, bv. `BestellingGerecht` (verwijst naar `Bestelling`
                            en
                            `Gerecht`).</li>
                    </ol>

                    <h3 class="text-2xl font-medium text-gray-700 mb-3 mt-6">DROP TABLE Volgorde (Bottom-Up)</h3>
                    <p class="mb-3 text-gray-600 leading-relaxed">
                        De volgorde is exact omgekeerd aan de creatie. Je kunt een 'ouder' tabel niet verwijderen als er
                        nog een
                        'kind' tabel is die ernaar verwijst.
                    </p>
                    <ol class="list-decimal list-outside space-y-2 ml-6 mb-4 text-gray-600">
                        <li>Verwijder eerst de tabellen die verwijzen (associatietabellen zoals `BestellingGerecht`).
                        </li>
                        <li>Verwijder daarna de 'child' tabellen (`Bestelling`).</li>
                        <li>Verwijder als laatste de 'parent' tabellen (`Klant`, `Gerecht`).</li>
                    </ol>

                    <!-- SQL Kijker -->
                    <div class="bg-white rounded-lg shadow-md p-6 mt-8">
                        <h3 class="text-2xl font-semibold text-slate-900 mb-4">SQL Kijker</h3>
                        <p class="text-slate-700 mb-4">Klik op de entiteiten om de bijbehorende SQL code te zien.</p>

                        <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                            <!-- Linker kolom: ERD -->
                            <div>
                                <h4 class="text-lg font-semibold text-slate-900 mb-4">Logisch Model (ERD)</h4>
                                <div class="space-y-4">
                                    <div id="sql-diagram-klant" class="entity-box interactive-box">
                                        <strong>Klant</strong> (1)
                                        <div class="text-sm font-normal text-left mt-2 pl-4">
                                            <u>id (PK)</u><br>
                                            naam<br>
                                            email (AK)
                                        </div>
                                    </div>
                                    <div class="text-center text-slate-500 text-sm font-mono">| <br> | (heeft) <br> |
                                    </div>
                                    <div id="sql-diagram-bestelling" class="entity-box interactive-box">
                                        <strong>Bestelling</strong> (N)
                                        <div class="text-sm font-normal text-left mt-2 pl-4">
                                            <u>id (PK)</u><br>
                                            orderdatum<br>
                                            <em>klantId (FK)</em>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- Rechter kolom: SQL Code -->
                            <div>
                                <h4 class="text-lg font-semibold text-slate-900 mb-4">Fysiek Model (SQL)</h4>
                                <code id="sql-code-snippet" class="text-sm">
-- Klik op een entiteit (links)
-- om de SQL code te zien.
                        </code>
                            </div>
                        </div>
                    </div>

                    <!-- SQL Volgorde Simulator -->
                    <div class="bg-white rounded-lg shadow-md p-6 mt-8">
                        <h3 class="text-2xl font-semibold text-slate-900 mb-4">SQL Volgorde Simulator</h3>
                        <p class="text-slate-700 mb-4">Sleep de tabellen in de juiste volgorde voor CREATE of DROP
                            statements.</p>

                        <div class="mb-4">
                            <button id="sql-order-mode-create"
                                class="sql-order-mode-btn bg-emerald-600 text-white font-bold py-2 px-4 rounded-md mr-2">CREATE
                                Volgorde</button>
                            <button id="sql-order-mode-drop"
                                class="sql-order-mode-btn bg-slate-500 text-white font-bold py-2 px-4 rounded-md">DROP
                                Volgorde</button>
                        </div>

                        <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                            <div>
                                <h4 class="font-semibold mb-2">Beschikbare Tabellen:</h4>
                                <div id="sql-order-available"
                                    class="border border-slate-300 rounded-lg p-4 min-h-[200px] bg-slate-50">
                                    <!-- Tabellen worden dynamisch geladen -->
                                </div>
                            </div>
                            <div>
                                <h4 class="font-semibold mb-2">Volgorde:</h4>
                                <div id="sql-order-sequence"
                                    class="border border-slate-300 rounded-lg p-4 min-h-[200px] bg-slate-50">
                                    <p class="text-slate-500 text-sm">Sleep tabellen hierheen...</p>
                                </div>
                                <button id="sql-order-validate"
                                    class="mt-4 bg-emerald-600 text-white font-bold py-2 px-4 rounded-md hover:bg-emerald-700 transition-colors">Valideer
                                    Volgorde</button>
                                <div id="sql-order-feedback" class="mt-3 p-3 rounded-md text-sm hidden"></div>
                            </div>
                        </div>
                    </div>
                    <p class="text-sm text-slate-600 mt-4"><a href="#volledige-tekst-6-1" class="read-more-link">Lees
                            meer over SQL implementatie →</a></p>
                </section>

                <section id="conclusie"
                    class="mb-16 space-y-8 p-6 bg-emerald-50 border-l-4 border-emerald-500 rounded-r-lg shadow-sm scroll-mt-20">
                    <h2 class="text-3xl font-bold text-emerald-800 border-b pb-2 border-emerald-200">Conclusie</h2>
                    <p class="text-gray-700 leading-relaxed">
                        ERD-modellering is een gestructureerd en progressief proces dat evolueert van een abstract
                        conceptueel
                        model (de 'wat'-vraag) naar een gedetailleerd fysiek model (de 'hoe'-vraag). Elke stap voegt een
                        diepere
                        laag van specificatie toe: van het definiëren van attributen (met aandacht voor het vermijden
                        van
                        samengestelde en berekende data), tot het architecturaal opzetten van sleutels (met een voorkeur
                        voor
                        surrogaat id sleutels), en het nauwkeurig definiëren van relaties.
                    </p>
                    <p class="text-gray-700 leading-relaxed mt-3">
                        De kern van een robuust model ligt in het correct toepassen van de regels voor de plaatsing van
                        Foreign
                        Keys (altijd aan de 'veel'-kant) en het oplossen van M:N-relaties via associatie-entiteiten. De
                        uiteindelijke specificatie van datatypes, Null-toegestaanheid (NA/NNA) en On Delete-gedrag
                        (DTC/DTR/DTN)
                        vertaalt de businesslogica naar afdwingbare integriteitsregels. Een correcte vertaling van dit
                        fysieke
                        model naar SQL `CREATE` statements, met respect voor de top-down afhankelijkheden, is de laatste
                        stap
                        naar een functionele en integere database.
                    </p>
                </section>

                <!-- EXAMENOPDRACHT SECTIE -->
                <section id="examenopdracht" class="mb-16 space-y-8 scroll-mt-20">
                    <h2 class="text-3xl font-bold text-emerald-800 border-b-4 border-emerald-200 pb-2">Examenopdracht:
                        Book Network</h2>

                    <div class="bg-emerald-50 border-l-4 border-emerald-500 p-6 rounded-r-lg mb-6">
                        <h3 class="text-xl font-semibold text-emerald-900 mb-3">Relationeel modelleren</h3>
                        <p class="text-slate-700 mb-4">Bouw een volledig model op, inclusief datatypes en FK
                            specificaties. Voor 5 relaties geef je de multipliciteiten en relatiebeschrijvingen, je
                            kiest zelf voor welke relaties je dit doet. Je mag hiervoor slechts één veel-op-veel relatie
                            gebruiken.</p>
                        <p class="text-slate-700 mb-4">Geef voor 5 entiteiten de soort aan (kern, karakteristiek of
                            associatie). Kies zelf voor welke 5 entiteiten je dit doet, maar zorg dat je van elke soort
                            minstens één aanduidt.</p>
                        <p class="text-slate-700 font-semibold">Beperk je voor deze opgave tot het gevraagde, voeg geen
                            extra entiteiten toe die, in realiteit nodig zijn, maar waarover niets gezegd wordt in de
                            opgave.</p>
                    </div>

                    <div class="bg-white rounded-lg shadow-md p-6">
                        <h3 class="text-2xl font-bold text-emerald-800 mb-4">Book Network</h3>
                        <p class="text-slate-700 mb-6">Je bouwt een sociaal netwerk voor fanatieke lezers, via dit
                            sociaal netwerk kunnen gebruikers de gelezen boeken bijhouden en organiseren. Daarnaast
                            kunnen gebruikers ook reviews schrijven.</p>

                        <div class="space-y-6">
                            <div>
                                <h4 class="text-xl font-semibold text-slate-800 mb-3">Boeken</h4>
                                <p class="text-slate-700 mb-2">Voor elk boek moet de titel, beschrijving, het unieke
                                    ISBN nummer, de publicatiedatum, de cover, het aantal pagina's en de uitgever
                                    bewaard worden. Voor een uitgever moet eventueel een website bewaard worden. Voor
                                    elk boek wordt een score weergegeven op de website, dit is een score tussen 1 en 5.
                                </p>
                                <p class="text-slate-700 mb-2">Een boek kan door één of meerdere auteurs geschreven
                                    worden. Een auteur heeft minimaal een voornaam. In de meeste gevallen wordt ook de
                                    achternaam bewaard, als deze bekend is. Voor sommige historische auteurs, zoals
                                    Homerus, is er geen achternaam bekend. Een auteur heeft eventueel een geverifieerde
                                    gebruikersaccount. Indien een auteur zijn/haar geverifieerde account afsluit, moet
                                    de auteursinformatie (naam, voornaam) nog steeds bewaard blijven.</p>
                            </div>

                            <div>
                                <h4 class="text-xl font-semibold text-slate-800 mb-3">Gebruikers</h4>
                                <p class="text-slate-700 mb-2">Gebruikers kunnen zich registreren op de website en
                                    moeten hiervoor hun e-mailadres en wachtwoord opgeven. Daarnaast kunnen ze eventueel
                                    een voornaam, achternaam, en leeftijd opgeven en kan een gebruiker eventueel een
                                    profielfoto uploaden. Tenslotte kan een gebruiker "Librarian" status aanvragen, een
                                    gebruiker kan deze status slechts één keer aanvragen. Als deze status toegekend
                                    wordt, kan de gebruiker de boeken op de website aanpassen.</p>
                            </div>

                            <div>
                                <h4 class="text-xl font-semibold text-slate-800 mb-3">Boekenplanken</h4>
                                <p class="text-slate-700 mb-2">Een gebruiker kan "boeken schappen" aanmaken, deze kunnen
                                    gebruikt worden om boeken te organiseren. Bijvoorbeeld een schap voor gelezen, te
                                    lezen, en favoriete boeken. Een gebruiker kan meerdere schappen aanmaken en in elk
                                    van deze schappen meerdere boeken plaatsen. Een schap heeft een naam en is eventueel
                                    als exclusief aangeduid. Een boek kan slechts op één van de exclusieve planken
                                    geplaatst worden. Een boek kan, ook als het in exclusief schap geplaatst is, nog
                                    steeds in alle andere niet-exclusieve schappen geplaatst worden.</p>
                                <p class="text-slate-700 font-semibold">Als een gebruiker zijn/haar account verwijderd,
                                    moeten al zijn/haar boekenplanken ook verwijderd worden.</p>
                            </div>

                            <div>
                                <h4 class="text-xl font-semibold text-slate-800 mb-3">Reviews</h4>
                                <p class="text-slate-700 mb-2">Een gebruiker kan reviews plaatsen voor een boek, een
                                    review bestaat minimaal uit een rating tussen 1 en 5. Daarnaast kan een review ook
                                    een uitgeschreven argument bevatten dat meer uitleg geeft over de gegeven score.
                                    Tenslotte moeten we ook de datum kennen waarop de review geplaatst wordt.</p>
                                <p class="text-slate-700 font-semibold">Als een gebruiker zijn/haar account verwijdert,
                                    dan moeten de geplaatste reviews blijven bestaan.</p>
                            </div>

                            <div>
                                <h4 class="text-xl font-semibold text-slate-800 mb-3">Gelezen boeken</h4>
                                <p class="text-slate-700 mb-2">Een gebruiker kan de website gebruiken om bij te houden
                                    welke boeken hij/zij gelezen heeft. We moeten weten wanneer het boek gelezen is,
                                    i.e. tussen welke datums.</p>
                                <p class="text-slate-700 font-semibold">Als een gebruiker verwijderd wordt, moet ook
                                    alle informatie over alle gelezen boeken verwijderd worden.</p>
                            </div>
                        </div>
                    </div>
                </section>

                <!-- ERD BUILDER SECTIE -->
                <section id="examen-erd-builder" class="mb-16 space-y-8 scroll-mt-20">
                    <h2 class="text-3xl font-bold text-emerald-800 border-b-4 border-emerald-200 pb-2">Interactieve ERD
                        Builder</h2>
                    <p class="text-slate-700 mb-4">Bouw je ERD model hier. Gebruik de toolbar om entiteiten toe te
                        voegen en relaties te tekenen. Dubbelklik op een entiteit om deze te bewerken.</p>

                    <div class="bg-white rounded-lg shadow-md p-6">
                        <!-- Toolbar -->
                        <div class="erd-toolbar">
                            <button id="erd-btn-select" class="erd-toolbar-btn active"
                                data-mode="select">Select</button>
                            <button id="erd-btn-add-entity" class="erd-toolbar-btn" data-mode="add-entity">+
                                Entiteit</button>
                            <button id="erd-btn-relationship" class="erd-toolbar-btn"
                                data-mode="relationship">Relatie</button>
                            <button id="erd-btn-delete" class="erd-toolbar-btn" data-mode="delete">Verwijder</button>
                            <button id="erd-btn-validate"
                                class="erd-toolbar-btn bg-emerald-600 text-white hover:bg-emerald-700">Valideer</button>
                            <button id="erd-btn-reset"
                                class="erd-toolbar-btn bg-slate-500 text-white hover:bg-slate-600">Reset</button>
                            <button id="erd-btn-export"
                                class="erd-toolbar-btn bg-teal-600 text-white hover:bg-teal-700">Export JSON</button>
                        </div>

                        <!-- Canvas -->
                        <div id="erd-canvas" class="erd-canvas select-mode">
                            <svg id="erd-svg"
                                style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;">
                                <defs>
                                    <marker id="arrowhead" markerWidth="10" markerHeight="10" refX="9" refY="3"
                                        orient="auto">
                                        <polygon points="0 0, 10 3, 0 6" fill="#475569" />
                                    </marker>
                                </defs>
                            </svg>
                        </div>
                    </div>

                    <!-- Editor Panel -->
                    <div id="erd-editor-panel" class="erd-editor-panel">
                        <div class="p-6">
                            <div class="flex justify-between items-center mb-4">
                                <h3 class="text-xl font-bold text-slate-900">Entiteit Editor</h3>
                                <button id="erd-editor-close" class="text-slate-500 hover:text-slate-700">✕</button>
                            </div>

                            <div class="space-y-4">
                                <div>
                                    <label class="block text-sm font-semibold text-slate-700 mb-1">Entiteit Naam</label>
                                    <input type="text" id="erd-entity-name"
                                        class="w-full p-2 border border-slate-300 rounded-md" placeholder="bv. Book">
                                </div>

                                <div>
                                    <label class="block text-sm font-semibold text-slate-700 mb-1">Entiteit Type</label>
                                    <select id="erd-entity-type" class="w-full p-2 border border-slate-300 rounded-md">
                                        <option value="">Geen</option>
                                        <option value="kern">Kern</option>
                                        <option value="karakteristiek">Karakteristiek</option>
                                        <option value="associatie">Associatie</option>
                                    </select>
                                </div>

                                <div>
                                    <label class="block text-sm font-semibold text-slate-700 mb-2">Attributen</label>
                                    <div id="erd-attributes-list" class="space-y-2 mb-2 max-h-64 overflow-y-auto">
                                        <!-- Attributen worden hier dynamisch toegevoegd -->
                                    </div>
                                    <button id="erd-btn-add-attribute"
                                        class="w-full p-2 bg-emerald-600 text-white rounded-md hover:bg-emerald-700">+
                                        Attribuut</button>
                                </div>

                                <button id="erd-btn-save-entity"
                                    class="w-full p-3 bg-emerald-600 text-white rounded-md hover:bg-emerald-700 font-semibold">Opslaan</button>
                            </div>
                        </div>
                    </div>

                    <!-- Relationship Editor Modal -->
                    <div id="erd-relationship-modal"
                        class="hidden fixed inset-0 bg-black bg-opacity-50 z-50 flex items-center justify-center">
                        <div class="bg-white rounded-lg p-6 max-w-md w-full mx-4">
                            <h3 class="text-xl font-bold text-slate-900 mb-4">Relatie Editor</h3>
                            <div class="space-y-4">
                                <div>
                                    <label class="block text-sm font-semibold text-slate-700 mb-1">Van</label>
                                    <input type="text" id="rel-from"
                                        class="w-full p-2 border border-slate-300 rounded-md" readonly>
                                </div>
                                <div>
                                    <label class="block text-sm font-semibold text-slate-700 mb-1">Naar</label>
                                    <input type="text" id="rel-to" class="w-full p-2 border border-slate-300 rounded-md"
                                        readonly>
                                </div>
                                <div>
                                    <label
                                        class="block text-sm font-semibold text-slate-700 mb-1">Multipliciteit</label>
                                    <select id="rel-multiplicity" class="w-full p-2 border border-slate-300 rounded-md">
                                        <option value="1:1">1:1</option>
                                        <option value="1:N">1:N</option>
                                        <option value="N:M">N:M</option>
                                    </select>
                                </div>
                                <div>
                                    <label
                                        class="block text-sm font-semibold text-slate-700 mb-1">Relatiebeschrijving</label>
                                    <textarea id="rel-description" class="w-full p-2 border border-slate-300 rounded-md"
                                        rows="3" placeholder="Beschrijving van de relatie..."></textarea>
                                </div>
                                <div>
                                    <label class="block text-sm font-semibold text-slate-700 mb-1">ON DELETE</label>
                                    <select id="rel-ondelete" class="w-full p-2 border border-slate-300 rounded-md">
                                        <option value="DTC">DTC (Cascade)</option>
                                        <option value="DTR">DTR (Restrict)</option>
                                        <option value="DTN">DTN (Set Null)</option>
                                    </select>
                                </div>
                                <div class="flex gap-2">
                                    <button id="rel-btn-save"
                                        class="flex-1 p-2 bg-emerald-600 text-white rounded-md hover:bg-emerald-700">Opslaan</button>
                                    <button id="rel-btn-cancel"
                                        class="flex-1 p-2 bg-slate-500 text-white rounded-md hover:bg-slate-600">Annuleren</button>
                                </div>
                            </div>
                        </div>
                    </div>
                </section>

                <!-- FEEDBACK SECTIE -->
                <section id="examen-feedback" class="mb-16 space-y-8 scroll-mt-20 hidden">
                    <h2 class="text-3xl font-bold text-emerald-800 border-b-4 border-emerald-200 pb-2">Validatie
                        Feedback</h2>

                    <div class="bg-white rounded-lg shadow-md p-6">
                        <!-- Dashboard -->
                        <div class="feedback-dashboard">
                            <div class="feedback-card">
                                <h3 class="font-semibold text-slate-900 mb-2">Totaal Score</h3>
                                <div class="text-3xl font-bold" id="feedback-total-score">0/0</div>
                                <div class="progress-bar">
                                    <div class="progress-fill" id="feedback-total-progress" style="width: 0%"></div>
                                </div>
                            </div>
                            <div class="feedback-card">
                                <h3 class="font-semibold text-slate-900 mb-2">Entiteiten</h3>
                                <div class="text-2xl font-bold" id="feedback-entities-score">0/0</div>
                                <div class="progress-bar">
                                    <div class="progress-fill" id="feedback-entities-progress" style="width: 0%"></div>
                                </div>
                            </div>
                            <div class="feedback-card">
                                <h3 class="font-semibold text-slate-900 mb-2">Attributen</h3>
                                <div class="text-2xl font-bold" id="feedback-attributes-score">0/0</div>
                                <div class="progress-bar">
                                    <div class="progress-fill" id="feedback-attributes-progress" style="width: 0%">
                                    </div>
                                </div>
                            </div>
                            <div class="feedback-card">
                                <h3 class="font-semibold text-slate-900 mb-2">Relaties</h3>
                                <div class="text-2xl font-bold" id="feedback-relationships-score">0/0</div>
                                <div class="progress-bar">
                                    <div class="progress-fill" id="feedback-relationships-progress" style="width: 0%">
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Gedetailleerde Feedback -->
                        <div class="mt-6 space-y-4">
                            <div id="feedback-entities-detail" class="hidden">
                                <h3 class="text-xl font-semibold text-slate-900 mb-3">Entiteiten Feedback</h3>
                                <div id="feedback-entities-content"></div>
                            </div>
                            <div id="feedback-attributes-detail" class="hidden">
                                <h3 class="text-xl font-semibold text-slate-900 mb-3">Attributen Feedback</h3>
                                <div id="feedback-attributes-content"></div>
                            </div>
                            <div id="feedback-relationships-detail" class="hidden">
                                <h3 class="text-xl font-semibold text-slate-900 mb-3">Relaties Feedback</h3>
                                <div id="feedback-relationships-content"></div>
                            </div>
                            <div id="feedback-constraints-detail" class="hidden">
                                <h3 class="text-xl font-semibold text-slate-900 mb-3">Constraints Feedback</h3>
                                <div id="feedback-constraints-content"></div>
                            </div>
                            <div id="feedback-rules-detail" class="hidden">
                                <h3 class="text-xl font-semibold text-slate-900 mb-3">Algemene Regels Feedback</h3>
                                <div id="feedback-rules-content"></div>
                            </div>
                        </div>
                    </div>
                </section>

                <!-- MODEL OPLOSSING SECTIE -->
                <section id="examen-model-solution" class="mb-16 space-y-8 scroll-mt-20 hidden">
                    <h2 class="text-3xl font-bold text-emerald-800 border-b-4 border-emerald-200 pb-2">Model Oplossing
                    </h2>

                    <div class="bg-white rounded-lg shadow-md p-6">
                        <button id="toggle-model-solution"
                            class="mb-4 p-3 bg-purple-600 text-white rounded-md hover:bg-purple-700 font-semibold">Toon
                            Model Oplossing</button>

                        <div id="model-solution-content" class="hidden">
                            <p class="text-slate-700 mb-4">Hieronder zie je de model oplossing van de leerkracht.
                                Vergelijk deze met je eigen oplossing om te zien wat je goed hebt gedaan en wat je kunt
                                verbeteren.</p>

                            <!-- Show image on both mobile and desktop -->
                            <div id="model-solution-image" class="mb-4">
                                <img src="ModeloplossingTussentijdsexamen.jpg" alt="Book Network Model Oplossing"
                                    class="w-full h-auto rounded-lg shadow-md">
                            </div>

                            <!-- Desktop: Show interactive ERD -->
                            <div id="model-solution-erd" class="erd-canvas hidden md:block">
                                <!-- Model oplossing ERD wordt hier gerenderd -->
                            </div>
                        </div>
                    </div>
                </section>

                <!-- NIEUWE SECTIE: VOLLEDIGE TEKST -->
                <section id="volledige-tekst" class="mb-16 space-y-8 scroll-mt-20">
                    <h2 class="text-3xl font-bold text-emerald-800 border-b-4 border-emerald-200 pb-2">Volledige
                        Tekstuele Uiteenzetting</h2>

                    <p class="mb-4 text-lg font-semibold text-gray-800">De Principes van Relationele Datamodellering:
                        Een
                        Theoretische en Praktische Gids</p>

                    <h3>Deel 1: De Fundamenten van Relationele Datamodellering</h3>

                    <h4 id="volledige-tekst-1-1">1.1 De Essentie: Van Data naar Informatie en Databases</h4>
                    <p>Voordat het ontwerp van een datamodel kan beginnen, is een helder begrip van de basisconcepten
                        essentieel. De concepten 'data' en 'informatie' worden vaak door elkaar gebruikt, maar
                        vertegenwoordigen
                        fundamenteel verschillende niveaus van abstractie.</p>
                    <p><strong>Data</strong> zijn de ruwe, ongeorganiseerde feiten die worden verzameld. Dit kunnen
                        cijfers,
                        tekst of andere observaties zijn die op zichzelf geen interpretatie of context bieden. Een
                        voorbeeld is
                        een lange lijst van productprijzen die wekelijks wordt genoteerd.</p>
                    <p><strong>Informatie</strong> ontstaat wanneer data wordt verwerkt, georganiseerd, gestructureerd
                        en
                        gepresenteerd binnen een specifieke context om het nuttig te maken. Informatie is
                        geïnterpreteerde data.
                        In het voorbeeld van de productprijzen zou de informatie de conclusie kunnen zijn dat de
                        gemiddelde
                        prijs van een product het afgelopen jaar is gestegen.</p>
                    <p>De brug tussen ruwe data en bruikbare informatie wordt vaak geslagen door een
                        <strong>database</strong>.
                        Een database (of databank) wordt gedefinieerd als een verzameling van permanente (of
                        persistente)
                        gegevens die zijn opgeslagen in een logische structuur. Deze verzameling gegevens wordt beheerd
                        door een
                        softwarepakket dat bekend staat als een <strong>Database Management System (DBMS)</strong>.
                    </p>

                    <h4 id="volledige-tekst-1-2">1.2 Het Relationele Model: Eigenschappen van Tabellen, Rijen en
                        Kolommen</h4>
                    <p>Het meest gebruikte model voor het structureren van databases is het relationele model,
                        geïntroduceerd
                        door E.F. Codd in 1970. In dit model worden gegevens opgeslagen in tabellen, die de conceptuele
                        basis
                        vormen van de structuur.</p>
                    <p>Een <strong>tabel</strong> bestaat uit:</p>
                    <ul>
                        <li><strong>Rijen</strong> (ook wel records genoemd): Elke rij vertegenwoordigt één uniek
                            exemplaar van
                            het object dat de tabel beschrijft (bv. één specifieke klant, één specifieke bestelling).
                        </li>
                        <li><strong>Kolommen</strong> (ook wel attributen of velden genoemd): Elke kolom beschrijft een
                            specifieke eigenschap van dat object (bv. de voornaam, het adres, de besteldatum).</li>
                    </ul>
                    <p>Het relationele model is niet zomaar een willekeurige spreadsheet; het wordt beheerst door
                        strikte,
                        fundamentele eigenschappen die de data-integriteit waarborgen:</p>
                    <ul>
                        <li>De volgorde van de rijen in een tabel is onbelangrijk.</li>
                        <li>De volgorde van de kolommen in een tabel is onbelangrijk.</li>
                        <li>Elke waarde in een specifieke kolom moet van hetzelfde type (datatype) zijn.</li>
                        <li>De kruising van een specifieke rij en een specifieke kolom kan maar één waarde bevatten
                            (atomische
                            waarden). Dit principe verklaart waarom samengestelde gegevens, zoals het opslaan van "Jan
                            Peeters"
                            in één veld, problematisch zijn.</li>
                        <li><strong>Cruciale Eigenschap:</strong> Identieke rijen mogen niet voorkomen in een tabel.
                        </li>
                    </ul>
                    <p>Deze regel vormt de fundamentele rechtvaardiging voor het bestaan van sleutels: als geen twee
                        rijen
                        identiek mogen zijn, moet er een mechanisme bestaan om elke rij uniek te identificeren. Dit
                        leidt direct
                        tot het concept van de Primaire Sleutel.</p>

                    <h4>1.3 De Hiërarchie van Datamodellen: Van Concept tot Implementatie</h4>
                    <p>Een datamodel is het resultaat van een gegevensanalyse en dient als de blauwdruk voor de
                        database. Het is
                        een cruciaal communicatiemiddel tussen de business (die de eisen definieert) en de ontwikkelaars
                        (die de
                        database bouwen). Dit proces verloopt in drie fasen van toenemende detaillering, die een brug
                        slaan van
                        abstracte business-semantiek naar concrete fysieke implementatie.</p>

                    <h5>1.3.0 Het Theoretische Fundament: Codd's Relationele Model</h5>
                    <p>De basis voor moderne datamodellering werd in 1969-1970 gelegd door Edgar F. Codd. Codd's doel
                        was om de
                        data-opslag <strong>onafhankelijk</strong> te maken van de fysieke hardware-implementatie en de
                        applicaties die de data benaderden. Zijn relationele model is een wiskundige benadering,
                        gebaseerd op
                        verzamelingenleer (set theory), die data organiseert in tabellen (of "relaties").</p>
                    <p>Dit theoretische raamwerk vormt de kern van het <strong>Logische Model (LDM)</strong>. Het LDM is
                        in
                        essentie de praktische toepassing van Codd's relationele theorie, waarbij de focus ligt op een
                        pure,
                        genormaliseerde structuur van tabellen en sleutels, onafhankelijk van een specifieke
                        softwareleverancier.</p>

                    <h5>1.3.1 Het Conceptuele Model (CDM)</h5>
                    <p>Het conceptuele model (CDM) is het hoogste abstractieniveau. Het beschrijft <strong>wat</strong>
                        er in
                        het systeem moet worden opgeslagen en focust op de kernentiteiten en hun onderlinge verbanden,
                        zoals
                        begrepen door de business.</p>
                    <ul>
                        <li><strong>Detailniveau:</strong> Zeer abstract. Het dient primair als een
                            <strong>communicatiemiddel</strong> tussen data-architecten en business-stakeholders (bv.
                            managers,
                            analisten) om te verzekeren dat de <strong>semantiek</strong> (de betekenis) van de business
                            correct
                            is vastgelegd. Het bevat geen attributen (of slechts de hoogstnoodzakelijke), geen datatypes
                            en geen
                            sleutels.
                        </li>
                        <li><strong>Relaties:</strong> Veel-op-veel (<code>M:N</code>) relaties zijn in deze fase
                            toegestaan en
                            zelfs gewenst, omdat ze de bedrijfsrealiteit vaak direct weerspiegelen (bv. "een auteur kan
                            veel
                            boeken schrijven, en een boek kan veel auteurs hebben"). Technische oplossingen voor deze
                            relaties
                            worden bewust weggelaten om de complexiteit laag te houden.</li>
                    </ul>

                    <h5>1.3.2 Het Logische Model (LDM)</h5>
                    <p>Het logische model (LDM) vertaalt het abstracte conceptuele model naar een concrete, maar
                        database-onafhankelijke structuur. Het beschrijft <strong>hoe</strong> de data gestructureerd
                        wordt,
                        gebaseerd op de principes van het relationele model.</p>
                    <ul>
                        <li><strong>Detailniveau:</strong> Dit is de <strong>architecturale blauwdruk</strong>. Het
                            bevat alle
                            entiteiten en hun attributen. Sleutels (PK, FK) worden aangeduid om de relaties te
                            formaliseren.
                        </li>
                        <li><strong>Datatypes:</strong> Er worden algemene, DBMS-onafhankelijke datatypes gebruikt,
                            zoals
                            <code>int</code>, <code>float</code>, <code>string</code>, <code>date</code> of
                            <code>boolean</code>.
                        </li>
                        <li><strong>Relaties:</strong> Veel-op-veel (<code>M:N</code>) relaties zijn in deze fase niet
                            langer
                            toegestaan. Ze <strong>moeten</strong> worden opgelost (genormaliseerd) door ze te vervangen
                            door
                            associatietabellen (tussentabellen) en twee <code>1:M</code> relaties. Dit is een directe
                            toepassing
                            van Codd's normalisatieregels.</li>
                    </ul>

                    <h5>1.3.3 Het Fysieke Model (PDM)</h5>
                    <p>Het fysieke model (PDM) is de definitieve blauwdruk voor de implementatie en is specifiek voor
                        één
                        gekozen Relationeel Database Management Systeem (RDBMS), zoals Oracle, MySQL of SQL Server.</p>
                    <ul>
                        <li><strong>Detailniveau:</strong> Dit model is de <strong>implementatiegids</strong> en is
                            volledig
                            uitgewerkt. Het vertaalt de logische architectuur naar een concrete, geoptimaliseerde
                            implementatie.
                        </li>
                        <li><strong>Sleutels:</strong> Alle Primaire Sleutels (PK), Alternatieve Sleutels (AK) en
                            Foreign Keys
                            (FK) zijn gedefinieerd.</li>
                        <li><strong>Datatypes:</strong> Er worden specifieke datatypes gebruikt die horen bij het RDBMS
                            (bv.
                            <code>varchar(200)</code> en <code>datetime2</code> in SQL Server, versus
                            <code>varchar2(200)</code>
                            en <code>date</code> in Oracle).
                        </li>
                        <li><strong>Constraints:</strong> Alle beperkingen, zoals Null Allowed (NA) / Nulls Not Allowed
                            (NNA) en
                            de On delete specificaties (DTC, DTR, DTN), zijn hier vastgelegd.</li>
                        <li><strong>Performance:</strong> Dit model bevat ook fysieke objecten die de performance
                            beïnvloeden,
                            zoals indexen. Soms wordt hier bewust <strong>gedenormaliseerd</strong> (afgeweken van het
                            LDM) om
                            de snelheid van veelvoorkomende queries te verhogen.</li>
                    </ul>

                    <h5>1.3.4 Visuele Progressie van de Modellen</h5>
                    <p>Om de evolutie van een datamodel te illustreren, volgt hier een scenario: "Studenten schrijven
                        zich in
                        voor Cursussen".</p>

                    <h5 class="font-bold">Visueel Voorbeeld 1: Het Conceptuele Model (CDM)</h5>
                    <p>Het CDM focust op de business-semantiek. Het model is eenvoudig en direct leesbaar voor een
                        administrator
                        of decaan.</p>
                    <ul>
                        <li>Een entiteit Student.</li>
                        <li>Een entiteit Cursus.</li>
                        <li>Een <code>M:N</code> (veel-op-veel) relatie "schrijft in" verbindt de twee.</li>
                    </ul>
                    <pre><code>
+-----------+         +---------+
| Student |---(M:N)---| Cursus |
+-----------+         +---------+
</code></pre>

                    <h5 class="font-bold">Visueel Voorbeeld 2: Het Logische Model (LDM)</h5>
                    <p>Het LDM lost de <code>M:N</code> relatie op en definieert de structuur. Dit is de
                        genormaliseerde,
                        database-onafhankelijke blauwdruk.</p>
                    <ul>
                        <li>De <code>M:N</code> relatie is opgesplitst door een nieuwe associatie-entiteit Inschrijving.
                        </li>
                        <li>Er zijn nu twee <code>1:M</code> (één-op-veel) relaties.</li>
                        <li>Logische attributen en sleutels zijn gedefinieerd.</li>
                    </ul>
                    <pre><code>
+--------------------------+
| Student                  |
+--------------------------+
| PK: studentId : int      |
| naam : string            |
| email : string           |
+--------------------------+
         (1)|
          (M)
+--------------------------+
| Inschrijving             |
+--------------------------+
| PK,FK: studentId : int   |
| PK,FK: cursusId : int    |
| inschrijfDatum : date    |
+--------------------------+
         (M)
          (1)|
+--------------------------+
| Cursus                   |
+--------------------------+
| PK: cursusId : int       |
| titel : string           |
| studiepunten : int       |
+--------------------------+
</code></pre>

                    <h5 class="font-bold">Visueel Voorbeeld 3: Het Fysieke Model (PDM) (Voorbeeld: MS SQL Server)</h5>
                    <p>Het PDM is de concrete implementatiegids, specifiek voor een RDBMS (hier MS SQL Server). Het
                        bevat alle
                        technische details, inclusief constraints die in Deel 5 worden besproken.</p>
                    <pre><code>
+------------------------------------------------------+
| Student (Tabel)                                      |
+------------------------------------------------------+
| studentId : int IDENTITY(1,1) {PK, NNA}              |
| naam : varchar(100) {NNA}                            |
| email : varchar(255) {NNA, AK_Student_Email UNIQUE}  |
+------------------------------------------------------+
         (1)|
          (M) {FK_Inschrijving_Student, ON DELETE CASCADE}
+------------------------------------------------------+
| Inschrijving (Tabel)                                 |
+------------------------------------------------------+
| studentId : int {PK, FK, NNA}                        |
| cursusId : int {PK, FK, NNA}                         |
| inschrijfDatum : datetime2 {NNA, DEFAULT GETDATE()}  |
+------------------------------------------------------+
         (M) {FK_Inschrijving_Cursus, ON DELETE CASCADE}
          (1)|
+------------------------------------------------------+
| Cursus (Tabel)                                       |
+------------------------------------------------------+
| cursusId : int IDENTITY(1,1) {PK, NNA}               |
| titel : varchar(100) {NNA}                           |
| studiepunten : int {NNA, CK_Studiepunten CHECK > 0}  |
+------------------------------------------------------+
</code></pre>

                    <h4>1.4 Vergelijkende Analyse: Conceptueel, Logisch en Fysiek</h4>
                    <p>De progressieve evolutie van een datamodel, van abstract idee tot concrete implementatie, kan
                        worden
                        samengevat in de volgende tabel. Deze tabel is gebaseerd op de analyse in de verstrekte
                        documenten en is
                        van cruciaal belang voor het begrip van het modelleringsproces.</p>

                    <div class="overflow-x-auto">
                        <table class="min-w-full divide-y divide-gray-200">
                            <thead class="bg-gray-50">
                                <tr>
                                    <th scope="col"
                                        class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                                        ERD onderdeel</th>
                                    <th scope="col"
                                        class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                                        Conceptueel</th>
                                    <th scope="col"
                                        class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                                        Logisch</th>
                                    <th scope="col"
                                        class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                                        Fysiek</th>
                                </tr>
                            </thead>
                            <tbody class="bg-white divide-y divide-gray-200">
                                <tr>
                                    <td class="px-6 py-4 whitespace-nowrap">Entiteit (tabel) naam</td>
                                    <td class="px-6 py-4 whitespace-nowrap">☑</td>
                                    <td class="px-6 py-4 whitespace-nowrap">☑</td>
                                    <td class="px-6 py-4 whitespace-nowrap">☑</td>
                                </tr>
                                <tr>
                                    <td class="px-6 py-4 whitespace-nowrap">Relaties</td>
                                    <td class="px-6 py-4 whitespace-nowrap">☑</td>
                                    <td class="px-6 py-4 whitespace-nowrap">☑</td>
                                    <td class="px-6 py-4 whitespace-nowrap">☑</td>
                                </tr>
                                <tr>
                                    <td class="px-6 py-4 whitespace-nowrap">Veel op veel toegestaan</td>
                                    <td class="px-6 py-4 whitespace-nowrap">☑</td>
                                    <td class="px-6 py-4 whitespace-nowrap">Optioneel (meestal niet)</td>
                                    <td class="px-6 py-4 whitespace-nowrap">X</td>
                                </tr>
                                <tr>
                                    <td class="px-6 py-4 whitespace-nowrap">Kolom (attribuut) naam</td>
                                    <td class="px-6 py-4 whitespace-nowrap">X (of zeer beperkt)</td>
                                    <td class="px-6 py-4 whitespace-nowrap">☑</td>
                                    <td class="px-6 py-4 whitespace-nowrap">☑</td>
                                </tr>
                                <tr>
                                    <td class="px-6 py-4 whitespace-nowrap">Datatypes</td>
                                    <td class="px-6 py-4 whitespace-nowrap">X</td>
                                    <td class="px-6 py-4 whitespace-nowrap">Optioneel (algemeen)</td>
                                    <td class="px-6 py-4 whitespace-nowrap">☑ (specifiek)</td>
                                </tr>
                                <tr>
                                    <td class="px-6 py-4 whitespace-nowrap">Primary key (PK)</td>
                                    <td class="px-6 py-4 whitespace-nowrap">X</td>
                                    <td class="px-6 py-4 whitespace-nowrap">Optioneel</td>
                                    <td class="px-6 py-4 whitespace-nowrap">☑</td>
                                </tr>
                                <tr>
                                    <td class="px-6 py-4 whitespace-nowrap">Foreign key (FK)</td>
                                    <td class="px-6 py-4 whitespace-nowrap">X</td>
                                    <td class="px-6 py-4 whitespace-nowrap">Optioneel</td>
                                    <td class="px-6 py-4 whitespace-nowrap">☑</td>
                                </tr>
                                <tr>
                                    <td class="px-6 py-4 whitespace-nowrap">"Relatiespecificaties (NA/NNA, On Delete)"
                                    </td>
                                    <td class="px-6 py-4 whitespace-nowrap">X</td>
                                    <td class="px-6 py-4 whitespace-nowrap">Optioneel</td>
                                    <td class="px-6 py-4 whitespace-nowrap">☑</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>

                    <h3 id="volledige-tekst-2-1">Deel 2: De Bouwstenen van het ERD: Entiteiten en Attributen</h3>

                    <h4>2.1 Entiteiten: Definitie, Regels en Naamgevingsconventies</h4>
                    <p>Een <strong>entiteit</strong> is het centrale concept in een ERD. Het vertegenwoordigt een object
                        (een
                        persoon, plaats, ding, concept of gebeurtenis) waarover de organisatie informatie wenst te
                        bewaren. Een
                        fundamentele eis is dat elke entiteit (en elk record daarbinnen) uniek identificeerbaar moet
                        zijn.</p>
                    <p><strong>Naamgevingsconventie (Regel):</strong></p>
                    <ul>
                        <li>De naam van een entiteit begint met een <strong>H</strong>oofdletter.</li>
                        <li>De naam staat altijd in het <strong>E</strong>nkelvoud.</li>
                    </ul>
                    <p>Voorbeeld: <code>Klant</code>, <code>Product</code>, <code>Order</code> (niet
                        <code>Klanten</code>,
                        <code>Producten</code>, <code>Orders</code>).
                    </p>

                    <h4>2.2 Attributen: Definitie, Regels en Naamgevingsconventies</h4>
                    <p>Een <strong>attribuut</strong> is een kenmerk of een specifieke eigenschap van een entiteit. Het
                        beschrijft een stukje data dat we van de entiteit willen bijhouden.</p>
                    <p><strong>Naamgevingsconventie (Regel):</strong></p>
                    <ul>
                        <li>De naam van een attribuut begint met een <strong>k</strong>leine letter.</li>
                        <li>Indien de naam uit meerdere woorden bestaat, wordt
                            <strong>c</strong>amel<strong>C</strong>ase
                            gebruikt (het tweede en elk volgend woord beginnen met een hoofdletter).
                        </li>
                        <li>De naam staat in het enkelvoud en moet duidelijk zijn (geen afkortingen).</li>
                    </ul>
                    <p>Voorbeeld: <code>voornaam</code>, <code>straat</code>, <code>leveringsdatum</code>,
                        <code>commissiePercentage</code>.
                    </p>
                    <p><strong>Conventie Primaire Sleutel (Regel):</strong></p>
                    <ul>
                        <li>De primaire sleutel, die dient als de unieke technische identifier, krijgt binnen deze
                            conventie
                            altijd de naam <code>id</code>.</li>
                    </ul>

                    <h4>2.3 Essentiële 'Best Practices' voor Attribuutontwerp</h4>
                    <p>Een slecht ontworpen attribuutstructuur kan leiden tot data-redundantie, update-anomalieën en
                        onmogelijke
                        queries. De volgende regels zijn cruciaal voor een robuust model.</p>

                    <h5>2.3.1 Het Vermijden van Samengestelde Gegevens (Composite Data)</h5>
                    <p>Dit zijn attributen die logisch opgesplitst kunnen worden in meerdere, kleinere onderdelen, zoals
                        een
                        'volledige naam' of een 'adres'.</p>
                    <ul>
                        <li><strong>Probleem:</strong> Het opslaan van "Jan Peeters" in een enkel <code>naam</code> veld
                            maakt
                            het extreem moeilijk of onmogelijk om de data betrouwbaar te gebruiken. Een applicatie kan
                            niet
                            eenvoudig een gepersonaliseerde e-mail sturen ("Beste Jan"). Het wordt nog complexer bij
                            namen met
                            tussenvoegsels ("Jan-Willem van de Velde").</li>
                        <li><strong>Regel:</strong> Bewaar samengestelde gegevens altijd in hun kleinste, logische,
                            atomische
                            componenten.</li>
                        <li><code>naam</code> &rarr; <code>voornaam</code> en <code>naam</code>.</li>
                        <li><code>adres</code> &rarr; <code>straat</code>, <code>huisnummer</code>,
                            <code>postcode</code>,
                            <code>gemeente</code>.
                        </li>
                    </ul>

                    <h5>2.3.2 Het Vermijden van Proces- of Berekende Gegevens (Calculated Data)</h5>
                    <p>Dit zijn gegevens die afgeleid of berekend kunnen worden op basis van andere attributen die al in
                        de
                        database aanwezig zijn. Het klassieke voorbeeld is <code>leeftijd</code>.</p>
                    <ul>
                        <li><strong>Probleem:</strong>
                            <ol>
                                <li><strong>Inefficiëntie en Onderhoud:</strong> De leeftijd van elke persoon in de
                                    database
                                    verandert elk jaar. Dit zou vereisen dat het systeem dagelijks of jaarlijks elk
                                    record moet
                                    bijwerken (updaten), wat een "compleet onnodige" en zware systeembelasting is.</li>
                                <li><strong>Data-Integriteit:</strong> Het creëert een risico op inconsistentie. Wat als
                                    de
                                    <code>geboortedatum</code> 01-01-1990 is, maar het <code>leeftijd</code> veld (door
                                    een
                                    fout) nog op 33 staat? Welk veld is dan de waarheid?
                                </li>
                            </ol>
                        </li>
                        <li><strong>Regel:</strong> Bewaar nooit berekende gegevens. Bewaar altijd de bron van de
                            berekening (in
                            dit geval <code>geboortedatum</code>). De applicatie (of een database view) kan de leeftijd
                            vervolgens 'on-the-fly' berekenen wanneer dat nodig is.</li>
                    </ul>

                    <h5>2.3.3 Correct Gebruik van Datatypes</h5>
                    <p>De keuze van een datatype moet de semantiek van de data weerspiegelen, niet alleen het uiterlijk.
                    </p>
                    <ul>
                        <li><strong>Regel:</strong> "Gebruik enkel getallen als je wil rekenen".</li>
                        <li><strong>Voorbeeld:</strong> Een <code>Postcode</code> (bv. 2440) en een
                            <code>Telefoonnummer</code>
                            zijn geen getallen. Er wordt nooit mee gerekend (de som van twee postcodes is zinloos). Het
                            zijn
                            <code>string</code> (tekst) types. Een <code>Salaris</code> is daarentegen wel een getal
                            (bv.
                            <code>float</code>), omdat hiermee gerekend moet worden.
                        </li>
                    </ul>

                    <h4>2.4 Soorten Entiteiten Onderscheiden</h4>
                    <p>Entiteiten kunnen worden gecategoriseerd op basis van hun rol en afhankelijkheid binnen het
                        model.</p>

                    <h5>2.4.1 Kernentiteiten (Core Entities)</h5>
                    <p>Dit zijn de fundamentele, onafhankelijke entiteiten in het model. Ze "bestaan op zichzelf" en
                        hebben geen
                        andere entiteit nodig om hun betekenis te krijgen. Dit zijn typisch de hoofdonderwerpen van de
                        applicatie.</p>
                    <ul>
                        <li><strong>Voorbeeld:</strong> <code>Klant</code>, <code>Product</code>,
                            <code>Leverancier</code>,
                            <code>Speler</code>.
                        </li>
                    </ul>

                    <h5>2.4.2 Associatie-entiteiten (Association Entities)</h5>
                    <p>Een associatie-entiteit (of tussentabel) bestaat niet op zichzelf, maar dient als een 'brug' om
                        een
                        veel-op-veel (<code>M:N</code>) relatie tussen twee of meer andere (meestal kern)entiteiten weer
                        te
                        geven.</p>
                    <ul>
                        <li><strong>Voorbeeld:</strong> Een bestelling kan veel producten bevatten, en een product kan
                            in veel
                            bestellingen voorkomen. De entiteit <code>Orderlijn</code> (of
                            <code>BestellingProduct</code>) is de
                            associatie-entiteit die <code>Order</code> en <code>Product</code> koppelt. Een ander
                            voorbeeld is
                            <code>BookAuthor</code> die <code>Book</code> en <code>Author</code> koppelt.
                        </li>
                    </ul>

                    <h5>2.4.3 Karakteristieke Entiteiten (Characteristic Entities)</h5>
                    <p>Een karakteristieke entiteit bestaat ook niet op zichzelf, maar dient uitsluitend om een andere
                        (meestal
                        kern)entiteit te verduidelijken, kwalificeren of te karakteriseren.</p>
                    <ul>
                        <li><strong>Doel:</strong> Het wordt gebruikt om een lijst van waarden (zoals types, categorieën
                            of
                            statussen) te beheren die dynamisch is (de lijst kan groeien of wijzigen) of waaraan extra
                            eigenschappen gekoppeld moeten worden.</li>
                        <li><strong>Voorbeeld:</strong> Een <code>Auto</code> heeft een <code>merk</code>. In plaats van
                            <code>merk</code> als een <code>string</code> attribuut op te slaan (wat kan leiden tot
                            inconsistente invoer zoals "VW", "vW", "volkswagen"), wordt een aparte karakteristieke
                            entiteit
                            <code>Merk</code> aangemaakt. De <code>Auto</code> entiteit krijgt dan een Foreign Key (FK)
                            die
                            verwijst naar de <code>Merk</code> entiteit.
                        </li>
                    </ul>

                    <h3 id="volledige-tekst-3-1">Deel 3: De Architectuur van Data: Sleutels (Keys)</h3>
                    <p>Sleutels zijn de mechanismen die de relationele regels (zoals uniciteit en verbanden) afdwingen.
                        Het
                        selecteren van de juiste sleutels is geen willekeurige keuze, maar volgt een logisch proces van
                        eliminatie en selectie.</p>

                    <h4>3.0 De Sleutelhiërarchie: Een Proces van Selectie</h4>
                    <p>Om de verschillende soorten sleutels te begrijpen, moeten we ze zien als een hiërarchische
                        trechter. Men
                        begint met een brede set van mogelijkheden, die vervolgens wordt verfijnd tot de uiteindelijke
                        sleutels.
                    </p>

                    <h5>3.0.1 Superkey (Supersleutel)</h5>
                    <ul>
                        <li><strong>Definitie:</strong> Een <strong>Superkey</strong> (supersleutel) is de breedste
                            categorie.
                            Het is <strong>elke</strong> set van één of meer attributen die, wanneer gecombineerd, een
                            rij in
                            een tabel uniek kan identificeren.</li>
                        <li><strong>Kenmerk:</strong> Een supersleutel mag "overbodige" (extraneous) attributen
                            bevatten.</li>
                        <li><strong>Voorbeeld:</strong> Beschouw een tabel <code>Student</code> met de kolommen
                            {<code>id</code>, <code>studentenNummer</code>, <code>email</code>, <code>naam</code>}.
                            Aangenomen
                            dat <code>id</code>, <code>studentenNummer</code> en <code>email</code> allemaal uniek zijn,
                            zijn de
                            volgende combinaties (en vele andere) allemaal <strong>Superkeys</strong>:
                            <ul>
                                <li>{<code>id</code>}</li>
                                <li>{<code>studentenNummer</code>}</li>
                                <li>{<code>id</code>, <code>naam</code>}</li>
                                <li>{<code>studentenNummer</code>, <code>email</code>, <code>naam</code>}</li>
                            </ul>
                        </li>
                    </ul>

                    <h5>3.0.2 Candidate Key (Kandidaatsleutel)</h5>
                    <ul>
                        <li><strong>Definitie:</strong> Een <strong>Candidate Key</strong> (kandidaatsleutel) is een
                            <strong>minimale supersleutel</strong>. Dit betekent dat het nog steeds uniek is, maar er
                            kunnen
                            geen attributen meer uit de set worden verwijderd zonder dat de uniciteit verloren gaat. Dit
                            zijn de
                            <strong>echte</strong> kandidaten om als Primaire Sleutel te dienen.
                        </li>
                        <li><strong>Kenmerk:</strong> Een tabel kan <strong>meerdere</strong> kandidaatsleutels hebben.
                        </li>
                        <li><strong>Voorbeeld:</strong> In het <code>Student</code> voorbeeld hierboven zijn de
                            <strong>Candidate Keys</strong>:
                            <ul>
                                <li>{<code>id</code>}</li>
                                <li>{<code>studentenNummer</code>}</li>
                                <li>{<code>email</code>}</li>
                            </ul>
                        </li>
                        <li>De combinatie {<code>id</code>, <code>naam</code>} is <strong>geen</strong>
                            kandidaatsleutel, omdat
                            het een <strong>superkey</strong> is waaruit <code>naam</code> kan worden verwijderd terwijl
                            de
                            uniciteit (gegarandeerd door <code>id</code>) behouden blijft.</li>
                    </ul>

                    <h4>3.1 De Primaire Sleutel (PK)</h4>
                    <p>De <strong>Primaire Sleutel (PK)</strong> is de <strong>gekozen</strong> kolom, of een combinatie
                        van
                        kolommen, die één specifieke rij (record) in een tabel uniek identificeert.</p>
                    <ul>
                        <li><strong>Relatie tot Kandidaatsleutel:</strong> De Primaire Sleutel is de
                            <strong>éne</strong>
                            kandidaatsleutel die door de databaseontwerper is <strong>geselecteerd</strong> om als de
                            officiële,
                            primaire identifier voor de tabel te dienen.
                        </li>
                    </ul>
                    <p>De PK moet voldoen aan twee strikte integriteitsregels:</p>
                    <ol>
                        <li><strong>Uniciteit:</strong> De waarde van de PK mag nooit twee keer voorkomen in de tabel.
                        </li>
                        <li><strong>Verplicht:</strong> De waarde van de PK mag nooit <code>NULL</code> (leeg) zijn. In
                            een
                            fysiek model wordt dit genoteerd als {NNA (Nulls Not Allowed)}.</li>
                    </ol>

                    <h5>3.1.5 Het Verschil: Primary Key vs. UNIQUE Constraint</h5>
                    <p>Een veelvoorkomende verwarring ontstaat tussen de Primaire Sleutel en een <code>UNIQUE</code>
                        constraint
                        (die gebruikt wordt voor Alternatieve Sleutels, zie 3.3). Hoewel beide uniciteit afdwingen, zijn
                        er
                        fundamentele verschillen:</p>
                    <ul>
                        <li><strong>Nullability:</strong> Een Primaire Sleutel dwingt een <code>NOT NULL</code>
                            constraint af;
                            <code>NULL</code> is per definitie niet toegestaan. Een <code>UNIQUE</code> constraint staat
                            in de
                            meeste RDBMS'en wel <code>NULL</code>-waarden toe (vaak slechts één, aangezien
                            <code>NULL</code>
                            niet gelijk wordt geacht aan een andere <code>NULL</code>).
                        </li>
                        <li><strong>Aantal per Tabel:</strong> Een tabel kan slechts <strong>één</strong> Primaire
                            Sleutel
                            hebben. Een tabel kan <strong>meerdere</strong> <code>UNIQUE</code> constraints hebben (bv.
                            één op
                            <code>email</code> en één op <code>telefoonnummer</code>).
                        </li>
                        <li><strong>Doel:</strong> De PK definieert de <strong>identiteit</strong> van de rij (entity
                            integrity). Een <code>UNIQUE</code> constraint dwingt een specifieke <strong>business
                                rule</strong>
                            af die uniciteit vereist voor een niet-primaire kolom.</li>
                        <li><strong>Fysieke Implementatie:</strong> In veel RDBMS'en (zoals SQL Server) wordt de PK
                            standaard
                            geïmplementeerd als een <strong>clustered index</strong> (die de fysieke opslagvolgorde van
                            de data
                            op schijf bepaalt), terwijl een <code>UNIQUE</code> constraint standaard als een
                            <strong>non-clustered index</strong> wordt geïmplementeerd.
                        </li>
                    </ul>

                    <h4>3.2 De Surrogaat Sleutel (Surrogate Key): De 'Best Practice'</h4>
                    <p>Er zijn twee soorten sleutels die als PK kunnen dienen:</p>
                    <ol>
                        <li><strong>Natuurlijke Sleutel:</strong> Een attribuut dat in de 'echte wereld' al uniek is
                            (bv.
                            <code>studentenNummer</code>, <code>factuurnummer</code>, <code>rijksregisternummer</code>).
                        </li>
                        <li><strong>Surrogaat Sleutel (Synthetische Sleutel):</strong> Een sleutel die geen betekenis
                            heeft in
                            de 'echte wereld', maar puur technisch wordt toegevoegd door de databaseontwerper om als
                            unieke
                            identifier te dienen.</li>
                    </ol>
                    <p>Binnen de context van deze cursus en als algemene 'best practice' wordt de voorkeur gegeven aan
                        de
                        surrogaat sleutel. Deze wordt standaard <code>id</code> genoemd en is van het type
                        <code>integer</code>.
                    </p>
                    <p>De voorkeur voor een surrogaat sleutel is gebaseerd op vier essentiële voordelen:</p>
                    <ol>
                        <li><strong>Heeft geen betekenis:</strong> Dit zorgt voor stabiliteit. Stel dat een
                            <code>studentenNummer</code> (een natuurlijke sleutel) als PK wordt gebruikt en bij invoer
                            wordt een
                            typfout gemaakt. Later, wanneer de student met het echte nummer zich probeert in te
                            schrijven, faalt
                            het systeem. Een betekenisloze <code>id</code> heeft dit probleem niet.
                        </li>
                        <li><strong>Is minimaal:</strong> Een <code>integer</code> (bv. 4 bytes) is veel kleiner dan een
                            <code>string</code> (bv. <code>varchar(50)</code>). Bij het leggen van verbanden (joins) op
                            grote
                            tabellen resulteert een kleinere sleutel in significant snellere operaties en minder
                            schijfgebruik.
                        </li>
                        <li><strong>Wordt nooit geüpdatet:</strong> Een natuurlijke sleutel kan wijzigen (een persoon
                            verandert
                            van e-mailadres, een bedrijf verandert van BTW-nummer). Als dit de PK is, moet deze
                            wijziging ook
                            worden doorgevoerd in alle tabellen die ernaar verwijzen (via Foreign Keys). Dit is een
                            zware en
                            risicovolle operatie. Een surrogaat <code>id</code> wijzigt nooit.</li>
                        <li><strong>Is een integer:</strong> Vergelijkingen tussen getallen (<code>int</code>) zijn voor
                            een
                            database aanzienlijk sneller en efficiënter dan vergelijkingen tussen teksten
                            (<code>string</code>).
                        </li>
                    </ol>

                    <h4>3.3 Alternatieve Sleutels (AK) (Alternative Keys)</h4>
                    <p>Wanneer een surrogaat <code>id</code> als PK is gekozen, wat gebeurt er dan met de natuurlijke
                        sleutels?
                        Dit worden <strong>Alternatieve Sleutels (AK)</strong>.</p>
                    <ul>
                        <li><strong>Definitie:</strong> Een Alternatieve Sleutel is <strong>elke kandidaatsleutel die
                                niet werd
                                gekozen als de Primaire Sleutel</strong>.</li>
                        <li><strong>Doel:</strong> Hoewel de <code>id</code> (PK) de <strong>technische</strong>
                            uniciteit
                            garandeert, garandeert de AK de <strong>business</strong> uniciteit. Het zorgt ervoor dat
                            geen twee
                            studenten hetzelfde <code>studentenNummer</code> of <code>email</code> kunnen hebben.</li>
                        <li><strong>Implementatie:</strong> Een AK krijgt in SQL (meestal) een <code>UNIQUE</code>
                            constraint en
                            wordt vaak geïndexeerd om snel zoeken op deze kolom mogelijk te maken.</li>
                        <li><strong>ERD Regel:</strong> Alle kernentiteiten moeten (minimaal) één AK hebben.</li>
                    </ul>

                    <h4>3.4 De Foreign Key (FK)</h4>
                    <p>De <strong>Foreign Key (FK)</strong> (of refererende sleutel) is de 'lijm' van de relationele
                        database.
                    </p>
                    <ul>
                        <li><strong>Definitie:</strong> Een FK is een kolom (of combinatie van kolommen) in één tabel
                            (de
                            'child' tabel) die verwijst naar de Primaire Sleutel (PK) in een andere tabel (de 'parent'
                            tabel).
                            (Een FK kan technisch ook verwijzen naar een Alternatieve Sleutel / <code>UNIQUE</code>
                            constraint).
                        </li>
                        <li><strong>Doel:</strong> Het legt het verband (de relatie) vast tussen twee tabellen en
                            voorkomt data
                            duplicatie. In plaats van de volledige naam en details van een serie te herhalen voor elk
                            boek,
                            slaat de <code>Book</code> tabel enkel de <code>id</code> van de serie op als een FK.</li>
                    </ul>

                    <h4>3.5 Samengestelde Sleutels (Composite Keys)</h4>
                    <ul>
                        <li><strong>Definitie:</strong> Een samengestelde sleutel (of <strong>composite key</strong>) is
                            een
                            sleutel (PK, AK, of FK) die bestaat uit een combinatie van <strong>twee of meer</strong>
                            kolommen om
                            uniciteit te garanderen.</li>
                        <li><strong>Toepassing 1: Associatie-entiteiten (M:N Relaties):</strong> Dit is de meest
                            voorkomende
                            toepassing. Bij het oploshsen van een <code>M:N</code> relatie tussen <code>Student</code>
                            en
                            <code>Cursus</code>, wordt de PK van de tussentabel <code>Inschrijving</code> vaak gevormd
                            door de
                            combinatie van de twee FK's: {<code>FK_studentId</code>, <code>FK_cursusId</code>}. Dit
                            garandeert
                            dat een student zich maar één keer voor dezelfde cursus kan inschrijven.
                        </li>
                        <li><strong>Toepassing 2: Zwakke Entiteiten (Identificerende Relaties):</strong> Zoals besproken
                            in Deel
                            4.5.3, kan de PK van een 'kind'-entiteit bestaan uit de PK van de 'ouder' plus een eigen
                            discriminator. Bijvoorbeeld, de PK van een <code>Kamer</code> kan zijn
                            {<code>FK_gebouwId</code>,
                            <code>kamerNummer</code>}.
                        </li>
                    </ul>
                    <p><strong>SQL Voorbeeld (Composite PK):</strong> Het volgende voorbeeld toont de creatie van een
                        <code>OrderLijn</code> tabel (een associatie-entiteit) waarbij de PK is samengesteld uit
                        <code>orderId</code> en <code>productId</code>.
                    </p>
                    <pre><code>CREATE TABLE OrderLijn (
    orderId INT NOT NULL,
    productId INT NOT NULL,
    aantal INT NOT NULL,

    -- Definitie van de samengestelde Primaire Sleutel
    CONSTRAINT PK_OrderLijn PRIMARY KEY (orderId, productId),

    -- Definitie van de individuele Foreign Keys
    CONSTRAINT FK_OrderLijn_Order
        FOREIGN KEY (orderId) REFERENCES Order(id),
    CONSTRAINT FK_OrderLijn_Product
        FOREIGN KEY (productId) REFERENCES Product(id)
);</code></pre>

                    <h4>3.6 Samenvattende Tabel: De Sleutelhiërarchie</h4>
                    <p>De relatie tussen de verschillende sleuteltypes kan als volgt worden samengevat:</p>
                    <div class="overflow-x-auto">
                        <table>
                            <thead>
                                <tr>
                                    <th>Sleuteltype</th>
                                    <th>Definitie</th>
                                    <th>Voorbeeld (Tabel: Student)</th>
                                    <th>Aantal per Tabel</th>
                                    <th>NULL Toegestaan?</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td><strong>Superkey</strong></td>
                                    <td><strong>Elke</strong> set attributen die een rij uniek identificeert.</td>
                                    <td>"{<code>id</code>, <code>naam</code>}"</td>
                                    <td>Vele</td>
                                    <td>Ja</td>
                                </tr>
                                <tr>
                                    <td><strong>Candidate Key</strong></td>
                                    <td>Een <strong>minimale</strong> superkey (geen overbodige attributen).</td>
                                    <td>"{<code>id</code>}, {<code>email</code>}"</td>
                                    <td>Eén of meer</td>
                                    <td>Nee</td>
                                </tr>
                                <tr>
                                    <td><strong>Primary Key (PK)</strong></td>
                                    <td>De <strong>gekozen</strong> kandidaatsleutel.</td>
                                    <td>{<code>id</code>}</td>
                                    <td>Precies één</td>
                                    <td>Nee</td>
                                </tr>
                                <tr>
                                    <td><strong>Alternate Key (AK)</strong></td>
                                    <td>Een kandidaatsleutel die <strong>niet</strong> als PK is gekozen.</td>
                                    <td>{<code>email</code>}</td>
                                    <td>Nul of meer</td>
                                    <td>Ja (meestal 1x)</td>
                                </tr>
                                <tr>
                                    <td><strong>Surrogate Key (SK)</strong></td>
                                    <td>Een technisch, betekenisloos <code>integer</code> veld, gebruikt als PK.</td>
                                    <td>{<code>id</code>} (als auto-nummer)</td>
                                    <td>Nul of één</td>
                                    <td>Nee</td>
                                </tr>
                                <tr>
                                    <td><strong>Composite Key</strong></td>
                                    <td>Een sleutel (PK, AK, etc.) die uit 2+ kolommen bestaat.</td>
                                    <td>"{<code>voornaam</code>, <code>naam</code>, <code>geboortedatum</code>}"</td>
                                    <td>N.v.t.</td>
                                    <td>Afhankelijk van type</td>
                                </tr>
                                <tr>
                                    <td><strong>Foreign Key (FK)</strong></td>
                                    <td>Een kolom die verwijst naar de PK (of AK) van een andere tabel.</td>
                                    <td>{<code>FK_opleidingId</code>}</td>
                                    <td>Nul of meer</td>
                                    <td>Ja (optioneel) / Nee (verplicht)</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>

                    <h3 id="volledige-tekst-4-1">Deel 4: Het Modelleren van Verbanden: Relaties en Multipliciteit</h3>

                    <h4>4.1 De Drie Soorten Relaties (Multipliciteit)</h4>
                    <p>Multipliciteit (ook wel cardinaliteit genoemd) beschrijft hoeveel records van de ene entiteit
                        kunnen
                        worden gekoppeld aan hoeveel records van een andere entiteit.</p>
                    <ul>
                        <li><strong>Eén-op-één (1:1):</strong> Elk record in A heeft precies één gerelateerd record in
                            B.
                            <ul>
                                <li><strong>Toepassing:</strong> Zeer zeldzaam. Het is vaak een indicatie dat entiteit A
                                    en B
                                    samengevoegd moeten worden tot één entiteit. Soms gebruikt voor performance of
                                    beveiliging
                                    (bv. <code>Werknemer</code> en <code>WerknemerGeheim</code> met <code>1:1</code>
                                    relatie
                                    voor salarisdata).</li>
                            </ul>
                        </li>
                        <li><strong>Eén-op-veel (1:M of 1:*):</strong> Elk record in A kan meerdere gerelateerde records
                            in B
                            hebben, maar elk record in B heeft slechts één gerelateerd record in A.
                            <ul>
                                <li><strong>Toepassing:</strong> Dit is de meest voorkomende en fundamentele relatie
                                    (bv. één
                                    <code>Klant</code> heeft veel <code>Bestellingen</code>).
                                </li>
                            </ul>
                        </li>
                        <li><strong>Veel-op-veel (M:N of *:*):</strong> Elk record in A kan meerdere records in B
                            hebben, en
                            vice versa.
                            <ul>
                                <li><strong>Toepassing:</strong> Dit kan niet direct geïmplementeerd worden in een
                                    relationele
                                    database en vereist een specifieke oplossing.</li>
                            </ul>
                        </li>
                    </ul>

                    <h4>4.2 De Gouden Regel: Correcte Plaatsing van de Foreign Key</h4>
                    <p>De plaatsing van de FK in een <code>1:M</code> relatie is geen keuze, maar een logische noodzaak
                        om
                        data-redundantie te voorkomen. Dit wordt geïllustreerd met de <code>1:M</code> relatie tussen
                        <code>Series</code> (1) en <code>Book</code> (M).
                    </p>
                    <ul>
                        <li><strong>Optie 1 (Fout):</strong> Plaats de FK <code>bookId</code> in de <code>Series</code>
                            tabel
                            (de '1'-kant).
                            <ul>
                                <li><strong>Resultaat:</strong> Als "The Kharkanas Trilogy" (id 1) twee boeken heeft (id
                                    1 en
                                    2), moet de <code>Series</code> tabel twee keer worden aangemaakt: één record voor
                                    (Series
                                    1, Book 1) en één record voor (Series 1, Book 2). Dit dupliceert de serie-informatie
                                    ("The
                                    Kharkanas Trilogy") onnodig.</li>
                            </ul>
                        </li>
                        <li><strong>Optie 2 (Correct):</strong> Plaats de FK <code>seriesId</code> in de
                            <code>Book</code> tabel
                            (de 'veel'-kant).
                            <ul>
                                <li><strong>Resultaat:</strong> De <code>Series</code> tabel heeft één record: (id 1,
                                    "The
                                    Kharkanas Trilogy"). De <code>Book</code> tabel kan nu meerdere records hebben die
                                    allemaal
                                    verwijzen naar <code>seriesId = 1</code>. Er is geen duplicatie van data.</li>
                            </ul>
                        </li>
                    </ul>
                    <p><strong class="text-red-600">REGEL: "De FK staat altijd aan de * kant (de 'veel'-kant) van elke
                            relatie".</strong></p>

                    <h4>4.3 De Oplossing voor M:N Relaties: De Associatie-entiteit</h4>
                    <p>Het bovenstaande probleem wordt complexer bij een <code>M:N</code> relatie, zoals
                        <code>Book</code> (*:*)
                        <code>Author</code>.
                    </p>
                    <ul>
                        <li><strong>Probleem:</strong> Waar komt de FK?
                            <ul>
                                <li>Als de FK <code>authorId</code> in <code>Book</code> staat (Optie 2 van
                                    <code>M:N</code>),
                                    moet een boek dat door twee auteurs is geschreven, twee keer in de <code>Book</code>
                                    tabel
                                    worden opgeslagen (duplicatie van boeken).
                                </li>
                                <li>Als de FK <code>bookId</code> in <code>Author</code> staat (Optie 1 van
                                    <code>M:N</code>),
                                    moet een auteur die twee boeken heeft geschreven, twee keer in de
                                    <code>Author</code> tabel
                                    worden opgeslagen (duplicatie van auteurs).
                                </li>
                            </ul>
                        </li>
                        <li>Beide opties leiden tot onwerkbare data-redundantie.</li>
                        <li><strong>Oplossing:</strong> De <code>M:N</code> relatie wordt opgesplitst met behulp van een
                            derde
                            entiteit: de <strong>associatie-entiteit</strong> (of tussentabel/samenvoegtabel),
                            bijvoorbeeld
                            <code>BookAuthor</code>.
                        </li>
                        <li><strong>Mechanisme:</strong> Deze tussentabel lost de <code>M:N</code> relatie op door deze
                            te
                            vervangen door twee <code>1:M</code> relaties:
                            <ol>
                                <li><code>Book</code> (1) &rarr; <code>BookAuthor</code> (M)</li>
                                <li><code>Author</code> (1) &rarr; <code>BookAuthor</code> (M)</li>
                            </ol>
                        </li>
                        <li>De associatietabel <code>BookAuthor</code> bevat (minimaal) twee FK's:
                            <code>FK1 bookId</code> en
                            <code>FK2 authorId</code>. Een record in deze tabel (bv. <code>bookId = 6</code>,
                            <code>authorId = 2</code>) koppelt één specifiek boek aan één specifieke auteur, zonder
                            enige data
                            in de <code>Book</code> of <code>Author</code> tabellen te dupliceren.
                        </li>
                    </ul>

                    <h4>4.4 Multipliciteit in Detail: Aard en Connectiviteit</h4>
                    <p>De notatie van een relatie (bv. <code>0..*</code> of <code>1..1</code>) bestaat uit twee
                        afzonderlijke
                        componenten die elk een specifieke regel definiëren.</p>
                    <ul>
                        <li><strong>Aard (Deelname):</strong> Dit is het <strong>minimum</strong> aantal keer dat een
                            relatie
                            <strong>moet</strong> voorkomen. Het bepaalt of de relatie <strong>optioneel (0)</strong> of
                            <strong>verplicht (1)</strong> is.
                            <ul>
                                <li><strong>0 (Optioneel):</strong> Een record <strong>kan</strong> bestaan zonder de
                                    relatie.
                                    Voorbeeld: In <code>Klant</code> (0)..<code>Order</code> (*), kan een
                                    <code>Klant</code>
                                    bestaan zonder dat deze al een <code>Order</code> heeft geplaatst.
                                </li>
                                <li><strong>1 (Verplicht):</strong> Een record <strong>moet</strong> de relatie hebben
                                    om te
                                    kunnen bestaan. Voorbeeld: In <code>Order</code> (1)..<code>Klant</code> (*), kan
                                    een
                                    <code>Order</code> niet bestaan zonder gekoppeld te zijn aan een <code>Klant</code>.
                                </li>
                            </ul>
                        </li>
                        <li><strong>Connectiviteit:</strong> Dit is het <strong>maximum</strong> aantal keer dat een
                            relatie
                            <strong>kan</strong> voorkomen. Het bepaalt of de relatie <strong>één (1)</strong> of
                            <strong>veel
                                (*)</strong> is.
                        </li>
                    </ul>
                    <p>Deze twee componenten (Aard en Connectiviteit) zijn direct verbonden met de fysieke implementatie
                        van de
                        Foreign Key:</p>
                    <ul>
                        <li>Als de <strong>Aard</strong> aan de kant van de FK <strong>1 (verplicht)</strong> is (zoals
                            bij
                            <code>Order</code> &rarr; <code>Klant</code>), moet de FK-kolom (<code>klantId</code>)
                            ingesteld
                            worden als <strong>NNA (Nulls Not Allowed)</strong>.
                        </li>
                        <li>Als de <strong>Aard</strong> aan de kant van de FK <strong>0 (optioneel)</strong> is (zoals
                            bij
                            <code>Book</code> &rarr; <code>Series</code>, een boek hoeft niet tot een serie te behoren),
                            moet de
                            FK-kolom (<code>seriesId</code>) ingesteld worden als <strong>NA (Nulls Allowed)</strong>.
                        </li>
                    </ul>

                    <h4>4.5 Taxonomie van Gevorderde Relatietypes</h4>
                    <p>Naast de standaard binaire relaties (tussen twee entiteiten) bestaan er complexere structuren die
                        specifieke modelleringspatronen vereisen.</p>

                    <h5>4.5.1 Unaire (Recursieve) Relaties</h5>
                    <ul>
                        <li><strong>Definitie:</strong> Een unaire of recursieve relatie is een relatie waarbij een
                            entiteit een
                            relatie heeft <strong>met zichzelf</strong>. Dit wordt ook een <strong>self-referencing
                                relationship</strong> genoemd.</li>
                        <li><strong>Toepassing:</strong> Dit patroon is essentieel voor het modelleren van hiërarchische
                            of
                            boomstructuren binnen één tabel.</li>
                        <li><strong>Voorbeeld (Werknemer Hiërarchie):</strong> De meest klassieke toepassing is het
                            organigram
                            van een bedrijf.
                            <ul>
                                <li>Entiteit: <code>Werknemer</code></li>
                                <li>Attributen: <code>id</code> (PK), <code>naam</code>, <code>managerId</code> (FK).
                                </li>
                                <li>De Relatie: De kolom <code>managerId</code> is een Foreign Key die <strong>verwijst
                                        naar de
                                        <code>id</code>-kolom in dezelfde <code>Werknemer</code>-tabel</strong>.</li>
                                <li>Een werknemer wiens <code>managerId</code> <code>NULL</code> is, staat aan de top
                                    van de
                                    hiërarchie (bv. de CEO).</li>
                            </ul>
                        </li>
                    </ul>
                    <p><strong>SQL Voorbeeld:</strong></p>
                    <pre><code>CREATE TABLE Werknemer (
    id INT PRIMARY KEY,
    naam VARCHAR(100),
    
    -- De FK verwijst naar de PK van dezelfde tabel
    managerId INT NULL,
    
    CONSTRAINT FK_Werknemer_Manager
        FOREIGN KEY (managerId)
        REFERENCES Werknemer(id)
    -- ON DELETE SET NULL is hier vaak een goede keuze (zie 5.4)
);</code></pre>
                    <p>Het bevragen van een dergelijke structuur (bv. "geef mij alle ondergeschikten van manager X")
                        vereist
                        speciale <strong>recursieve queries</strong> (vaak met Common Table Expressions - CTEs).</p>

                    <h5>4.5.2 Ternaire (en N-aire) Relaties</h5>
                    <ul>
                        <li><strong>Definitie:</strong> Een ternaire relatie is een relatie die <strong>drie</strong>
                            verschillende entiteiten tegelijkertijd met elkaar verbindt. Een N-aire relatie verbindt N
                            entiteiten.</li>
                        <li><strong>Probleem:</strong> Een ternaire relatie kan <strong>niet</strong> worden opgesplitst
                            in
                            (bijvoorbeeld) drie afzonderlijke binaire relaties zonder dat de <strong>context</strong> of
                            <strong>semantiek</strong> verloren gaat.
                        </li>
                        <li><strong>Voorbeeld (Folksonomy):</strong> Een <code>Gebruiker</code> past een
                            <code>Tag</code> toe op
                            een <code>Boek</code>.
                            <ul>
                                <li>Een record (Jan, SQL, Database Design) betekent dat <strong>Jan</strong> de tag
                                    <strong>SQL</strong> heeft toegepast op het boek <strong>Database Design</strong>.
                                </li>
                                <li>Dit is niet hetzelfde als drie losse feiten: (Jan, SQL), (Jan, Database Design),
                                    (SQL,
                                    Database Design).</li>
                            </ul>
                        </li>
                        <li><strong>Oplossing:</strong> Net als bij <code>M:N</code> relaties wordt een
                            associatie-entiteit
                            gebruikt, maar deze entiteit bevat nu <strong>drie</strong> (of N) Foreign Keys.</li>
                        <li><strong>Structuur:</strong>
                            <ul>
                                <li>Entiteiten: <code>Gebruiker</code>, <code>Tag</code>, <code>Boek</code>.</li>
                                <li>Associatie-entiteit: <code>GebruikerTagBoek</code></li>
                                <li>Sleutels in <code>GebruikerTagBoek</code>:
                                    <ul>
                                        <li><code>FK_gebruikerId</code> (verwijst naar <code>Gebruiker</code>)</li>
                                        <li><code>FK_tagId</code> (verwijst naar <code>Tag</code>)</li>
                                        <li><code>FK_boekId</code> (verwijst naar <code>Boek</code>)</li>
                                    </ul>
                                </li>
                                <li>De Primaire Sleutel is typisch een samengestelde sleutel van alle drie de FK's:
                                    {<code>FK_gebruikerId</code>, <code>FK_tagId</code>, <code>FK_boekId</code>}.</li>
                            </ul>
                        </li>
                    </ul>

                    <h5>4.5.3 Identificerende vs. Niet-Identificerende Relaties</h5>
                    <p>Dit onderscheid definieert hoe een 'kind'-entiteit (de 'veel'-kant) zich verhoudt tot zijn
                        'ouder'-entiteit (de 'één'-kant), specifiek met betrekking tot zijn
                        <strong>bestaansrecht</strong> en
                        <strong>identificatie</strong>.
                    </p>
                    <ul>
                        <li><strong>Niet-Identificerende Relatie (Meest Voorkomend):</strong>
                            <ul>
                                <li><strong>Definitie:</strong> Dit is de standaard <code>1:M</code> relatie. De
                                    'kind'-entiteit
                                    heeft een <strong>eigen, onafhankelijke</strong> Primaire Sleutel (meestal een
                                    surrogaat
                                    <code>id</code>).
                                </li>
                                <li><strong>Sleutels:</strong> De PK van de 'ouder' migreert naar het 'kind' als een
                                    <strong>gewone Foreign Key</strong> die <strong>geen</strong> deel uitmaakt van de
                                    PK van
                                    het kind.
                                </li>
                                <li><strong>Voorbeeld:</strong> <code>Klant</code> (PK: <code>id</code>) en
                                    <code>Bestelling</code> (PK: <code>id</code>, FK: <code>klantId</code>). De
                                    <code>klantId</code> in <code>Bestelling</code> is enkel een FK.
                                </li>
                            </ul>
                        </li>
                        <li><strong>Identificerende Relatie (Relatie met een Zwakke Entiteit):</strong>
                            <ul>
                                <li><strong>Definitie:</strong> Wordt gebruikt wanneer de 'kind'-entiteit
                                    <strong>logisch niet
                                        kan bestaan</strong> zonder de 'ouder'. Het 'kind' wordt in deze context een
                                    <strong>Zwakke Entiteit</strong> (Weak Entity) genoemd, omdat het zijn identiteit
                                    deels
                                    ontleent aan de 'ouder'.
                                </li>
                                <li><strong>Sleutels:</strong> De PK van de 'ouder' migreert naar het 'kind' en wordt
                                    daar
                                    <strong>onderdeel van de Primaire Sleutel van het kind</strong>.
                                </li>
                                <li><strong>Voorbeeld:</strong> <code>Gebouw</code> en <code>Kamer</code>. Een
                                    <code>Kamer</code> is betekenisloos zonder een <code>Gebouw</code> en wordt
                                    geïdentificeerd
                                    door zijn <code>kamernummer</code> (een partiële sleutel) <strong>binnen</strong>
                                    een
                                    specifiek gebouw.
                                    <ul>
                                        <li><code>Gebouw</code> {PK: <code>gebouwId</code>}</li>
                                        <li><code>Kamer</code> {PK: (<code>FK_gebouwId</code>,
                                            <code>kamerNummer</code>)}
                                        </li>
                                    </ul>
                                </li>
                                <li>In dit geval is <code>FK_gebouwId</code> in de <code>Kamer</code> tabel
                                    <strong>zowel</strong> een Foreign Key <strong>als</strong> een deel van de Primaire
                                    Sleutel. Het gebruik van surrogaat <code>id</code> sleutels (zoals aanbevolen in
                                    3.2) maakt
                                    dit patroon zeldzamer, omdat ontwerpers vaak toch kiezen voor een
                                    niet-identificerende
                                    relatie (bv. <code>Kamer</code> {PK: <code>kamerId</code>, FK:
                                    <code>gebouwId</code>}).
                                </li>
                            </ul>
                        </li>
                    </ul>

                    <h4>4.6 Samenvattende Tabel: Relatietypes</h4>
                    <div class="overflow-x-auto">
                        <table>
                            <thead>
                                <tr>
                                    <th>Relatietype</th>
                                    <th>Definitie</th>
                                    <th>Klassiek Voorbeeld</th>
                                    <th>Implementatie</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td><strong>Binair (1:M)</strong></td>
                                    <td>Eén 'ouder' record heeft veel 'kind' records.</td>
                                    <td><code>Klant</code> &rarr; <code>Bestelling</code></td>
                                    <td>FK in de 'veel'-tabel (<code>Bestelling</code>).</td>
                                </tr>
                                <tr>
                                    <td><strong>Binair (M:N)</strong></td>
                                    <td>Veel records hebben veel records.</td>
                                    <td><code>Student</code> &harr; <code>Cursus</code></td>
                                    <td>Associatietabel met 2 FK's.</td>
                                </tr>
                                <tr>
                                    <td><strong>Unair (Recursief)</strong></td>
                                    <td>Een entiteit heeft een relatie met zichzelf.</td>
                                    <td><code>Werknemer</code> &rarr; <code>Werknemer</code> (Manager)</td>
                                    <td>"FK in dezelfde tabel, verwijst naar eigen PK."</td>
                                </tr>
                                <tr>
                                    <td><strong>Ternair (N-air)</strong></td>
                                    <td>Een relatie tussen drie (of meer) entiteiten.</td>
                                    <td><code>Gebruiker</code> past <code>Tag</code> toe op <code>Boek</code></td>
                                    <td>Associatietabel met 3 (of N) FK's.</td>
                                </tr>
                                <tr>
                                    <td><strong>Identificerend</strong></td>
                                    <td>Een 'zwak kind' dat niet kan bestaan zonder de 'ouder'.</td>
                                    <td><code>Gebouw</code> &rarr; <code>Kamer</code></td>
                                    <td>PK van 'ouder' wordt <strong>deel van</strong> de PK van 'kind'.</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>

                    <h3 id="volledige-tekst-5-1">Deel 5: Gedetailleerde Specificatie en Integriteitsregels</h3>
                    <p>In het Fysieke Model (PDM) wordt de logica van het LDM vertaald naar afdwingbare regels. Deze
                        <strong>constraints</strong> vormen het "immuunsysteem" van de database; ze beschermen actief de
                        data-integriteit door ongeldige data te weigeren.
                    </p>

                    <h4>5.1 Datatypes: Logisch vs. Fysiek Niveau</h4>
                    <p>De keuze van datatypes wordt specifieker naarmate het model evolueert.</p>
                    <ul>
                        <li><strong>Logisch Niveau:</strong> Gebruik algemene, DBMS-onafhankelijke types:
                            <code>int</code>,
                            <code>float</code>, <code>string</code>, <code>date</code>, <code>time</code>,
                            <code>datetime</code>, <code>boolean</code>.
                        </li>
                        <li><strong>Fysiek Niveau:</strong> Gebruik DBMS-specifieke types, zoals <code>varchar2</code>
                            en
                            <code>number</code> (Oracle) of <code>varchar</code> en <code>datetime2</code> (SQL Server).
                        </li>
                        <li><strong>Notatie:</strong> Datatypes worden in het ERD achter een dubbelpunt genoteerd:
                            <code>naam: string</code>.
                        </li>
                    </ul>

                    <h4>5.2 De Afweging: Karakteristieke Entiteit versus Enumeratie (Enum)</h4>
                    <p>Voor attributen met een beperkte set van mogelijke waarden (bv. brandstoftype, merk, status) zijn
                        er twee
                        oplossingen: een enum of een karakteristieke entiteit.</p>
                    <ul>
                        <li><strong>Enumeratie (Enum):</strong>
                            <ul>
                                <li><strong>Definitie:</strong> Een vaste, stabiele lijst met waarden, gedefinieerd
                                    binnen het
                                    attribuut zelf.</li>
                                <li><strong>Structuur:</strong> Er wordt geen aparte entiteit aangemaakt.</li>
                                <li><strong>Beperking:</strong> Er kunnen geen extra eigenschappen aan de waarden worden
                                    gekoppeld.</li>
                                <li><strong>Voorbeeld:</strong> Het attribuut <code>brandstofType</code> met de vaste,
                                    onveranderlijke lijst: 'Benzine', 'Diesel', 'Hybride', 'Elektrisch'.</li>
                            </ul>
                        </li>
                        <li><strong>Karakteristieke Entiteit:</strong>
                            <ul>
                                <li><strong>Definitie:</strong> Een aparte entiteit (tabel) die wordt aangemaakt om een
                                    dynamische lijst van waarden te beheren.</li>
                                <li><strong>Structuur:</strong> De lijst kan groeien of wijzigen (bv. er komt een nieuw
                                    automerk
                                    bij) en er kunnen extra eigenschappen aan de waarden worden gekoppeld (bv. het land
                                    van
                                    herkomst van het merk).</li>
                                <li><strong>Voorbeeld:</strong> Een <code>Merk</code> entiteit die via een FK gekoppeld
                                    is aan
                                    de <code>Auto</code> entiteit.</li>
                            </ul>
                        </li>
                    </ul>
                    <p><strong>Vuistregel (Regel):</strong> "gebruik een enum als de lijst klein en stabiel is";
                        "gebruik een
                        karakteristieke entiteit als de waarden vaak wijzigen of als je er extra eigenschappen/relaties
                        aan wilt
                        koppelen".</p>

                    <h4>5.3 Null-Specificaties: Nulls Allowed (NA) vs. Nulls Not Allowed (NNA)</h4>
                    <p>Voor elk attribuut in het fysieke model moet worden aangegeven of het <code>NULL</code> (leeg)
                        mag zijn.
                        Dit is de constraint die <strong>Entity Integrity</strong> (voor PK's) en <strong>Domain
                            Integrity</strong> (voor gewone kolommen) bewaakt.</p>
                    <ul>
                        <li><strong>NA (Nulls Allowed):</strong> Lege waarden zijn toegestaan. Dit is nuttig voor
                            optionele data
                            (bv. <code>einddatum</code> voor een bestuurslid dat nog in functie is).</li>
                        <li><strong>NNA (Nulls Not Allowed):</strong> Het attribuut moet altijd een waarde hebben. Dit
                            geldt
                            voor verplichte data (bv. <code>begindatum</code>).</li>
                        <li><strong>Notatie:</strong> Wordt genoteerd tussen accolades achter het datatype:
                            <code>begindatum: date {NNA}</code>.
                        </li>
                        <li><strong class="text-red-600">Regel:</strong> De Primaire Sleutel (PK) is altijd {NNA}.</li>
                    </ul>

                    <h5>De Theoretische Complexiteit van NULL</h5>
                    <p>De specificatie NA/NNA is meer dan een simpele keuze; het heeft diepgaande theoretische
                        implicaties.</p>
                    <ul>
                        <li><strong>NULL is geen waarde:</strong> <code>NULL</code> is geen 0, geen lege string ("") en
                            geen
                            <code>false</code>. Het is een <strong>marker</strong> voor een "onbekende," "ontbrekende"
                            of
                            "niet-toepasselijke" waarde.
                        </li>
                        <li><strong>Three-Valued Logic (3VL):</strong> Omdat <code>NULL</code> "onbekend" betekent,
                            breekt het
                            de standaard binaire logica (TRUE/FALSE). SQL gebruikt een drie-waarden-logica: TRUE, FALSE,
                            en
                            UNKNOWN.
                            <ul>
                                <li>Een vergelijking zoals <code>leeftijd = 25</code> is TRUE of FALSE.</li>
                                <li>Een vergelijking zoals <code>leeftijd = NULL</code> is <strong>altijd</strong>
                                    UNKNOWN
                                    (omdat we niet weten wat <code>leeftijd</code> is).</li>
                            </ul>
                        </li>
                        <li>Een <code>WHERE</code> clausule retourneert enkel rijen waar de conditie TRUE is. Rijen die
                            FALSE of
                            UNKNOWN evalueren, worden <strong>niet</strong> geretourneerd. Dit is een veelvoorkomende
                            bron van
                            bugs.</li>
                        <li><strong>Best Practice:</strong> Om de complexiteit van 3VL te vermijden, is het vaak beter
                            om
                            kolommen als {NNA} (<code>NOT NULL</code>) te definiëren en een <code>DEFAULT</code>
                            constraint (zie
                            5.5.3) te gebruiken om een bekende standaardwaarde (zoals 0 of 'Onbekend') in te vullen. Dit
                            moet
                            echter afgewogen worden tegen de business-semantiek: als "onbekend" een legitieme en aparte
                            staat
                            is, dan is <code>NULL</code> de correcte keuze.</li>
                    </ul>

                    <h4>5.4 Referentiële Integriteit: Foreign Key Specificaties bij Verwijdering (DTC/DTR/DTN)</h4>
                    <p>Referentiële integriteit zorgt ervoor dat relaties tussen tabellen geldig blijven. Een cruciale
                        vraag is:
                        wat gebeurt er met de 'child' records (bv. de <code>Boeken</code>) als het 'parent' record (bv.
                        de
                        <code>Series</code>) waarnaar ze verwijzen, wordt verwijderd?. Dit gedrag wordt gedefinieerd
                        door de
                        <code>ON DELETE</code> clausule van de Foreign Key. De keuze tussen deze opties is een
                        <strong>business</strong> beslissing, geen technische.
                    </p>

                    <h5>5.4.1 Delete of target restricted (DTR) / ON DELETE RESTRICT</h5>
                    <ul>
                        <li><strong>Functioneel:</strong> De database <strong>weigert</strong> het 'parent' record te
                            verwijderen zolang er nog 'child' records naar verwijzen. De gebruiker krijgt een
                            foutmelding.</li>
                        <li><strong>Toepassing (Richtlijn):</strong> Dit is de <strong>veiligste</strong> en
                            <strong>standaardoptie</strong>. Het dwingt de applicatie of gebruiker om eerst de
                            afhankelijke
                            records (de boeken) te verwijderen of aan een andere serie te koppelen voordat de serie zelf
                            verwijderd kan worden. Gebruik dit voor alle kritieke data waar het 'kind' een zelfstandige
                            waarde
                            heeft.
                        </li>
                        <li><strong>Voorbeeld:</strong> Een <code>Klant</code> met <code>Bestellingen</code>. Het
                            systeem moet
                            <strong>weigeren</strong> de <code>Klant</code> te verwijderen zolang er nog financiële
                            <code>Bestellingen</code> aan gekoppeld zijn.
                        </li>
                    </ul>

                    <h5>5.4.2 Delete of target cascades (DTC) / ON DELETE CASCADE</h5>
                    <ul>
                        <li><strong>Functioneel:</strong> Het verwijderen van het 'parent' record (bv. een
                            <code>Order</code>)
                            activeert een kettingreactie die <strong>automatisch</strong> alle bijbehorende 'child'
                            records (bv.
                            alle <code>Orderlijn</code> records voor die order) ook verwijdert.
                        </li>
                        <li><strong>Gevaar:</strong> Deze optie is "heel gevaarlijk". Een foutieve verwijdering kan
                            onomkeerbaar
                            dataverlies veroorzaken ("SQL HEEFT GEEN UNDO").</li>
                        <li><strong>Toepassing (Richtlijn):</strong> Mag "bijna uitsluitend in associatietabellen
                            gebruikt
                            worden". Gebruik dit <strong>enkel</strong> voor data die <strong>conceptueel
                                eigendom</strong> is
                            van de 'parent' en geen zelfstandig bestaansrecht heeft (bv. zwakke entiteiten of
                            associatietabellen).</li>
                        <li><strong>Voorbeeld:</strong> Een <code>Bestelling</code> en zijn <code>Bestelregels</code>.
                            Als de
                            <code>Bestelling</code> wordt geannuleerd en verwijderd, zijn de bijbehorende
                            <code>Bestelregels</code> nutteloos en <strong>moeten</strong> ze mee verwijderd worden.
                        </li>
                    </ul>

                    <h5>5.4.3 Delete of target nullifies (DTN) / ON DELETE SET NULL</h5>
                    <ul>
                        <li><strong>Functioneel:</strong> Het verwijderen van het 'parent' record (bv.
                            <code>Series</code>)
                            zorgt ervoor dat de FK-kolom (<code>seriesId</code>) in alle afhankelijke 'child' records
                            (de
                            <code>Boeken</code>) automatisch op <code>NULL</code> wordt gezet. De boeken blijven
                            bestaan, maar
                            zijn nu 'serie-loos'.
                        </li>
                        <li><strong>Voorwaarde (Regel):</strong> Dit is <strong>enkel mogelijk</strong> indien de
                            relatie
                            optioneel is (Aard = 0) en de FK-kolom dus <strong>Nulls Allowed (NA)</strong> is. Als de FK
                            {NNA}
                            was, zou deze actie falen.</li>
                        <li><strong>Toepassing (Richtlijn):</strong> Gebruik dit voor <strong>optionele
                                associaties</strong>
                            waarbij het 'kind' prima zelfstandig kan bestaan, maar de koppeling mag vervallen.</li>
                        <li><strong>Voorbeeld:</strong> De unaire relatie <code>Werknemer</code> (zie 4.5.1). Als een
                            <code>Manager</code> wordt verwijderd, wil men niet al zijn ondergeschikten verwijderen
                            (geen DTC).
                            Men wil de <code>managerId</code> van deze werknemers op <code>NULL</code> zetten, waardoor
                            ze
                            'manager-loos' worden totdat ze opnieuw toegewezen worden.
                        </li>
                    </ul>

                    <h4>5.5 Overige Attribuut- en Tabelconstraints (Het Integriteitsframework)</h4>
                    <p>Naast PK, FK, en NULL-specificaties, zijn er drie cruciale constraints die de <strong>Domain
                            Integrity</strong> (de geldigheid van een waarde) en <strong>Business Rule
                            Integrity</strong> (de
                        naleving van bedrijfsregels) afdwingen.</p>

                    <h5>5.5.1 De UNIQUE Constraint</h5>
                    <ul>
                        <li><strong>Definitie:</strong> Dwingt af dat elke waarde in een kolom (of een combinatie van
                            kolommen)
                            uniek moet zijn binnen de tabel. Geen duplicaten toegestaan.</li>
                        <li><strong>Doel:</strong> Dit is de technische implementatie van een <strong>Alternatieve
                                Sleutel
                                (AK)</strong> (zie 3.3). Het dwingt een <strong>business rule</strong> af, los van de
                            PK.</li>
                        <li><strong>Voorbeeld:</strong> In een <code>Gebruiker</code> tabel is <code>id</code> de PK,
                            maar
                            <code>email</code> moet ook uniek zijn. Dit wordt afgedwongen met een <code>UNIQUE</code>
                            constraint.
                        </li>
                    </ul>
                    <p><strong>SQL Syntax:</strong></p>
                    <pre><code>CREATE TABLE Gebruiker (
    id INT PRIMARY KEY,
    email VARCHAR(255) NOT NULL,

    -- Out-of-line syntax (geeft de constraint een naam)
    CONSTRAINT AK_Gebruiker_Email UNIQUE (email)
);
-- Of In-line syntax: 
-- email VARCHAR(255) NOT NULL UNIQUE 
</code></pre>

                    <h5>5.5.2 De CHECK Constraint</h5>
                    <ul>
                        <li><strong>Definitie:</strong> Een <code>CHECK</code> constraint is een krachtige regel die
                            afdwingt
                            dat de waarde in een kolom moet voldoen aan een specifieke Booleaanse voorwaarde.</li>
                        <li><strong>Doel:</strong> Dwingt <strong>Domain Integrity</strong> af. Het voorkomt
                            <strong>semantisch</strong> ongeldige data die het datatype wel zou toestaan (bv. een
                            <code>integer</code> datatype staat -5 toe, maar een <code>CHECK (leeftijd > 0)</code>
                            voorkomt
                            dit).
                        </li>
                        <li><strong>Voorbeelden:</strong>
                            <ul>
                                <li><code>prijs DECIMAL(10, 2) CHECK (prijs > 0)</code></li>
                                <li><code>geslacht CHAR(1) CHECK (geslacht IN ('M', 'V', 'X'))</code></li>
                                <li><code>eindDatum DATE CHECK (eindDatum >= beginDatum)</code> (een multi-kolom 'table
                                    constraint')</li>
                            </ul>
                        </li>
                    </ul>
                    <p><strong>SQL Syntax:</strong></p>
                    <pre><code>CREATE TABLE Product (
    id INT PRIMARY KEY,
    prijs DECIMAL(10, 2) NOT NULL,
    kostprijs DECIMAL(10, 2) NOT NULL,

    -- Dwingt af dat prijs positief moet zijn
    CONSTRAINT CK_Product_Prijs CHECK (prijs > 0),

    -- Dwingt een business rule af (marge moet positief zijn)
    CONSTRAINT CK_Product_Marge CHECK (prijs > kostprijs)
);</code></pre>

                    <h5>5.5.3 De DEFAULT Constraint</h5>
                    <ul>
                        <li><strong>Definitie:</strong> Specificeert een <strong>standaardwaarde</strong> die
                            automatisch door
                            de database wordt ingevoegd wanneer een <code>INSERT</code>-statement <strong>geen</strong>
                            expliciete waarde voor die kolom opgeeft.</li>
                        <li><strong>Doel:</strong> Vereenvoudigt data-invoer en, nog belangrijker, voorkomt ongewenste
                            <code>NULL</code>-waarden in {NA}-kolommen (waardoor de 3VL-problematiek uit 5.3 wordt
                            vermeden).
                        </li>
                        <li><strong>Voorbeelden:</strong>
                            <ul>
                                <li><code>isActief BIT DEFAULT 1</code> (Standaard is 'true')</li>
                                <li><code>status VARCHAR(20) DEFAULT 'In behandeling'</code></li>
                                <li><code>creatieDatum DATETIME DEFAULT GETDATE()</code> (Gebruikt een database-functie)
                                </li>
                            </ul>
                        </li>
                    </ul>
                    <p><strong>SQL Syntax:</strong></p>
                    <pre><code>CREATE TABLE Bestelling (
    id INT PRIMARY KEY,
    klantId INT NOT NULL,
    
    -- Als de INSERT geen orderDatum specificeert, 
    -- wordt de huidige datum/tijd automatisch ingevuld
    orderDatum DATE NOT NULL DEFAULT GETDATE(),
    
    status VARCHAR(50) NOT NULL DEFAULT 'In behandeling'
);</code></pre>

                    <h4>5.6 Samenvattende Tabel: Het Data Integriteitsframework</h4>
                    <p>De verschillende constraints werken samen om de database te beschermen. Ze kunnen worden
                        gecategoriseerd
                        op basis van het type integriteit dat ze bewaken.</p>
                    <div class="overflow-x-auto">
                        <table>
                            <thead>
                                <tr>
                                    <th>Integriteitstype</th>
                                    <th>Constraint</th>
                                    <th>Doel (Beschermt wat?)</th>
                                    <th>SQL Voorbeeld</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td><strong>Entity Integrity</strong></td>
                                    <td><code>PRIMARY KEY</code></td>
                                    <td>De <strong>identiteit</strong> van een rij. Garandeert uniciteit.</td>
                                    <td><code>id INT PRIMARY KEY</code></td>
                                </tr>
                                <tr>
                                    <td><strong>Entity Integrity</strong></td>
                                    <td><code>NOT NULL {NNA}</code></td>
                                    <td>Het <strong>bestaan</strong> van een waarde. Voorkomt 'onbekend'.</td>
                                    <td><code>naam VARCHAR(100) NOT NULL</code></td>
                                </tr>
                                <tr>
                                    <td><strong>Referential Integrity</strong></td>
                                    <td><code>FOREIGN KEY</code></td>
                                    <td>De <strong>validiteit van relaties</strong>. Voorkomt 'wees'-records.</td>
                                    <td><code>FOREIGN KEY (klantId) REFERENCES Klant(id)</code></td>
                                </tr>
                                <tr>
                                    <td><strong>Referential Integrity</strong></td>
                                    <td><code>ON DELETE</code> Specs</td>
                                    <td>Het <strong>gedrag</strong> bij het verwijderen van een 'ouder'.</td>
                                    <td><code>... ON DELETE RESTRICT</code></td>
                                </tr>
                                <tr>
                                    <td><strong>Domain Integrity</strong></td>
                                    <td><code>Datatype</code></td>
                                    <td>De <strong>syntaxis</strong> van een waarde.</td>
                                    <td><code>leeftijd INT</code></td>
                                </tr>
                                <tr>
                                    <td><strong>Domain Integrity</strong></td>
                                    <td><code>CHECK</code></td>
                                    <td>De <strong>semantiek</strong> van een waarde (business rule).</td>
                                    <td><code>CHECK (leeftijd >= 18)</code></td>
                                </tr>
                                <tr>
                                    <td><strong>Domain Integrity</strong></td>
                                    <td><code>DEFAULT</code></td>
                                    <td>De <strong>standaardwaarde</strong> (voorkomt <code>NULL</code>).</td>
                                    <td><code>isActief BIT DEFAULT 1</code></td>
                                </tr>
                                <tr>
                                    <td><strong>Business Integrity</strong></td>
                                    <td><code>UNIQUE (AK)</code></td>
                                    <td>De <strong>uniciteit</strong> van een business-attribuut.</td>
                                    <td><code>email VARCHAR(255) UNIQUE</code></td>
                                </tr>
                            </tbody>
                        </table>
                    </div>

                    <h3 id="volledige-tekst-6-1">Deel 6: Van Theorie naar Praktijk: De SQL-Vertaling (Mapping ERD naar
                        SQL)</h3>
                    <p>Het fysieke ERD dient als directe blauwdruk voor de <code>CREATE TABLE</code> statements in SQL.
                    </p>

                    <h4>6.1 Conceptuele Mapping: Van ERD-diagram naar CREATE TABLE</h4>
                    <ul>
                        <li>Elke <strong>Entiteit</strong> in het PDM wordt een
                            <code>CREATE TABLE Schemanaam.Tabelnaam</code>
                            statement.
                        </li>
                        <li>Elk <strong>Attribuut</strong> wordt een Kolomdefinitie binnen de <code>()</code> met de
                            syntaxis:
                            <code>veldnaam datatype</code>.
                        </li>
                        <li>ERD: <code>naam: string {NNA}</code> &rarr; SQL: <code>naam varchar(100) NOT NULL</code>.
                        </li>
                        <li>ERD: <code>nicknaam: string {NA}</code> &rarr; SQL: <code>nicknaam varchar(100) NULL</code>.
                        </li>
                    </ul>

                    <h4>6.2 Vertaling van Sleutels en Attribuut-Constraints</h4>
                    <ul>
                        <li><strong>Primaire Sleutel (PK):</strong>
                            <ul>
                                <li><code>CONSTRAINT PK_Tabelnaam PRIMARY KEY (id)</code>.</li>
                            </ul>
                        </li>
                        <li><strong>Surrogaat Sleutel (Auto-nummering):</strong>
                            <ul>
                                <li><code>id int IDENTITY(1,1)</code> (SQL Server syntax, begint bij 1 en telt per 1
                                    op).</li>
                            </ul>
                        </li>
                        <li><strong>Alternatieve Sleutel (AK):</strong>
                            <ul>
                                <li><code>CONSTRAINT UK_Tabelnaam_Veld UNIQUE (veldnaam)</code>.</li>
                            </ul>
                        </li>
                        <li><strong>Check Constraint (Waardebeperking):</strong>
                            <ul>
                                <li><code>CONSTRAINT CK_Persoon_geslacht CHECK (geslacht = 'M' OR geslacht = 'V')</code>.
                                </li>
                            </ul>
                        </li>
                        <li><strong>Default Constraint (Standaardwaarde):</strong>
                            <ul>
                                <li><code>CONSTRAINT DF_Persoon_land DEFAULT 'België'</code>.</li>
                            </ul>
                        </li>
                    </ul>

                    <h4>6.3 Vertaling van Relaties: De FOREIGN KEY en REFERENCES Clausule</h4>
                    <p>De FK-relatie uit het ERD wordt vertaald met een <code>FOREIGN KEY</code> constraint, die gebruik
                        maakt
                        van de <code>REFERENCES</code> clausule om de 'parent' tabel aan te duiden.</p>
                    <ul>
                        <li><strong>Algemene Syntaxis:</strong>
                            <ul>
                                <li><code>CONSTRAINT FK_HuidigeTabel_ParentTabel FOREIGN KEY (lokale_fk_kolom) REFERENCES ParentTabel (parent_pk_kolom)</code>
                                </li>
                            </ul>
                        </li>
                        <li><strong>Voorbeeld 1:</strong>
                            <ul>
                                <li><code>CONSTRAINT FK_Muziek_Uitvoerder FOREIGN KEY (uitvoerderId) REFERENCES Les.Uitvoerder(id)</code>
                                </li>
                            </ul>
                        </li>
                    </ul>

                    <h4>6.4 Vertaling van Referentiële Integriteit: De ON DELETE Clausules</h4>
                    <p>De DTC/DTR/DTN-regels uit het ERD worden als volgt toegevoegd aan het einde van de
                        <code>FOREIGN KEY</code>-definitie:
                    </p>
                    <ul>
                        <li><strong>DTC &rarr; <code>ON DELETE CASCADE</code></strong>
                            <ul>
                                <li>SQL: <code>... REFERENCES Les.Order(id) ON DELETE CASCADE</code>.</li>
                            </ul>
                        </li>
                        <li><strong>DTR &rarr; (Geen toevoeging)</strong>
                            <ul>
                                <li>SQL: Dit is het standaardgedrag van de meeste RDBMS'en; er hoeft niets te worden
                                    toegevoegd.
                                    (Soms expliciet: <code>ON DELETE RESTRICT</code>).</li>
                            </ul>
                        </li>
                        <li><strong>DTN &rarr; <code>ON DELETE SET NULL</code></strong>
                            <ul>
                                <li>SQL: <code>... REFERENCES Les.Product(id) ON DELETE SET NULL</code>.</li>
                            </ul>
                        </li>
                    </ul>

                    <h4>6.5 De Bouwvolgorde: CREATE en DROP</h4>
                    <p>Vanwege de <code>FOREIGN KEY</code> constraints (en de DTR-regel) is de volgorde waarin tabellen
                        worden
                        aangemaakt en verwijderd cruciaal.</p>
                    <ul>
                        <li><strong>CREATE TABLE Volgorde (Top-Down):</strong>
                            <ol>
                                <li>Maak eerst de 'parent' tabellen (de '1'-kant, tabellen zonder FKs), bv.
                                    <code>Klant</code>,
                                    <code>Gerecht</code>.
                                </li>
                                <li>Maak daarna de 'child' tabellen (de '*'-kant, tabellen met FKs), bv.
                                    <code>Bestelling</code>
                                    (die verwijst naar <code>Klant</code>).
                                </li>
                                <li>Maak als laatste de associatietabellen, bv. <code>BestellingGerecht</code> (verwijst
                                    naar
                                    <code>Bestelling</code> en <code>Gerecht</code>).
                                </li>
                            </ol>
                        </li>
                        <li><strong>DROP TABLE Volgorde (Bottom-Up):</strong>
                            <ol>
                                <li>De volgorde is exact omgekeerd aan de creatie.</li>
                                <li>Verwijder eerst de tabellen die verwijzen (associatietabellen zoals
                                    <code>BestellingGerecht</code>).
                                </li>
                                <li>Verwijder daarna de 'child' tabellen (<code>Bestelling</code>).</li>
                                <li>Verwijder als laatste de 'parent' tabellen (<code>Klant</code>,
                                    <code>Gerecht</code>).
                                </li>
                            </ol>
                        </li>
                    </ul>

                    <h3 class="mt-8">Conclusie</h3>
                    <p>ERD-modellering is een gestructureerd en progressief proces dat evolueert van een abstract
                        conceptueel
                        model (de 'wat'-vraag) naar een gedetailleerd fysiek model (de 'hoe'-vraag). Elke stap voegt een
                        diepere
                        laag van specificatie toe: van het definiëren van attributen (met aandacht voor het vermijden
                        van
                        samengestelde en berekende data), tot het architecturaal opzetten van sleutels (met een voorkeur
                        voor
                        surrogaat id sleutels), en het nauwkeurig definiëren van relaties.</p>
                    <p>De kern van een robuust model ligt in het correct toepassen van de regels voor de plaatsing van
                        Foreign
                        Keys (altijd aan de 'veel'-kant) en het oplossen van <code>M:N</code>-relaties via
                        associatie-entiteiten. De uiteindelijke specificatie van datatypes, Null-toegestaanheid (NA/NNA)
                        en On
                        Delete-gedrag (DTC/DTR/DTN) vertaalt de businesslogica naar afdwingbare integriteitsregels. Een
                        correcte
                        vertaling van dit fysieke model naar SQL, met inachtneming van de creatie- en
                        verwijderingsvolgorde,
                        garandeert een stabiele, efficiënte en integere database.</p>

                </section>
                <!-- EINDE NIEUWE SECTIE -->

            </div>

            <footer class="text-center py-6 bg-slate-100 border-t border-slate-200">
                <p class="text-sm text-slate-500">Interactieve Studiegids ERD-Modellering</p>
            </footer>

            <script>
                document.addEventListener('DOMContentLoaded', () => {
                    // --- Navigatie Logic ---
                    const navLinks = document.querySelectorAll('nav a[data-target]');
                    const sections = document.querySelectorAll('main section[id]');
                    const sidebarNav = document.getElementById('sidebar-nav');
                    const mobileMenuBtn = document.getElementById('mobile-menu-btn');

                    // ========== QUIZ DATA ==========
                    const QUIZZES = [
                        {
                            sectionId: 'deel-1',
                            title: 'Kennischeck – Fundamenten',
                            questions: [
                                {
                                    id: 'd1q1', type: 'single', prompt: 'Welke eigenschap hoort bij relationele tabellen?', choices: [
                                        { id: 'a', text: 'Rijvolgorde bepaalt de betekenis', correct: false },
                                        { id: 'b', text: 'Kolomvolgorde is onbelangrijk', correct: true }
                                    ], explanation: 'De volgorde van rijen en kolommen is niet bepalend in het relationele model.'
                                },
                                { id: 'd1q2', type: 'text', prompt: 'Hoe noemen we een tabel in het relationele model? (één woord)', answerPattern: '^relatie$', explanation: 'Een tabel heet een “relatie”.' },
                                {
                                    id: 'd1q3', type: 'multi', prompt: 'Kruis de juiste uitspraken aan:', choices: [
                                        { id: 'a', text: 'Data zijn ruwe feiten', correct: true },
                                        { id: 'b', text: 'Informatie is geïnterpreteerde data', correct: true },
                                        { id: 'c', text: 'Data is altijd betekenisvol', correct: false }
                                    ], explanation: 'Data zijn ruwe feiten; informatie is data in context.'
                                },
                                {
                                    id: 'd1q4', type: 'single', prompt: 'Wat is een DBMS?', choices: [
                                        { id: 'a', text: 'Software om databases te beheren', correct: true },
                                        { id: 'b', text: 'Een datatype voor tekst', correct: false }
                                    ], explanation: 'Een DBMS beheert de opslag, toegang en integriteit van data.'
                                },
                                {
                                    id: 'd1q5', type: 'single', prompt: 'Een cel (rij x kolom) bevat …', choices: [
                                        { id: 'a', text: 'Meerdere waarden', correct: false },
                                        { id: 'b', text: 'Exact één atomische waarde', correct: true }
                                    ], explanation: 'Atomisch: één waarde per kruising van rij en kolom.'
                                },
                                { id: 'd1q6', type: 'text', prompt: 'Welke sleutel garandeert unieke rijen? (twee woorden of Engels)', answerPattern: '^primaire sleutel$|^primary key$', explanation: 'De primaire sleutel (Primary Key) garandeert uniekheid.' }
                            ]
                        },
                        {
                            sectionId: 'deel-2',
                            title: 'Kennischeck – Modellen',
                            questions: [
                                {
                                    id: 'd2q1', type: 'single', prompt: 'Wat is toegestaan in een Conceptueel Model (CDM)?', choices: [
                                        { id: 'a', text: 'M:N relaties', correct: true },
                                        { id: 'b', text: 'Specifieke DBMS-datatypes', correct: false }
                                    ], explanation: 'In CDM kun je M:N gebruiken; DBMS-datatypes horen niet in CDM.'
                                },
                                {
                                    id: 'd2q2', type: 'multi', prompt: 'Welke horen bij het Logisch Model (LDM)? (meerdere)', choices: [
                                        { id: 'a', text: 'PK/FK notatie', correct: true },
                                        { id: 'b', text: 'Fysieke indexen en partities', correct: false },
                                        { id: 'c', text: 'Generieke datatypes (int/date)', correct: true }
                                    ], explanation: 'LDM bevat PK/FK en generieke types; fysieke zaken horen in PDM.'
                                },
                                {
                                    id: 'd2q3', type: 'single', prompt: 'Waar gebruik je DBMS-specifieke datatypes?', choices: [
                                        { id: 'a', text: 'Conceptueel Model (CDM)', correct: false },
                                        { id: 'b', text: 'Fysiek Model (PDM)', correct: true }
                                    ], explanation: 'DBMS-specifieke types (bv. varchar2) horen in het PDM.'
                                },
                                { id: 'd2q4', type: 'text', prompt: 'Normalisatie reduceert vooral … (één woord)', answerPattern: '^redundan', explanation: 'Normalisatie reduceert redundantie.' },
                                {
                                    id: 'd2q5', type: 'multi', prompt: 'Welke uitspraken over CDM kloppen?', choices: [
                                        { id: 'a', text: 'Geen DBMS-datatypes', correct: true },
                                        { id: 'b', text: 'PK/FK zijn verplicht', correct: false },
                                        { id: 'c', text: 'M:N relaties toegestaan', correct: true }
                                    ], explanation: 'CDM is business-semantiek: geen technische details, M:N kan.'
                                }
                            ]
                        },
                        {
                            sectionId: 'deel-3',
                            title: 'Kennischeck – Sleutels',
                            questions: [
                                {
                                    id: 'd3q1', type: 'multi', prompt: 'Kruis alle eigenschappen van een PK aan:', choices: [
                                        { id: 'a', text: 'Uniek', correct: true },
                                        { id: 'b', text: 'Mag NULL zijn', correct: false },
                                        { id: 'c', text: 'Identificeert rij', correct: true }
                                    ], explanation: 'PK is uniek, niet-NULL en identificeert de rij.'
                                },
                                {
                                    id: 'd3q2', type: 'single', prompt: 'Wat is een Alternatieve Sleutel (AK)?', choices: [
                                        { id: 'a', text: 'Een kandidaat-sleutel die niet als PK is gekozen', correct: true },
                                        { id: 'b', text: 'Een willekeurige FK', correct: false }
                                    ], explanation: 'AK is een kandidaat-sleutel die geen PK is.'
                                },
                                {
                                    id: 'd3q3', type: 'single', prompt: 'Wat is een surrogaat sleutel?', choices: [
                                        { id: 'a', text: 'Een kunstmatige sleutel gegenereerd door het systeem', correct: true },
                                        { id: 'b', text: 'Een natuurlijke sleutel vanuit de business', correct: false }
                                    ], explanation: 'Surrogaat = kunstmatig (bv. IDENTITY/UUID).'
                                },
                                {
                                    id: 'd3q4', type: 'multi', prompt: 'Selecteer juiste uitspraken over Foreign Keys:', choices: [
                                        { id: 'a', text: 'Verwijst naar PK of AK van de parent', correct: true },
                                        { id: 'b', text: 'Kan NULL zijn afhankelijk van de relatie/businessregels', correct: true },
                                        { id: 'c', text: 'Is altijd uniek', correct: false }
                                    ], explanation: 'FK verwijst naar een sleutel; uniekheid is niet standaard vereist.'
                                }
                            ]
                        },
                        {
                            sectionId: 'deel-4',
                            title: 'Kennischeck – Relaties',
                            questions: [
                                {
                                    id: 'd4q1', type: 'single', prompt: 'Waar staat de FK bij 1:N?', choices: [
                                        { id: 'a', text: 'Altijd aan de 1-kant', correct: false },
                                        { id: 'b', text: 'Altijd aan de N-kant', correct: true }
                                    ], explanation: 'De FK staat aan de “veel”-kant.'
                                },
                                { id: 'd4q2', type: 'text', prompt: 'Hoe los je een M:N relatie op? (één woord)', answerPattern: '^associatie|associatietabel|tussentabel$', explanation: 'Door een associatietabel/tussentabel met twee 1:N relaties.' },
                                {
                                    id: 'd4q3', type: 'single', prompt: 'Een 1:1 relatie wordt vaak gebruikt voor …', choices: [
                                        { id: 'a', text: 'Optionele detailgegevens in aparte tabel', correct: true },
                                        { id: 'b', text: 'Het modelleren van M:N', correct: false }
                                    ], explanation: '1:1 splitst vaak optionele of zelden gebruikte gegevens af.'
                                },
                                {
                                    id: 'd4q4', type: 'multi', prompt: 'Eigenschappen van een associatietabel:', choices: [
                                        { id: 'a', text: 'Bevat FKs naar beide entiteiten', correct: true },
                                        { id: 'b', text: 'Lost M:N relaties op', correct: true },
                                        { id: 'c', text: 'Mag nooit extra attributen bevatten', correct: false }
                                    ], explanation: 'Associatietabellen kunnen extra attributen bevatten (bv. rol, datum).'
                                },
                                { id: 'd4q5', type: 'text', prompt: 'Hoe heet een relatie van een entiteit met zichzelf? (één woord)', answerPattern: '^recurs', explanation: 'Dat is een recursieve relatie.' }
                            ]
                        },
                        {
                            sectionId: 'deel-5',
                            title: 'Kennischeck – Constraints',
                            questions: [
                                {
                                    id: 'd5q1', type: 'single', prompt: 'Wat betekent NNA bij een attribuut?', choices: [
                                        { id: 'a', text: 'Null Not Allowed', correct: true },
                                        { id: 'b', text: 'Null Now Allowed', correct: false }
                                    ], explanation: 'NNA = Null Not Allowed.'
                                },
                                {
                                    id: 'd5q2', type: 'single', prompt: 'Welke ON DELETE actie verwijdert children?', choices: [
                                        { id: 'a', text: 'DTR (Restrict)', correct: false },
                                        { id: 'b', text: 'DTC (Cascade)', correct: true },
                                        { id: 'c', text: 'DTN (Set Null)', correct: false }
                                    ], explanation: 'Cascade verwijdert de children automatisch.'
                                },
                                {
                                    id: 'd5q3', type: 'multi', prompt: 'Wat doet een UNIQUE constraint? (meerdere)', choices: [
                                        { id: 'a', text: 'Voorkomt duplicaten', correct: true },
                                        { id: 'b', text: 'Kan (afhankelijk van DBMS) meerdere NULL-waarden toestaan', correct: true },
                                        { id: 'c', text: 'Verwijdert rijen bij conflict', correct: false }
                                    ], explanation: 'UNIQUE voorkomt duplicaten; gedrag met NULLs verschilt per DBMS.'
                                },
                                {
                                    id: 'd5q4', type: 'single', prompt: 'Een CHECK constraint …', choices: [
                                        { id: 'a', text: 'Valideert toegestane waarden in een kolom', correct: true },
                                        { id: 'b', text: 'Bepaalt join-strategieën van de optimizer', correct: false }
                                    ], explanation: 'CHECK valideert waardebereiken of patronen.'
                                },
                                { id: 'd5q5', type: 'text', prompt: 'Welke afkorting hoort bij ON DELETE SET NULL? (drie letters)', answerPattern: '^dtn$', explanation: 'DTN staat voor Set Null.' }
                            ]
                        },
                        {
                            sectionId: 'deel-6',
                            title: 'Kennischeck – SQL Implementatie',
                            questions: [
                                {
                                    id: 'd6q1', type: 'single', prompt: 'Wat creëer je eerst in correcte SQL-orde?', choices: [
                                        { id: 'a', text: 'Tabellen zonder FK', correct: true },
                                        { id: 'b', text: 'Foreign Keys', correct: false }
                                    ], explanation: 'Eerst tabellen, nadien constraints zoals FK.'
                                },
                                { id: 'd6q2', type: 'text', prompt: 'Hoe noem je het verwijderen van child-rijen automatisch? (één woord)', answerPattern: '^cascade$', explanation: 'Dat is “cascade”.' },
                                {
                                    id: 'd6q3', type: 'multi', prompt: 'Kies de correcte drop-volgorde:', choices: [
                                        { id: 'a', text: 'Eerst foreign keys droppen', correct: true },
                                        { id: 'b', text: 'Daarna tabellen droppen', correct: true },
                                        { id: 'c', text: 'Altijd eerst views droppen', correct: false }
                                    ], explanation: 'Verwijder afhankelijkheden (FK) vóór tabellen.'
                                },
                                {
                                    id: 'd6q4', type: 'single', prompt: 'DML staat voor …', choices: [
                                        { id: 'a', text: 'Data Manipulation Language', correct: true },
                                        { id: 'b', text: 'Database Machine Logic', correct: false }
                                    ], explanation: 'DML = SELECT/INSERT/UPDATE/DELETE.'
                                },
                                { id: 'd6q5', type: 'text', prompt: 'Welk SQL-commando gebruik je om de structuur te wijzigen? (één woord)', answerPattern: '^alter$', explanation: 'ALTER TABLE …' }
                            ]
                        }
                    ];

                    function updateActiveLink(targetId) {
                        navLinks.forEach(link => {
                            link.classList.toggle('active', link.getAttribute('data-target') === targetId);
                        });
                    }

                    navLinks.forEach(link => {
                        link.addEventListener('click', (e) => {
                            e.preventDefault();
                            const targetId = link.getAttribute('data-target');
                            const targetElement = document.getElementById(targetId);
                            if (targetElement) {
                                targetElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
                                if (window.innerWidth < 768) {
                                    sidebarNav.classList.remove('open');
                                    if (sidebarOverlay) {
                                        sidebarOverlay.classList.remove('active');
                                    }
                                }
                            }
                        });
                    });

                    // Mobile menu toggle
                    const sidebarOverlay = document.getElementById('sidebar-overlay');
                    if (mobileMenuBtn) {
                        mobileMenuBtn.addEventListener('click', () => {
                            sidebarNav.classList.toggle('open');
                            if (sidebarOverlay) {
                                sidebarOverlay.classList.toggle('active');
                            }
                        });
                    }

                    // Sluit menu bij klik op overlay
                    if (sidebarOverlay) {
                        sidebarOverlay.addEventListener('click', () => {
                            sidebarNav.classList.remove('open');
                            sidebarOverlay.classList.remove('active');
                        });
                    }

                    // Sluit menu bij klik buiten menu op mobiel
                    document.addEventListener('click', (e) => {
                        if (window.innerWidth < 768) {
                            const isClickInsideNav = sidebarNav.contains(e.target);
                            const isClickOnButton = mobileMenuBtn && mobileMenuBtn.contains(e.target);
                            if (!isClickInsideNav && !isClickOnButton && sidebarNav.classList.contains('open')) {
                                sidebarNav.classList.remove('open');
                                if (sidebarOverlay) {
                                    sidebarOverlay.classList.remove('active');
                                }
                            }
                        }
                    });

                    // ========== QUIZ ENGINE ==========
                    class QuizEngine {
                        constructor(config, container, onFinish) {
                            this.config = config;
                            this.container = container;
                            this.onFinish = onFinish;
                            this.index = 0;
                            this.answers = {};
                            this.loadProgress();
                            this.renderIntro();
                        }
                        key() { return `quiz:${this.config.sectionId}`; }
                        loadProgress() {
                            const raw = localStorage.getItem(this.key());
                            this.progress = raw ? JSON.parse(raw) : null;
                        }
                        saveProgress(summary) {
                            localStorage.setItem(this.key(), JSON.stringify(summary));
                        }
                        renderIntro() {
                            this.container.innerHTML = `
                              <div class="quiz-card">
                                <div class="quiz-header">
                                  <div class="quiz-title">${this.config.title}</div>
                                  <div class="text-sm text-slate-600">${this.config.questions.length} vragen</div>
                                </div>
                                <div class="quiz-body">
                                  <p class="mb-3">Test kort je begrip van dit deel voordat je verder gaat.</p>
                                  ${this.progress ? `<div class="mb-3 text-sm text-slate-600">Laatste score: <strong>${this.progress.score}/${this.progress.total}</strong></div>` : ''}
                                  <div class="quiz-progress mb-3"><div style="width:0%"></div></div>
                                  <button class="start-btn px-4 py-2 bg-emerald-600 text-white rounded hover:bg-emerald-700">Start</button>
                                </div>
                              </div>`;
                            this.container.querySelector('.start-btn').addEventListener('click', () => this.renderQuestion());
                        }
                        renderQuestion() {
                            const q = this.config.questions[this.index];
                            const progressPct = Math.round((this.index) / this.config.questions.length * 100);
                            const choicesHtml = q.type === 'text' ? `
                                <input type="text" class="quiz-text w-full p-2 border rounded" placeholder="Typ je antwoord..." />
                            ` : q.choices.map(c => `
                                <label class="quiz-choice" data-id="${c.id}">
                                  <input ${q.type === 'multi' ? 'type="checkbox"' : 'type="radio" name="q"'} class="sr-only">
                                  <span>${c.text}</span>
                                </label>`).join('');
                            this.container.innerHTML = `
                              <div class="quiz-card">
                                <div class="quiz-header">
                                  <div class="quiz-title">${this.config.title}</div>
                                  <div class="text-sm text-slate-600">${this.index + 1}/${this.config.questions.length}</div>
                                </div>
                                <div class="quiz-body">
                                  <div class="mb-2 font-semibold">${q.prompt}</div>
                                  <div class="space-y-2">${choicesHtml}</div>
                                  <div class="quiz-explanation hidden"></div>
                                </div>
                                <div class="quiz-actions">
                                  <button class="check-btn px-3 py-2 bg-slate-800 text-white rounded hover:bg-slate-900">Check</button>
                                  <button class="next-btn px-3 py-2 bg-emerald-600 text-white rounded hover:bg-emerald-700 hidden">Volgende</button>
                                </div>
                                <div class="p-3"><div class="quiz-progress"><div style="width:${progressPct}%"></div></div></div>
                              </div>`;
                            // Choice selection styling
                            this.container.querySelectorAll('.quiz-choice').forEach(el => {
                                const input = el.querySelector('input');
                                // Sync class with input state (for accessibility/keyboard)
                                if (q.type === 'multi') {
                                    input.addEventListener('change', (e) => {
                                        el.classList.toggle('selected', input.checked);
                                    });
                                } else {
                                    input.addEventListener('change', () => {
                                        this.container.querySelectorAll('.quiz-choice').forEach(x => {
                                            x.classList.remove('selected');
                                            const rx = x.querySelector('input');
                                            if (rx) rx.checked = false;
                                        });
                                        el.classList.add('selected');
                                        input.checked = true;
                                    });
                                }
                                // Click on label for mouse/touch
                                el.addEventListener('click', (ev) => {
                                    if (q.type === 'multi') {
                                        ev.preventDefault();
                                        const willSelect = !el.classList.contains('selected');
                                        el.classList.toggle('selected', willSelect);
                                        input.checked = willSelect;
                                    } else {
                                        this.container.querySelectorAll('.quiz-choice').forEach(x => {
                                            x.classList.remove('selected');
                                            const rx = x.querySelector('input');
                                            if (rx) rx.checked = false;
                                        });
                                        el.classList.add('selected');
                                        input.checked = true;
                                    }
                                });
                            });
                            this.container.querySelector('.check-btn').addEventListener('click', () => this.check(q));
                            this.container.querySelector('.next-btn').addEventListener('click', () => this.next());
                        }
                        check(q) {
                            let correct = false;
                            if (q.type === 'text') {
                                const val = (this.container.querySelector('.quiz-text')?.value || '').trim().toLowerCase();
                                correct = !!(new RegExp(q.answerPattern, 'i').test(val));
                            } else if (q.type === 'single') {
                                const sel = this.container.querySelector('.quiz-choice.selected');
                                const id = sel ? sel.getAttribute('data-id') : null;
                                correct = !!q.choices.find(c => c.id === id && c.correct);
                                // visual
                                this.container.querySelectorAll('.quiz-choice').forEach(el => {
                                    const eid = el.getAttribute('data-id');
                                    const isCorrect = q.choices.find(c => c.id === eid)?.correct;
                                    el.classList.add(isCorrect ? 'correct' : 'incorrect');
                                });
                            } else if (q.type === 'multi') {
                                const selectedIds = [...this.container.querySelectorAll('.quiz-choice.selected')].map(el => el.getAttribute('data-id'));
                                const correctSet = q.choices.filter(c => c.correct).map(c => c.id).sort().join(',');
                                const selectedSet = selectedIds.sort().join(',');
                                correct = correctSet === selectedSet;
                                this.container.querySelectorAll('.quiz-choice').forEach(el => {
                                    const eid = el.getAttribute('data-id');
                                    const isCorrect = q.choices.find(c => c.id === eid)?.correct;
                                    el.classList.add(isCorrect ? 'correct' : 'incorrect');
                                });
                            }
                            this.answers[q.id] = !!correct;
                            const exp = this.container.querySelector('.quiz-explanation');
                            if (exp) {
                                exp.classList.remove('hidden');
                                exp.innerHTML = `${correct ? '<span class="text-emerald-700 font-semibold">Correct</span>' : '<span class="text-rose-700 font-semibold">Niet correct</span>'} – ${q.explanation || ''}`;
                            }
                            const nextBtn = this.container.querySelector('.next-btn');
                            if (nextBtn) nextBtn.classList.remove('hidden');
                        }
                        next() {
                            this.index++;
                            if (this.index >= this.config.questions.length) {
                                this.finish();
                            } else {
                                this.renderQuestion();
                            }
                        }
                        finish() {
                            const total = this.config.questions.length;
                            const score = Object.values(this.answers).filter(Boolean).length;
                            const summary = { score, total, ts: Date.now() };
                            this.saveProgress(summary);
                            this.container.innerHTML = `
                              <div class="quiz-card">
                                <div class="quiz-header"><div class="quiz-title">${this.config.title}</div></div>
                                <div class="quiz-body">
                                  <div class="text-lg font-semibold mb-2">Jouw score: ${score}/${total}</div>
                                  <div class="quiz-progress mb-3"><div style="width:${Math.round(score / total * 100)}%"></div></div>
                                  <button class="restart px-3 py-2 bg-slate-800 text-white rounded hover:bg-slate-900">Opnieuw</button>
                                </div>
                              </div>`;
                            this.container.querySelector('.restart').addEventListener('click', () => { this.index = 0; this.answers = {}; this.renderIntro(); });
                            if (typeof this.onFinish === 'function') this.onFinish(this.config.sectionId, summary);
                        }
                    }

                    function renderQuizBlocks() {
                        QUIZZES.forEach(cfg => {
                            const sec = document.getElementById(cfg.sectionId);
                            if (!sec) return;
                            let host = sec.querySelector('.quiz-host');
                            if (!host) {
                                host = document.createElement('div');
                                host.className = 'quiz-host mt-6';
                                sec.appendChild(host);
                            }
                            new QuizEngine(cfg, host, updateSidebarBadge);

                            // Dynamische 10-vragen toets CTA
                            let dyn = sec.querySelector('.dyn-quiz-host');
                            if (!dyn) {
                                dyn = document.createElement('div');
                                dyn.className = 'dyn-quiz-host mt-6';
                                dyn.innerHTML = `<div class="quiz-card"><div class="quiz-header"><div class="quiz-title">Hoofdstuktoets – 10 vragen</div></div><div class="quiz-body"><p class="mb-3">Klaar met dit hoofdstuk? Start een willekeurige 10-vragen toets op basis van de stof.</p><button class="dyn-start px-4 py-2 bg-emerald-600 text-white rounded hover:bg-emerald-700">Start kennistoets</button><div class="dyn-container mt-3"></div></div></div>`;
                                sec.appendChild(dyn);
                                const btn = dyn.querySelector('.dyn-start');
                                const container = dyn.querySelector('.dyn-container');
                                if (btn && container) {
                                    btn.addEventListener('click', async () => {
                                        const bank = await loadQuestionBank();
                                        const pool = bank.questions.filter(q => q.chapterId === cfg.sectionId);
                                        const last = JSON.parse(localStorage.getItem(`quiz:last:${cfg.sectionId}`) || 'null');
                                        const avoid = last?.questionIds || [];
                                        const picked = pickRandomQuestions([...pool], 10, avoid);
                                        new DynamicQuizEngine(cfg.sectionId, picked, container, updateSidebarBadge);
                                    });
                                }
                            }
                        });
                    }

                    // --- Loader en helpers ---
                    async function loadQuestionBank() {
                        if (window.__QUESTION_BANK__) return window.__QUESTION_BANK__;
                        try {
                            const res = await fetch('questions.json', { cache: 'no-store' });
                            if (!res.ok) throw new Error('Failed to load questions.json');
                            const data = await res.json();
                            window.__QUESTION_BANK__ = data;
                            return data;
                        } catch (e) {
                            // Fallback op minimale inline set
                            window.__QUESTION_BANK__ = { questions: [] };
                            return window.__QUESTION_BANK__;
                        }
                    }

                    function pickRandomQuestions(pool, count, avoidIds = []) {
                        const candidates = pool.filter(q => !avoidIds.includes(q.id));
                        const source = candidates.length >= count ? candidates : pool;
                        for (let i = source.length - 1; i > 0; i--) {
                            const j = Math.floor(Math.random() * (i + 1));
                            [source[i], source[j]] = [source[j], source[i]];
                        }
                        return source.slice(0, count);
                    }

                    class DynamicQuizEngine {
                        constructor(chapterId, questions, container, onFinish) {
                            this.chapterId = chapterId;
                            this.questions = questions;
                            this.container = container;
                            this.onFinish = onFinish;
                            this.render();
                        }
                        render() {
                            const html = [`<form class="space-y-4">`];
                            this.questions.forEach((q, idx) => {
                                html.push(`<div class="quiz-card"><div class="quiz-header"><div class="quiz-title">Vraag ${idx + 1}</div></div><div class="quiz-body"><div class="mb-2 font-semibold">${q.prompt}</div>`);
                                if (q.type === 'text') {
                                    html.push(`<input type="text" class="w-full p-2 border rounded" name="${q.id}" placeholder="Antwoord">`);
                                } else {
                                    const group = q.type === 'multi' ? '' : `name="${q.id}"`;
                                    q.choices?.forEach(choice => {
                                        const inputType = q.type === 'multi' ? 'checkbox' : 'radio';
                                        html.push(`<label class="quiz-choice"><input type="${inputType}" ${group} value="${choice.id}"><span>${choice.text}</span></label>`);
                                    });
                                }
                                html.push(`</div></div>`);
                            });
                            html.push(`<div class="flex gap-2"><button type="submit" class="px-4 py-2 bg-emerald-600 text-white rounded hover:bg-emerald-700">Indienen</button></div>`);
                            html.push(`</form>`);
                            this.container.innerHTML = html.join('');
                            const form = this.container.querySelector('form');
                            // Selection UX voor multi
                            this.container.querySelectorAll('.quiz-choice').forEach(el => {
                                const input = el.querySelector('input');
                                el.addEventListener('click', (ev) => {
                                    if (input.type === 'checkbox') {
                                        // toggle visueel, laat browser checkbox state afhandelen
                                        setTimeout(() => {
                                            el.classList.toggle('selected', input.checked);
                                        }, 0);
                                    } else {
                                        // radio: maak andere labels in dezelfde groep los
                                        const name = input.getAttribute('name');
                                        this.container.querySelectorAll(`input[name="${name}"]`).forEach(r => r.closest('.quiz-choice').classList.remove('selected'));
                                        setTimeout(() => {
                                            el.classList.add('selected');
                                        }, 0);
                                    }
                                });
                            });
                            form.addEventListener('submit', (e) => {
                                e.preventDefault();
                                this.evaluate();
                            });
                        }
                        evaluate() {
                            let score = 0;
                            const details = [];
                            this.questions.forEach(q => {
                                let userAnswer = null;
                                let correctAnswer = null;
                                let isCorrect = false;
                                if (q.type === 'text') {
                                    const val = (this.container.querySelector(`input[name="${q.id}"]`)?.value || '').trim();
                                    userAnswer = val;
                                    isCorrect = !!(new RegExp(q.answerPattern, 'i').test(val));
                                } else if (q.type === 'single') {
                                    const sel = this.container.querySelector(`input[name="${q.id}"]:checked`);
                                    userAnswer = sel ? sel.value : null;
                                    const correct = q.choices?.find(c => c.correct);
                                    correctAnswer = correct ? correct.id : null;
                                    isCorrect = userAnswer === correctAnswer;
                                } else if (q.type === 'multi') {
                                    const selected = [...this.container.querySelectorAll(`input[type="checkbox"][value][name="${q.id}"]`)].filter(x => x.checked).map(x => x.value);
                                    // Als we checkboxen zonder name-groep hebben, selecteer alle checkboxes binnen q-card
                                    if (selected.length === 0) {
                                        const within = [...this.container.querySelectorAll(`.quiz-card .quiz-body input[type="checkbox"]`)].filter(inp => inp.closest('.quiz-card').querySelector(`input[name="${q.id}"]`) === null);
                                    }
                                    userAnswer = [...this.container.querySelectorAll(`.quiz-card .quiz-body input[type="checkbox"]`)].filter(inp => inp.closest('.quiz-card') && inp.closest('.quiz-card').innerText.includes(q.prompt) && inp.checked).map(inp => inp.value);
                                    if (Array.isArray(userAnswer) && userAnswer.length === 0) {
                                        // fallback: alle checkboxes met value die binnen deze vraag staan
                                        userAnswer = [...this.container.querySelectorAll(`label.quiz-choice input[type="checkbox"]`)].filter(inp => inp.closest('.quiz-card').querySelector('.font-semibold').innerText === q.prompt && inp.checked).map(inp => inp.value);
                                    }
                                    const correctIds = (q.choices || []).filter(c => c.correct).map(c => c.id).sort().join(',');
                                    const chosen = (userAnswer || []).slice().sort().join(',');
                                    isCorrect = correctIds === chosen;
                                    correctAnswer = (q.choices || []).filter(c => c.correct).map(c => c.id);
                                }
                                if (isCorrect) score++;
                                details.push({ q, userAnswer, correctAnswer, isCorrect });
                            });
                            const total = this.questions.length;
                            const summary = { score, total, questionIds: this.questions.map(q => q.id), ts: Date.now() };
                            localStorage.setItem(`quiz:last:${this.chapterId}`, JSON.stringify(summary));
                            localStorage.setItem(`quiz:${this.chapterId}:${summary.ts}`, JSON.stringify({ ...summary, details }));
                            if (typeof this.onFinish === 'function') this.onFinish(this.chapterId, summary);
                            this.renderResults(summary, details);
                        }
                        renderResults(summary, details) {
                            const pct = Math.round(summary.score / summary.total * 100);
                            const rows = details.map(d => {
                                const q = d.q;
                                const your = Array.isArray(d.userAnswer) ? d.userAnswer.join(', ') : (d.userAnswer ?? '—');
                                let correct = '';
                                if (q.type === 'text') correct = q.answerPattern;
                                else if (q.type === 'single') correct = (q.choices || []).find(c => c.correct)?.id || '';
                                else if (q.type === 'multi') correct = (q.choices || []).filter(c => c.correct).map(c => c.id).join(', ');
                                const ref = q.reference ? `<a href="#${q.reference.anchorId}" class="text-teal-700 underline">Zie tekst</a>` : '';
                                const excerpt = q.reference?.excerpt ? `<blockquote class="mt-2 text-sm text-slate-600 border-l-4 border-slate-300 pl-3">${q.reference.excerpt}</blockquote>` : '';
                                return `<div class="p-3 border rounded ${d.isCorrect ? 'bg-emerald-50 border-emerald-200' : 'bg-rose-50 border-rose-200'}">
                                    <div class="font-semibold mb-1">${q.prompt}</div>
                                    <div class="text-sm"><span class="font-medium">Jouw antwoord:</span> ${your}</div>
                                    <div class="text-sm"><span class="font-medium">Correct:</span> ${correct}</div>
                                    <div class="quiz-explanation mt-2">${q.explanation || ''} ${ref}${excerpt}</div>
                                </div>`;
                            }).join('');
                            this.container.innerHTML = `<div class="quiz-card">
                                <div class="quiz-header"><div class="quiz-title">Resultaat</div><div class="text-sm">${summary.score}/${summary.total} (${pct}%)</div></div>
                                <div class="quiz-body">
                                  <div class="quiz-progress mb-4"><div style="width:${pct}%"></div></div>
                                  <div class="space-y-3">${rows}</div>
                                  <div class="mt-4 flex gap-2">
                                    <button class="again px-3 py-2 bg-slate-800 text-white rounded hover:bg-slate-900">Nieuwe set</button>
                                  </div>
                                </div>
                              </div>`;
                            const again = this.container.querySelector('.again');
                            if (again) {
                                again.addEventListener('click', async () => {
                                    const bank = await loadQuestionBank();
                                    const pool = bank.questions.filter(q => q.chapterId === this.chapterId);
                                    const avoid = summary.questionIds || [];
                                    const picked = pickRandomQuestions([...pool], 10, avoid);
                                    new DynamicQuizEngine(this.chapterId, picked, this.container, this.onFinish);
                                });
                            }
                        }
                    }

                    function updateSidebarBadge(sectionId, summary) {
                        const link = document.querySelector(`nav a[data-target='${sectionId}']`);
                        if (!link) return;
                        let badge = link.querySelector('.quiz-badge');
                        const label = `${summary.score}/${summary.total}`;
                        if (!badge) {
                            badge = document.createElement('span');
                            badge.className = 'quiz-badge';
                            badge.textContent = label;
                            link.appendChild(badge);
                        } else {
                            badge.textContent = label;
                        }
                    }

                    // initial load: show stored badges
                    (function seedBadgesFromStorage() {
                        QUIZZES.forEach(cfg => {
                            const raw = localStorage.getItem(`quiz:${cfg.sectionId}`);
                            if (raw) updateSidebarBadge(cfg.sectionId, JSON.parse(raw));
                        });
                    })();

                    renderQuizBlocks();

                    // CTA highlight wanneer sectie-einde in beeld komt
                    const ctaObserver = new IntersectionObserver(entries => {
                        entries.forEach(entry => {
                            if (entry.isIntersecting) {
                                const host = entry.target.querySelector('.dyn-quiz-host');
                                if (host) host.classList.add('ring-2', 'ring-emerald-300');
                            }
                        });
                    }, { root: null, threshold: 0.1 });
                    ['deel-1', 'deel-2', 'deel-3', 'deel-4', 'deel-5', 'deel-6'].forEach(id => {
                        const sec = document.getElementById(id);
                        if (sec) ctaObserver.observe(sec);
                    });

                    const observerOptions = {
                        root: null,
                        rootMargin: '-30% 0px -70% 0px',
                        threshold: 0
                    };

                    const observer = new IntersectionObserver(entries => {
                        entries.forEach(entry => {
                            if (entry.isIntersecting) {
                                updateActiveLink(entry.target.id);
                            }
                        });
                    }, observerOptions);

                    sections.forEach(section => {
                        observer.observe(section);
                    });

                    if (sections.length > 0) {
                        updateActiveLink(sections[0].id);
                    }

                    // --- Interactie 1: Naam Checker (Uitgebreid) ---
                    const nameInput = document.getElementById('name-checker-input');
                    const nameFeedback = document.getElementById('name-checker-feedback');
                    const reservedWords = ['select', 'insert', 'update', 'delete', 'create', 'drop', 'alter', 'table', 'database', 'index', 'view', 'where', 'from', 'join', 'order', 'group', 'by', 'having', 'distinct', 'null', 'not', 'and', 'or', 'as', 'is', 'in', 'like', 'between', 'exists'];

                    if (nameInput && nameFeedback) {
                        nameInput.addEventListener('input', () => {
                            const value = nameInput.value;
                            if (value.length === 0) {
                                nameFeedback.innerHTML = "";
                                nameFeedback.className = "mt-3 p-3 rounded-md text-sm";
                                return;
                            }

                            // Check voor reserved words
                            if (reservedWords.includes(value.toLowerCase())) {
                                nameFeedback.innerHTML = `<strong>Fout:</strong> "${value}" is een gereserveerd SQL woord. Gebruik een andere naam (bv. "${value}Value" of "${value}_kolom").`;
                                nameFeedback.className = "mt-3 p-3 rounded-md text-sm feedback-incorrect";
                                return;
                            }

                            // Check voor lengte
                            if (value.length > 64) {
                                nameFeedback.innerHTML = `<strong>Waarschuwing:</strong> Deze naam is erg lang (${value.length} karakters). Probeer kortere namen te gebruiken (maximaal 64 karakters).`;
                                nameFeedback.className = "mt-3 p-3 rounded-md text-sm";
                                nameFeedback.style.color = '#b45309';
                                nameFeedback.style.backgroundColor = '#fffbeb';
                                nameFeedback.style.borderLeft = '4px solid #f59e0b';
                                return;
                            }

                            // Check voor spaties
                            if (value.includes(' ')) {
                                nameFeedback.innerHTML = "<strong>Fout:</strong> Attribuutnamen mogen geen spaties bevatten. Gebruik `camelCase` (bv. `voornaamKlant`) of `snake_case` (bv. `voornaam_klant`).";
                                nameFeedback.className = "mt-3 p-3 rounded-md text-sm feedback-incorrect";
                                return;
                            }

                            // Check voor speciale tekens (behalve underscore)
                            if (value.match(/[^a-zA-Z0-9_]/)) {
                                nameFeedback.innerHTML = "<strong>Fout:</strong> Attribuutnamen mogen alleen letters, cijfers en underscores bevatten. Speciale tekens zoals '-', '.', '@' zijn niet toegestaan.";
                                nameFeedback.className = "mt-3 p-3 rounded-md text-sm feedback-incorrect";
                                return;
                            }

                            // Check voor cijfers aan het begin
                            if (value.match(/^[0-9]/)) {
                                nameFeedback.innerHTML = "<strong>Fout:</strong> Attribuutnamen mogen niet beginnen met een cijfer. Begin altijd met een letter.";
                                nameFeedback.className = "mt-3 p-3 rounded-md text-sm feedback-incorrect";
                                return;
                            }

                            // Check voor alleen kleine letters (te lang)
                            if (value.toLowerCase() === value && !value.includes('_') && value.length > 5) {
                                nameFeedback.innerHTML = "<strong>Tip:</strong> Dit is geldig, maar `camelCase` (bv. `klantNummer`) is vaak beter leesbaar dan `klantnummer`.";
                                nameFeedback.className = "mt-3 p-3 rounded-md text-sm";
                                nameFeedback.style.color = '#b45309';
                                nameFeedback.style.backgroundColor = '#fffbeb';
                                nameFeedback.style.borderLeft = '4px solid #f59e0b';
                                return;
                            }

                            // Valid snake_case
                            if (value.match(/^[a-z][a-z0-9_]*$/)) {
                                const examples = value.includes('_')
                                    ? "Goed voorbeeld van `snake_case`!"
                                    : "Dit is ook geldig, maar overweeg `snake_case` voor lange namen.";
                                nameFeedback.innerHTML = `<strong>Perfect!</strong> Dit is geldige \`snake_case\`. ${examples}`;
                                nameFeedback.className = "mt-3 p-3 rounded-md text-sm feedback-correct";
                                return;
                            }

                            // Valid camelCase
                            if (value.match(/^[a-z][a-zA-Z0-9]*$/)) {
                                nameFeedback.innerHTML = "<strong>Perfect!</strong> Dit is geldige `camelCase`. Goede keuze voor leesbaarheid!";
                                nameFeedback.className = "mt-3 p-3 rounded-md text-sm feedback-correct";
                                return;
                            }

                            // Fallback
                            nameFeedback.innerHTML = "<strong>Tip:</strong> Begin met een kleine letter. Gebruik alleen letters, cijfers en underscores. Vermijd speciale tekens.";
                            nameFeedback.className = "mt-3 p-3 rounded-md text-sm feedback-incorrect";
                            nameFeedback.style.color = '#b45309';
                            nameFeedback.style.backgroundColor = '#fffbeb';
                            nameFeedback.style.borderLeft = '4px solid #f59e0b';
                        });
                    }

                    // --- Interactie 2: Model Vergelijker ---
                    const modelBtns = document.querySelectorAll('.model-toggle-btn');
                    const modelContent = document.getElementById('model-comparison-content');
                    const modelData = {
                        conceptueel: {
                            title: 'Conceptueel Model (CDM)',
                            content: '<p class="mb-3"><strong>Doel:</strong> Begrijpen van business-vereisten en communiceren met stakeholders (niet-technisch).</p><p class="mb-3"><strong>Focus:</strong> Entiteiten (bv. Klant, Product) en de relaties daartussen.</p><p class="mb-3"><strong>Details:</strong> Geen attributen, geen sleutels, geen datatypes. M:N relaties zijn toegestaan.</p><div class="mt-4 p-4 bg-emerald-100 rounded-lg"><div class="flex items-center justify-center space-x-4"><div class="border-2 border-emerald-500 rounded-lg p-4 font-medium bg-white">Klant</div><div class="px-3 py-1 bg-emerald-200 rounded-full text-sm font-medium">heeft</div><div class="border-2 border-emerald-500 rounded-lg p-4 font-medium bg-white">Bestelling</div></div></div>'
                        },
                        logisch: {
                            title: 'Logisch Model (LDM)',
                            content: '<p class="mb-3"><strong>Doel:</strong> Een architecturale blauwdruk maken voor de database.</p><p class="mb-3"><strong>Focus:</strong> Alle attributen voor elke entiteit. PK en FK worden gedefinieerd.</p><p class="mb-3"><strong>Details:</strong> Algemene datatypes (int, string, date). M:N relaties MOETEN worden opgelost met associatietabellen.</p><div class="mt-4 p-4 bg-teal-100 rounded-lg"><div class="flex items-center justify-center space-x-4"><div class="border-2 border-teal-500 rounded-lg p-4 bg-white"><strong>Klant</strong><div class="text-sm mt-2"><u>id (PK)</u><br>naam<br>email</div></div><div class="px-3 py-1 bg-teal-200 rounded-full text-sm font-medium">1..N</div><div class="border-2 border-teal-500 rounded-lg p-4 bg-white"><strong>Bestelling</strong><div class="text-sm mt-2"><u>id (PK)</u><br>datum<br><em>klantId (FK)</em></div></div></div></div>'
                        },
                        fysiek: {
                            title: 'Fysiek Model (PDM)',
                            content: '<p class="mb-3"><strong>Doel:</strong> Concrete implementatiegids voor een specifiek RDBMS.</p><p class="mb-3"><strong>Focus:</strong> Specifieke datatypes (VARCHAR(100), INT, DATETIME). Alle constraints (NA/NNA, ON DELETE).</p><p class="mb-3"><strong>Details:</strong> Volledig uitgewerkt met indexen, partities, en andere performance-optimalisaties.</p><div class="mt-4 p-4 bg-slate-100 rounded-lg"><pre class="bg-slate-800 text-slate-200 p-3 rounded text-sm overflow-x-auto"><code>CREATE TABLE Klant (<br>    id INT IDENTITY(1,1) NOT NULL,<br>    naam VARCHAR(100) NOT NULL,<br>    email VARCHAR(150) NOT NULL,<br>    PRIMARY KEY (id),<br>    UNIQUE (email)<br>);</code></pre></div>'
                        },
                        vergelijk: {
                            title: 'Vergelijkingstabel: Conceptueel vs Logisch vs Fysiek',
                            content: `<div class="overflow-x-auto">
                                <table class="w-full border-collapse border border-slate-300 text-sm">
                                    <thead>
                                        <tr class="bg-slate-100">
                                            <th class="border border-slate-300 p-2 text-left">Aspect</th>
                                            <th class="border border-slate-300 p-2 text-center bg-emerald-50">Conceptueel</th>
                                            <th class="border border-slate-300 p-2 text-center bg-teal-50">Logisch</th>
                                            <th class="border border-slate-300 p-2 text-center bg-slate-50">Fysiek</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        <tr>
                                            <td class="border border-slate-300 p-2 font-semibold">Doel</td>
                                            <td class="border border-slate-300 p-2">Business begrip</td>
                                            <td class="border border-slate-300 p-2">Database architectuur</td>
                                            <td class="border border-slate-300 p-2">Implementatie</td>
                                        </tr>
                                        <tr class="bg-slate-50">
                                            <td class="border border-slate-300 p-2 font-semibold">Entiteiten</td>
                                            <td class="border border-slate-300 p-2">✓ Alleen namen</td>
                                            <td class="border border-slate-300 p-2">✓ Met attributen</td>
                                            <td class="border border-slate-300 p-2">✓ Met datatypes</td>
                                        </tr>
                                        <tr>
                                            <td class="border border-slate-300 p-2 font-semibold">Attributen</td>
                                            <td class="border border-slate-300 p-2">✗ Geen</td>
                                            <td class="border border-slate-300 p-2">✓ Algemeen (int, string)</td>
                                            <td class="border border-slate-300 p-2">✓ Specifiek (VARCHAR(100))</td>
                                        </tr>
                                        <tr class="bg-slate-50">
                                            <td class="border border-slate-300 p-2 font-semibold">Sleutels</td>
                                            <td class="border border-slate-300 p-2">✗ Geen</td>
                                            <td class="border border-slate-300 p-2">✓ PK, FK</td>
                                            <td class="border border-slate-300 p-2">✓ PK, FK, AK, constraints</td>
                                        </tr>
                                        <tr>
                                            <td class="border border-slate-300 p-2 font-semibold">M:N Relaties</td>
                                            <td class="border border-slate-300 p-2">✓ Toegestaan</td>
                                            <td class="border border-slate-300 p-2">✗ Moet opgelost worden</td>
                                            <td class="border border-slate-300 p-2">✗ Via associatietabel</td>
                                        </tr>
                                        <tr class="bg-slate-50">
                                            <td class="border border-slate-300 p-2 font-semibold">Constraints</td>
                                            <td class="border border-slate-300 p-2">✗ Geen</td>
                                            <td class="border border-slate-300 p-2">✗ Geen</td>
                                            <td class="border border-slate-300 p-2">✓ NA/NNA, ON DELETE, CHECK</td>
                                        </tr>
                                        <tr>
                                            <td class="border border-slate-300 p-2 font-semibold">DBMS Specifiek</td>
                                            <td class="border border-slate-300 p-2">✗ Nee</td>
                                            <td class="border border-slate-300 p-2">✗ Nee</td>
                                            <td class="border border-slate-300 p-2">✓ Ja (SQL Server, MySQL, etc.)</td>
                                        </tr>
                                    </tbody>
                                </table>
                            </div>`
                        }
                    };

                    modelBtns.forEach(btn => {
                        btn.addEventListener('click', () => {
                            modelBtns.forEach(b => b.classList.remove('ring-4', 'ring-offset-2'));
                            btn.classList.add('ring-4', 'ring-offset-2');

                            const modelType = btn.id.replace('model-btn-', '');
                            if (modelData[modelType] && modelContent) {
                                modelContent.innerHTML = `<h4 class="font-bold text-lg mb-3">${modelData[modelType].title}</h4>${modelData[modelType].content}`;
                            }
                        });
                    });

                    // --- Interactie 3: Sleutel Hiërarchie ---
                    const keyHierarchySteps = document.querySelectorAll('.key-hierarchy-step');
                    keyHierarchySteps.forEach(step => {
                        step.addEventListener('click', () => {
                            const detail = step.querySelector('.key-hierarchy-detail');
                            if (detail) {
                                detail.classList.toggle('hidden');
                            }
                        });
                    });

                    // --- Interactie 4: Relatie Oplosser ---
                    const scenarioSelect = document.getElementById('scenario-select');
                    const problemText = document.getElementById('problem-text');
                    const problemDiagram = document.getElementById('problem-diagram');
                    const solveButton = document.getElementById('solve-button');
                    const solutionContainer = document.getElementById('solution-container');
                    const solutionRule = document.getElementById('solution-rule');
                    const solutionDiagram = document.getElementById('solution-diagram');

                    const scenarios = {
                        '1n': {
                            text: "Een Klant kan veel Bestellingen plaatsen, maar een Bestelling hoort bij exact één Klant.",
                            problem: `<div class="flex items-center justify-center space-x-4">
                                <div class="entity-box">Klant</div>
                                <div class="rel-line">--- 1..N ---</div>
                                <div class="entity-box">Bestelling</div>
                              </div>`,
                            rule: "<strong>REGEL (1-op-N):</strong> De Primaire Sleutel (PK) van de '1'-kant (Klant) wordt een Vreemde Sleutel (FK) aan de 'N'-kant (Bestelling).",
                            solution: `<div class="flex items-center justify-center space-x-4">
                                <div class="entity-box">
                                    <strong>Klant</strong>
                                    <div class="text-sm font-normal text-left mt-2 pl-4"><u>id (PK)</u><br>naam</div>
                                </div>
                                <div class="rel-line">--- 1..N ---</div>
                                <div class="entity-box">
                                    <strong>Bestelling</strong>
                                    <div class="text-sm font-normal text-left mt-2 pl-4"><u>id (PK)</u><br>datum<br><em>klantId (FK)</em></div>
                                </div>
                               </div>`
                        },
                        'nm': {
                            text: "Een Student kan veel Cursussen volgen, en een Cursus wordt door veel Studenten gevolgd.",
                            problem: `<div class="flex items-center justify-center space-x-4">
                                <div class="entity-box">Student</div>
                                <div class="rel-line">--- N..M ---</div>
                                <div class="entity-box">Cursus</div>
                              </div>`,
                            rule: "<strong>REGEL (N-op-M):</strong> Dit kan niet direct! We creëren een TUSSENTABEL (bv. 'Inschrijving'). Deze tabel krijgt de FK's van beide kanten. De N-M relatie wordt vervangen door twee 1-N relaties.",
                            solution: `<div class="flex flex-col md:flex-row items-center justify-center space-y-4 md:space-y-0 md:space-x-4">
                                <div class="entity-box">
                                    <strong>Student</strong>
                                    <div class="text-sm font-normal text-left mt-2 pl-4"><u>id (PK)</u></div>
                                </div>
                                <div class="rel-line">(1) -- (N)</div>
                                <div class="entity-box bg-emerald-100 border-emerald-500">
                                    <strong>Inschrijving</strong>
                                    <div class="text-sm font-normal text-left mt-2 pl-4"><u><em>studentId (PK, FK)</em></u><br><u><em>cursusId (PK, FK)</em></u><br>resultaat</div>
                                </div>
                                <div class="rel-line">(N) -- (1)</div>
                                <div class="entity-box">
                                    <strong>Cursus</strong>
                                    <div class="text-sm font-normal text-left mt-2 pl-4"><u>id (PK)</u></div>
                                </div>
                               </div>`
                        },
                        'multi': {
                            text: "Een Klant kan meerdere Telefoonnummers hebben.",
                            problem: `<div class="flex items-center justify-center space-x-4">
                                <div class="entity-box">
                                    <strong>Klant</strong>
                                    <div class="text-sm font-normal text-left mt-2 pl-4"><u>id (PK)</u><br>naam<br>telefoonnummers (?)</div>
                                </div>
                              </div>
                              <p class="text-center mt-2 text-red-600">Probleem: 'telefoonnummers' is een multi-valued attribuut.</p>`,
                            rule: "<strong>REGEL (Multi-valued Attribuut):</strong> We maken een aparte, 'karakteristieke' entiteit (bv. 'KlantTelefoon') die alle telefoonnummers opslaat met een FK naar de Klant. Dit wordt een simpele 1-op-N relatie.",
                            solution: `<div class="flex items-center justify-center space-x-4">
                                <div class="entity-box">
                                    <strong>Klant</strong>
                                    <div class="text-sm font-normal text-left mt-2 pl-4"><u>id (PK)</u><br>naam</div>
                                </div>
                                <div class="rel-line">--- 1..N ---</div>
                                <div class="entity-box bg-emerald-100 border-emerald-500">
                                    <strong>KlantTelefoon</strong>
                                    <div class="text-sm font-normal text-left mt-2 pl-4"><u>id (PK)</u><br>telefoonnummer<br>type<br><em>klantId (FK)</em></div>
                                </div>
                               </div>`
                        },
                        'recursive': {
                            text: "Een Werknemer kan een Manager hebben, en een Manager is ook een Werknemer.",
                            problem: `<div class="flex items-center justify-center space-x-4">
                                <div class="entity-box">
                                    <strong>Werknemer</strong>
                                    <div class="text-sm font-normal text-left mt-2 pl-4"><u>id (PK)</u><br>naam<br>managerId (?)</div>
                                </div>
                              </div>
                              <p class="text-center mt-2 text-red-600">Probleem: Hoe modelleer je een relatie waarbij een entiteit naar zichzelf verwijst?</p>`,
                            rule: "<strong>REGEL (Recursieve Relatie):</strong> Voeg een Foreign Key-kolom toe aan de tabel die verwijst naar de Primaire Sleutel van dezelfde tabel. Deze FK-kolom moet NULL toegestaan (NA) zijn voor de top van de hiërarchie.",
                            solution: `<div class="flex items-center justify-center space-x-4">
                                <div class="entity-box">
                                    <strong>Werknemer</strong>
                                    <div class="text-sm font-normal text-left mt-2 pl-4"><u>id (PK)</u><br>naam<br><em>managerId (FK, NA)</em></div>
                                </div>
                                <div class="rel-line">--- zelfreferentie ---</div>
                                <div class="entity-box">
                                    <strong>Werknemer</strong>
                                    <div class="text-sm font-normal text-left mt-2 pl-4"><u>id (PK)</u><br>naam<br><em>managerId (FK, NA)</em></div>
                                </div>
                               </div>
                               <p class="text-center mt-4 text-sm text-slate-600">De FK verwijst naar dezelfde tabel. managerId = NULL betekent top van hiërarchie.</p>`
                        },
                        'ternary': {
                            text: "Een Gebruiker past een Tag toe op een Boek. Dit is een ternaire relatie waarbij drie entiteiten tegelijk betrokken zijn.",
                            problem: `<div class="flex flex-col items-center justify-center space-y-4">
                                <div class="flex items-center justify-center space-x-4">
                                    <div class="entity-box">Gebruiker</div>
                                    <div class="rel-line">---</div>
                                    <div class="entity-box">Tag</div>
                                    <div class="rel-line">---</div>
                                    <div class="entity-box">Boek</div>
                                </div>
                                <p class="text-center mt-2 text-red-600">Probleem: Dit is een ternaire relatie. Je kunt dit niet oplossen met drie losse binaire relaties zonder context te verliezen.</p>
                              </div>`,
                            rule: "<strong>REGEL (Ternaire Relatie):</strong> Een ternaire relatie vereist een associatie-entiteit die alle drie de Foreign Keys bevat. De PK is een samengestelde sleutel van alle drie de FK's. Dit behoudt de context: 'Welke gebruiker heeft welke tag toegepast op welk boek?'",
                            solution: `<div class="flex flex-col items-center justify-center space-y-4">
                                <div class="flex flex-col md:flex-row items-center justify-center space-y-4 md:space-y-0 md:space-x-4">
                                    <div class="entity-box">
                                        <strong>Gebruiker</strong>
                                        <div class="text-sm font-normal text-left mt-2 pl-4"><u>id (PK)</u><br>naam</div>
                                    </div>
                                    <div class="rel-line">(1) -- (N)</div>
                                    <div class="entity-box bg-emerald-100 border-emerald-500">
                                        <strong>GebruikerTagBoek</strong>
                                        <div class="text-sm font-normal text-left mt-2 pl-4"><u><em>gebruikerId (PK, FK)</em></u><br><u><em>tagId (PK, FK)</em></u><br><u><em>boekId (PK, FK)</em></u><br>datum</div>
                                    </div>
                                    <div class="rel-line">(N) -- (1)</div>
                                    <div class="entity-box">
                                        <strong>Tag</strong>
                                        <div class="text-sm font-normal text-left mt-2 pl-4"><u>id (PK)</u><br>naam</div>
                                    </div>
                                </div>
                                <div class="flex items-center justify-center space-x-4 mt-4">
                                    <div class="entity-box bg-emerald-100 border-emerald-500">
                                        <strong>GebruikerTagBoek</strong>
                                    </div>
                                    <div class="rel-line">(N) -- (1)</div>
                                    <div class="entity-box">
                                        <strong>Boek</strong>
                                        <div class="text-sm font-normal text-left mt-2 pl-4"><u>id (PK)</u><br>titel</div>
                                    </div>
                                </div>
                                <p class="text-center mt-4 text-sm text-slate-600">De associatie-entiteit bevat alle drie de FK's als samengestelde PK. Dit behoudt de volledige context van de relatie.</p>
                               </div>`
                        },
                        'identifying': {
                            text: "Verschil tussen identificerende en niet-identificerende relaties: wanneer heeft een 'kind' entiteit een eigen PK vs wanneer maakt de FK deel uit van de PK?",
                            problem: `<div class="space-y-4">
                                <div class="p-4 bg-yellow-50 border border-yellow-200 rounded">
                                    <p class="font-semibold mb-2">Niet-Identificerende Relatie (Meest Voorkomend):</p>
                                    <div class="flex items-center justify-center space-x-4">
                                        <div class="entity-box">
                                            <strong>Klant</strong>
                                            <div class="text-sm font-normal text-left mt-2 pl-4"><u>id (PK)</u></div>
                                        </div>
                                        <div class="rel-line">--- 1..N ---</div>
                                        <div class="entity-box">
                                            <strong>Bestelling</strong>
                                            <div class="text-sm font-normal text-left mt-2 pl-4"><u>id (PK)</u><br><em>klantId (FK)</em></div>
                                        </div>
                                    </div>
                                    <p class="text-sm mt-2">Bestelling heeft eigen PK. klantId is alleen FK.</p>
                                </div>
                                <div class="p-4 bg-blue-50 border border-blue-200 rounded">
                                    <p class="font-semibold mb-2">Identificerende Relatie (Zeldzaam):</p>
                                    <div class="flex items-center justify-center space-x-4">
                                        <div class="entity-box">
                                            <strong>Project</strong>
                                            <div class="text-sm font-normal text-left mt-2 pl-4"><u>id (PK)</u></div>
                                        </div>
                                        <div class="rel-line">--- 1..N ---</div>
                                        <div class="entity-box">
                                            <strong>Taak</strong>
                                            <div class="text-sm font-normal text-left mt-2 pl-4"><u><em>projectId (PK, FK)</em></u><br><u>taakNummer (PK)</u></div>
                                        </div>
                                    </div>
                                    <p class="text-sm mt-2">Taak heeft geen eigen PK. projectId maakt deel uit van de PK.</p>
                                </div>
                              </div>`,
                            rule: "<strong>REGEL (Identificerende vs Niet-Identificerende):</strong><br><br><strong>Niet-Identificerende:</strong> Het 'kind' heeft een eigen PK (meestal surrogaat id). De FK is alleen een referentie. Dit is de standaard.<br><br><strong>Identificerende:</strong> Het 'kind' heeft geen eigen bestaansrecht zonder de 'ouder'. De FK maakt deel uit van de PK. Dit is zeldzaam en wordt gebruikt wanneer het kind alleen betekenis heeft binnen de context van de ouder.",
                            solution: `<div class="space-y-6">
                                <div class="p-4 bg-emerald-50 border border-emerald-300 rounded">
                                    <h5 class="font-bold mb-2">Niet-Identificerende Relatie (Standaard):</h5>
                                    <div class="flex items-center justify-center space-x-4">
                                        <div class="entity-box">
                                            <strong>Klant</strong>
                                            <div class="text-sm font-normal text-left mt-2 pl-4"><u>id (PK)</u><br>naam</div>
                                        </div>
                                        <div class="rel-line">--- 1..N ---</div>
                                        <div class="entity-box">
                                            <strong>Bestelling</strong>
                                            <div class="text-sm font-normal text-left mt-2 pl-4"><u>id (PK)</u><br>datum<br><em>klantId (FK)</em></div>
                                        </div>
                                    </div>
                                    <p class="text-sm mt-2 text-slate-600">Bestelling kan onafhankelijk bestaan. De PK is alleen 'id'.</p>
                                </div>
                                <div class="p-4 bg-teal-50 border border-teal-300 rounded">
                                    <h5 class="font-bold mb-2">Identificerende Relatie (Zeldzaam):</h5>
                                    <div class="flex items-center justify-center space-x-4">
                                        <div class="entity-box">
                                            <strong>Project</strong>
                                            <div class="text-sm font-normal text-left mt-2 pl-4"><u>id (PK)</u><br>naam</div>
                                        </div>
                                        <div class="rel-line">--- 1..N ---</div>
                                        <div class="entity-box bg-teal-100 border-teal-500">
                                            <strong>Taak</strong>
                                            <div class="text-sm font-normal text-left mt-2 pl-4"><u><em>projectId (PK, FK)</em></u><br><u>taakNummer (PK)</u><br>beschrijving</div>
                                        </div>
                                    </div>
                                    <p class="text-sm mt-2 text-slate-600">Taak heeft geen betekenis zonder Project. De PK is {projectId, taakNummer}.</p>
                                </div>
                               </div>`
                        },
                        'complex': {
                            text: "Een E-commerce systeem: Klanten plaatsen Bestellingen die Producten bevatten. Producten kunnen in Categorieën zitten. Klanten kunnen Reviews schrijven voor Producten.",
                            problem: `<div class="space-y-3">
                                <div class="flex items-center justify-center space-x-4">
                                    <div class="entity-box">Klant</div>
                                    <div class="rel-line">--- N..M ---</div>
                                    <div class="entity-box">Product</div>
                                </div>
                                <div class="flex items-center justify-center space-x-4">
                                    <div class="entity-box">Product</div>
                                    <div class="rel-line">--- N..M ---</div>
                                    <div class="entity-box">Categorie</div>
                                </div>
                                <div class="flex items-center justify-center space-x-4">
                                    <div class="entity-box">Klant</div>
                                    <div class="rel-line">--- N..M ---</div>
                                    <div class="entity-box">Product</div>
                                </div>
                                <p class="text-center mt-2 text-red-600">Probleem: Meerdere M:N relaties die allemaal opgelost moeten worden!</p>
                              </div>`,
                            rule: "<strong>REGEL (Complex Model):</strong> Bij complexe modellen met meerdere M:N relaties:<br>1. Identificeer alle M:N relaties<br>2. Los elke M:N relatie op met een associatie-entiteit<br>3. Zorg dat associatie-entiteiten duidelijk benoemd zijn<br>4. Controleer dat alle FK's correct geplaatst zijn<br>5. Verifieer dat de volgorde van CREATE statements klopt",
                            solution: `<div class="space-y-4">
                                <div class="p-3 bg-emerald-50 rounded">
                                    <p class="font-semibold text-sm mb-2">Stap 1: Basis entiteiten</p>
                                    <div class="flex flex-wrap items-center justify-center gap-4">
                                        <div class="entity-box text-xs"><strong>Klant</strong><div class="text-xs mt-1"><u>id (PK)</u></div></div>
                                        <div class="entity-box text-xs"><strong>Product</strong><div class="text-xs mt-1"><u>id (PK)</u></div></div>
                                        <div class="entity-box text-xs"><strong>Categorie</strong><div class="text-xs mt-1"><u>id (PK)</u></div></div>
                                    </div>
                                </div>
                                <div class="p-3 bg-teal-50 rounded">
                                    <p class="font-semibold text-sm mb-2">Stap 2: 1:N relaties</p>
                                    <div class="flex items-center justify-center space-x-4">
                                        <div class="entity-box text-xs"><strong>Klant</strong></div>
                                        <div class="rel-line text-xs">--- 1..N ---</div>
                                        <div class="entity-box text-xs"><strong>Bestelling</strong><div class="text-xs mt-1"><u>id (PK)</u><br><em>klantId (FK)</em></div></div>
                                    </div>
                                </div>
                                <div class="p-3 bg-blue-50 rounded">
                                    <p class="font-semibold text-sm mb-2">Stap 3: M:N relaties oplossen</p>
                                    <div class="space-y-3">
                                        <div class="flex items-center justify-center space-x-4">
                                            <div class="entity-box text-xs"><strong>Bestelling</strong></div>
                                            <div class="rel-line text-xs">(1) -- (N)</div>
                                            <div class="entity-box bg-emerald-100 text-xs"><strong>BestellingProduct</strong><div class="text-xs mt-1"><u><em>bestellingId (PK, FK)</em></u><br><u><em>productId (PK, FK)</em></u><br>aantal</div></div>
                                            <div class="rel-line text-xs">(N) -- (1)</div>
                                            <div class="entity-box text-xs"><strong>Product</strong></div>
                                        </div>
                                        <div class="flex items-center justify-center space-x-4">
                                            <div class="entity-box text-xs"><strong>Product</strong></div>
                                            <div class="rel-line text-xs">(1) -- (N)</div>
                                            <div class="entity-box bg-emerald-100 text-xs"><strong>ProductCategorie</strong><div class="text-xs mt-1"><u><em>productId (PK, FK)</em></u><br><u><em>categorieId (PK, FK)</em></u></div></div>
                                            <div class="rel-line text-xs">(N) -- (1)</div>
                                            <div class="entity-box text-xs"><strong>Categorie</strong></div>
                                        </div>
                                        <div class="flex items-center justify-center space-x-4">
                                            <div class="entity-box text-xs"><strong>Klant</strong></div>
                                            <div class="rel-line text-xs">(1) -- (N)</div>
                                            <div class="entity-box bg-emerald-100 text-xs"><strong>Review</strong><div class="text-xs mt-1"><u>id (PK)</u><br><em>klantId (FK)</em><br><em>productId (FK)</em><br>score</div></div>
                                            <div class="rel-line text-xs">(N) -- (1)</div>
                                            <div class="entity-box text-xs"><strong>Product</strong></div>
                                        </div>
                                    </div>
                                </div>
                                <p class="text-center mt-4 text-sm text-slate-600">Elke M:N relatie is opgelost met een associatie-entiteit. Review is eigenlijk een 1:N relatie (één klant kan meerdere reviews schrijven), maar heeft wel een FK naar Product.</p>
                               </div>`
                        }
                    };

                    if (scenarioSelect) {
                        scenarioSelect.addEventListener('change', () => {
                            const scenario = scenarioSelect.value;
                            if (scenarios[scenario]) {
                                if (problemText) problemText.textContent = scenarios[scenario].text;
                                if (problemDiagram) problemDiagram.innerHTML = scenarios[scenario].problem;
                                if (solutionRule) solutionRule.innerHTML = scenarios[scenario].rule;
                                if (solutionDiagram) solutionDiagram.innerHTML = scenarios[scenario].solution;

                                if (solveButton) {
                                    solveButton.style.display = 'block';
                                    solveButton.classList.remove('hidden');
                                }
                                if (solutionContainer) solutionContainer.style.display = 'none';
                            }
                        });

                        if (solveButton) {
                            solveButton.addEventListener('click', () => {
                                if (solutionContainer) solutionContainer.style.display = 'block';
                            });
                        }
                    }

                    // --- Interactie 5: Datatype Kiezer ---
                    const quizQuestion = document.getElementById('quiz-question');
                    const quizChoices = document.getElementById('quiz-choices');
                    const quizFeedback = document.getElementById('quiz-feedback');

                    const quizData = [
                        { attr: 'Telefoonnummer', correct: 'string', rule: "<strong>Correct!</strong> Een telefoonnummer (bv. '+32 477...') is tekst. Je gaat er nooit mee rekenen." },
                        { attr: 'Postcode', correct: 'string', rule: "<strong>Correct!</strong> Een postcode (bv. '2000' of '1000AB') is tekst. Je telt postcodes niet op." },
                        { attr: 'Salaris', correct: 'number', rule: "<strong>Correct!</strong> Met een salaris (bv. 2500.50) wil je wiskundige berekeningen doen (optellen, gemiddelde)." },
                        { attr: 'Huisnummer', correct: 'string', rule: "<strong>Correct!</strong> Een huisnummer kan '10A' of '22bis' zijn. Dit is tekst, geen getal." },
                        { attr: 'Prijs', correct: 'number', rule: "<strong>Correct!</strong> Met een prijs wil je rekenen (bv. BTW berekenen, totaalprijs)." },
                        { attr: 'Klantnummer', correct: 'string', rule: "<strong>Correct!</strong> Een klantnummer (bv. 'KL005') is een identificator, geen getal om mee te rekenen." }
                    ];
                    let currentQuestionIndex = 0;

                    function loadQuizQuestion() {
                        if (currentQuestionIndex >= quizData.length) {
                            currentQuestionIndex = 0;
                        }
                        const q = quizData[currentQuestionIndex];
                        if (quizQuestion) quizQuestion.textContent = `Welk datatype kies je voor het attribuut: "${q.attr}"?`;
                        if (quizFeedback) {
                            quizFeedback.style.display = 'none';
                            quizFeedback.className = "mt-4 p-3 rounded-md text-sm";
                        }
                    }

                    if (quizChoices) {
                        quizChoices.addEventListener('click', (e) => {
                            if (e.target.tagName === 'BUTTON') {
                                const choice = e.target.dataset.choice;
                                const q = quizData[currentQuestionIndex];

                                if (quizFeedback) {
                                    if (choice === q.correct) {
                                        quizFeedback.innerHTML = q.rule;
                                        quizFeedback.className = "mt-4 p-3 rounded-md text-sm feedback-correct";
                                    } else {
                                        const wrongRule = (q.correct === 'string')
                                            ? "<strong>Fout.</strong> Vraag jezelf af: 'Ga ik hiermee rekenen?'. Zo nee, dan is het bijna altijd 'String'."
                                            : "<strong>Fout.</strong> Vraag jezelf af: 'Ga ik hiermee rekenen?'. Zo ja, dan moet het 'Number' zijn.";
                                        quizFeedback.innerHTML = wrongRule;
                                        quizFeedback.className = "mt-4 p-3 rounded-md text-sm feedback-incorrect";
                                    }
                                    quizFeedback.style.display = 'block';
                                }

                                currentQuestionIndex++;
                                setTimeout(loadQuizQuestion, 2500);
                            }
                        });
                        loadQuizQuestion();
                    }

                    // --- Interactie 6: SQL Kijker ---
                    const diagramKlant = document.getElementById('sql-diagram-klant');
                    const diagramBestelling = document.getElementById('sql-diagram-bestelling');
                    const sqlCodeElement = document.getElementById('sql-code-snippet');

                    const sqlData = {
                        klant: `CREATE TABLE Klant (
    id INT IDENTITY(1,1) NOT NULL,
    naam NVARCHAR(100) NOT NULL,
    email NVARCHAR(100) NOT NULL,

    CONSTRAINT PK_Klant PRIMARY KEY (id),
    CONSTRAINT AK_Klant_Email UNIQUE (email)
);`,
                        bestelling: `CREATE TABLE Bestelling (
    id INT IDENTITY(1,1) NOT NULL,
    orderdatum DATE NOT NULL,
    klantId INT NOT NULL,

    CONSTRAINT PK_Bestelling PRIMARY KEY (id),
    CONSTRAINT FK_Bestelling_Klant 
        FOREIGN KEY (klantId) 
        REFERENCES Klant(id)
        ON DELETE RESTRICT
);`,
                        default: `-- Klik op een entiteit (links)
-- om de SQL code te zien.`
                    };

                    function updateSqlView(type) {
                        if (sqlCodeElement) sqlCodeElement.textContent = sqlData[type];
                        if (diagramKlant) diagramKlant.classList.toggle('active-sql', type === 'klant');
                        if (diagramBestelling) diagramBestelling.classList.toggle('active-sql', type === 'bestelling');
                    }

                    if (diagramKlant) {
                        diagramKlant.addEventListener('click', () => updateSqlView('klant'));
                    }
                    if (diagramBestelling) {
                        diagramBestelling.addEventListener('click', () => updateSqlView('bestelling'));
                    }

                    // --- Interactie 7: Constraint Builder ---
                    const constraintTableName = document.getElementById('constraint-table-name');
                    const constraintColumnName = document.getElementById('constraint-column-name');
                    const constraintType = document.getElementById('constraint-type');
                    const constraintValue = document.getElementById('constraint-value');
                    const generateConstraintBtn = document.getElementById('generate-constraint-btn');
                    const constraintSqlOutput = document.getElementById('constraint-sql-output');
                    const constraintSqlCode = document.getElementById('constraint-sql-code');
                    const copyConstraintSql = document.getElementById('copy-constraint-sql');

                    if (generateConstraintBtn && constraintSqlOutput && constraintSqlCode) {
                        generateConstraintBtn.addEventListener('click', () => {
                            const tableName = constraintTableName ? constraintTableName.value : 'Klant';
                            const columnName = constraintColumnName ? constraintColumnName.value : 'email';
                            const type = constraintType ? constraintType.value : 'unique';
                            const value = constraintValue ? constraintValue.value : '';

                            let sql = '';
                            if (type === 'unique') {
                                sql = `CONSTRAINT AK_${tableName}_${columnName} UNIQUE (${columnName})`;
                            } else if (type === 'check') {
                                sql = `CONSTRAINT CK_${tableName}_${columnName} CHECK (${value || `${columnName} > 0`})`;
                            } else if (type === 'default') {
                                sql = `${columnName} ${value ? `DEFAULT ${value}` : "DEFAULT 'In behandeling'"}`;
                            }

                            constraintSqlCode.textContent = sql;
                            constraintSqlOutput.classList.remove('hidden');
                        });
                    }

                    if (copyConstraintSql && constraintSqlCode) {
                        copyConstraintSql.addEventListener('click', () => {
                            navigator.clipboard.writeText(constraintSqlCode.textContent).then(() => {
                                copyConstraintSql.textContent = 'Gekopieerd!';
                                setTimeout(() => {
                                    copyConstraintSql.textContent = 'Kopieer';
                                }, 2000);
                            });
                        });
                    }

                    // --- Interactie 8: SQL Volgorde Simulator ---
                    const sqlOrderModeCreate = document.getElementById('sql-order-mode-create');
                    const sqlOrderModeDrop = document.getElementById('sql-order-mode-drop');
                    const sqlOrderAvailable = document.getElementById('sql-order-available');
                    const sqlOrderSequence = document.getElementById('sql-order-sequence');
                    const sqlOrderValidate = document.getElementById('sql-order-validate');
                    const sqlOrderFeedback = document.getElementById('sql-order-feedback');
                    let currentMode = 'create';

                    const correctOrder = {
                        create: ['Klant', 'Categorie', 'Gerecht', 'Bestelling', 'BestellingGerecht', 'Review'],
                        drop: ['Review', 'BestellingGerecht', 'Bestelling', 'Gerecht', 'Categorie', 'Klant']
                    };

                    const tableInfo = {
                        'Klant': { type: 'parent', description: 'Basis entiteit, geen FK\'s' },
                        'Categorie': { type: 'parent', description: 'Basis entiteit, geen FK\'s' },
                        'Gerecht': { type: 'child', description: 'Heeft FK naar Categorie' },
                        'Bestelling': { type: 'child', description: 'Heeft FK naar Klant' },
                        'BestellingGerecht': { type: 'assoc', description: 'Associatietabel, heeft FK\'s naar Bestelling en Gerecht' },
                        'Review': { type: 'child', description: 'Heeft FK\'s naar Klant en Gerecht' }
                    };

                    function resetSqlOrderSimulator() {
                        if (sqlOrderSequence) {
                            sqlOrderSequence.innerHTML = '<p class="text-slate-500 text-sm">Klik op tabellen om ze in volgorde te plaatsen...</p>';
                        }
                        if (sqlOrderAvailable) {
                            const tables = currentMode === 'create'
                                ? ['Klant', 'Categorie', 'Gerecht', 'Bestelling', 'BestellingGerecht', 'Review']
                                : ['Review', 'BestellingGerecht', 'Bestelling', 'Gerecht', 'Categorie', 'Klant'];

                            sqlOrderAvailable.innerHTML = tables.map(table => {
                                const info = tableInfo[table];
                                return `<div class="sql-order-item p-2 mb-2 bg-white border border-slate-300 rounded cursor-pointer hover:bg-emerald-50 transition-colors" data-table="${table}" data-type="${info.type}">
                                    <div class="font-semibold">${table}</div>
                                    <div class="text-xs text-slate-500">${info.type} - ${info.description}</div>
                                </div>`;
                            }).join('');
                        }
                        attachSqlOrderListeners();
                    }

                    function attachSqlOrderListeners() {
                        const items = document.querySelectorAll('.sql-order-item');
                        items.forEach(item => {
                            item.addEventListener('click', () => {
                                const table = item.dataset.table;
                                if (sqlOrderSequence && sqlOrderSequence.querySelector('.text-slate-500')) {
                                    sqlOrderSequence.innerHTML = '';
                                }
                                if (sqlOrderSequence) {
                                    const newItem = item.cloneNode(true);
                                    newItem.classList.add('mb-2');
                                    sqlOrderSequence.appendChild(newItem);
                                }
                                item.remove();
                            });
                        });
                    }

                    if (sqlOrderModeCreate) {
                        sqlOrderModeCreate.addEventListener('click', () => {
                            currentMode = 'create';
                            sqlOrderModeCreate.classList.add('ring-4', 'ring-offset-2');
                            sqlOrderModeDrop.classList.remove('ring-4', 'ring-offset-2');
                            resetSqlOrderSimulator();
                        });
                    }

                    if (sqlOrderModeDrop) {
                        sqlOrderModeDrop.addEventListener('click', () => {
                            currentMode = 'drop';
                            sqlOrderModeDrop.classList.add('ring-4', 'ring-offset-2');
                            sqlOrderModeCreate.classList.remove('ring-4', 'ring-offset-2');
                            resetSqlOrderSimulator();
                        });
                    }

                    if (sqlOrderValidate && sqlOrderSequence && sqlOrderFeedback) {
                        sqlOrderValidate.addEventListener('click', () => {
                            const sequenceItems = sqlOrderSequence.querySelectorAll('.sql-order-item');
                            const userOrder = Array.from(sequenceItems).map(item => item.dataset.table);
                            const correct = correctOrder[currentMode];

                            if (userOrder.length === 0) {
                                sqlOrderFeedback.innerHTML = '<strong>Fout:</strong> Je hebt nog geen tabellen in de volgorde geplaatst. Klik op tabellen om ze toe te voegen.';
                                sqlOrderFeedback.className = "mt-3 p-3 rounded-md text-sm feedback-incorrect";
                                sqlOrderFeedback.classList.remove('hidden');
                                return;
                            }

                            if (userOrder.length !== correct.length) {
                                sqlOrderFeedback.innerHTML = `<strong>Fout:</strong> Je hebt ${userOrder.length} tabel(len), maar er moeten ${correct.length} zijn. Controleer of je alle tabellen hebt gebruikt.`;
                                sqlOrderFeedback.className = "mt-3 p-3 rounded-md text-sm feedback-incorrect";
                                sqlOrderFeedback.classList.remove('hidden');
                                return;
                            }

                            // Gedetailleerde validatie met hints
                            let firstError = -1;
                            let errorHint = '';
                            for (let i = 0; i < userOrder.length; i++) {
                                if (userOrder[i] !== correct[i]) {
                                    firstError = i;
                                    const userTable = userOrder[i];
                                    const correctTable = correct[i];
                                    const userInfo = tableInfo[userTable];
                                    const correctInfo = tableInfo[correctTable];

                                    if (currentMode === 'create') {
                                        if (userInfo.type === 'assoc' && i < 2) {
                                            errorHint = `Associatietabellen (zoals ${userTable}) moeten NA de parent en child tabellen komen.`;
                                        } else if (userInfo.type === 'child' && correctInfo.type === 'parent') {
                                            errorHint = `Child tabellen (zoals ${userTable}) verwijzen naar parent tabellen. Parent tabellen (zoals ${correctTable}) moeten eerst worden aangemaakt.`;
                                        } else {
                                            errorHint = `${correctTable} moet voor ${userTable} komen omdat ${userTable} een FK heeft naar ${correctTable} of een andere afhankelijkheid.`;
                                        }
                                    } else {
                                        if (userInfo.type === 'parent' && correctInfo.type !== 'parent') {
                                            errorHint = `Parent tabellen (zoals ${userTable}) kunnen niet verwijderd worden zolang er nog child tabellen zijn die ernaar verwijzen.`;
                                        } else {
                                            errorHint = `${correctTable} moet voor ${userTable} worden verwijderd vanwege FK-afhankelijkheden.`;
                                        }
                                    }
                                    break;
                                }
                            }

                            const isCorrect = userOrder.every((table, index) => table === correct[index]);
                            if (isCorrect) {
                                sqlOrderFeedback.innerHTML = '<strong>Correct!</strong> De volgorde is perfect. Je hebt alle afhankelijkheden correct geïdentificeerd.';
                                sqlOrderFeedback.className = "mt-3 p-3 rounded-md text-sm feedback-correct";
                            } else {
                                sqlOrderFeedback.innerHTML = `<strong>Fout bij positie ${firstError + 1}:</strong> ${errorHint}<br><br><strong>Correcte volgorde:</strong> ${correct.join(' → ')}`;
                                sqlOrderFeedback.className = "mt-3 p-3 rounded-md text-sm feedback-incorrect";
                            }
                            sqlOrderFeedback.classList.remove('hidden');
                        });
                    }

                    resetSqlOrderSimulator();
                });

                // ========== EXAMENOPDRACHT: ERD BUILDER & VALIDATIE ==========

                // BookNetwork Model Data Structuur (gebaseerd op BookNetwork.drawio)
                const bookNetworkModel = {
                    entities: [
                        {
                            name: "Author",
                            type: "kern",
                            attributes: [
                                { name: "id", type: "int", pk: true, fk: false, ak: false, nullable: false },
                                { name: "firstName", type: "string", pk: false, fk: false, ak: false, nullable: false },
                                { name: "lastName", type: "string", pk: false, fk: false, ak: false, nullable: true },
                                { name: "profileId", type: "int", pk: false, fk: true, ak: false, nullable: true, references: "User.id", onDelete: "DTN" }
                            ]
                        },
                        {
                            name: "Book",
                            type: "kern",
                            attributes: [
                                { name: "id", type: "int", pk: true, fk: false, ak: false, nullable: false },
                                { name: "title", type: "string", pk: false, fk: false, ak: false, nullable: false },
                                { name: "description", type: "string", pk: false, fk: false, ak: false, nullable: false },
                                { name: "isbn", type: "string", pk: false, fk: false, ak: true, nullable: false },
                                { name: "publicationDate", type: "date", pk: false, fk: false, ak: false, nullable: false },
                                { name: "cover", type: "string", pk: false, fk: false, ak: false, nullable: true },
                                { name: "nbPages", type: "int", pk: false, fk: false, ak: false, nullable: true },
                                { name: "publisherId", type: "int", pk: false, fk: true, ak: false, nullable: false, references: "Publisher.id", onDelete: "DTR" }
                            ]
                        },
                        {
                            name: "BookAuthor",
                            type: "associatie",
                            attributes: [
                                { name: "id", type: "int", pk: true, fk: false, ak: false, nullable: false },
                                { name: "authorId", type: "int", pk: false, fk: true, ak: false, nullable: false, references: "Author.id", onDelete: "DTR" },
                                { name: "bookId", type: "int", pk: false, fk: true, ak: false, nullable: false, references: "Book.id", onDelete: "DTR" }
                            ]
                        },
                        {
                            name: "Publisher",
                            type: "kern",
                            attributes: [
                                { name: "id", type: "int", pk: true, fk: false, ak: false, nullable: false },
                                { name: "name", type: "string", pk: false, fk: false, ak: false, nullable: false },
                                { name: "website", type: "string", pk: false, fk: false, ak: false, nullable: true }
                            ]
                        },
                        {
                            name: "User",
                            type: "kern",
                            attributes: [
                                { name: "id", type: "int", pk: true, fk: false, ak: false, nullable: false },
                                { name: "firstName", type: "string", pk: false, fk: false, ak: false, nullable: false },
                                { name: "lastName", type: "string", pk: false, fk: false, ak: false, nullable: true },
                                { name: "birthDate", type: "date", pk: false, fk: false, ak: false, nullable: true },
                                { name: "email", type: "string", pk: false, fk: false, ak: false, nullable: false },
                                { name: "wachtwoord", type: "string", pk: false, fk: false, ak: false, nullable: false },
                                { name: "profilePicture", type: "string", pk: false, fk: false, ak: false, nullable: true },
                                { name: "isLibrarian", type: "boolean", pk: false, fk: false, ak: false, nullable: false },
                                { name: "requestedLibrarian", type: "boolean", pk: false, fk: false, ak: false, nullable: false }
                            ]
                        },
                        {
                            name: "Shelve",
                            type: "karakteristiek",
                            attributes: [
                                { name: "id", type: "int", pk: true, fk: false, ak: false, nullable: false },
                                { name: "name", type: "string", pk: false, fk: false, ak: false, nullable: false },
                                { name: "exclusive", type: "boolean", pk: false, fk: false, ak: false, nullable: false },
                                { name: "userId", type: "int", pk: false, fk: true, ak: false, nullable: false, references: "User.id", onDelete: "DTC" }
                            ]
                        },
                        {
                            name: "Shelved",
                            type: "associatie",
                            attributes: [
                                { name: "id", type: "int", pk: true, fk: false, ak: false, nullable: false },
                                { name: "shelveId", type: "int", pk: false, fk: true, ak: false, nullable: false, references: "Shelve.id", onDelete: "DTC" },
                                { name: "bookId", type: "int", pk: false, fk: true, ak: false, nullable: false, references: "Book.id", onDelete: "DTR" }
                            ]
                        },
                        {
                            name: "Review",
                            type: "karakteristiek",
                            attributes: [
                                { name: "id", type: "int", pk: true, fk: false, ak: false, nullable: false },
                                { name: "stars", type: "int", pk: false, fk: false, ak: false, nullable: false },
                                { name: "text", type: "string", pk: false, fk: false, ak: false, nullable: true },
                                { name: "bookId", type: "int", pk: false, fk: true, ak: false, nullable: false, references: "Book.id", onDelete: "DTR" },
                                { name: "userId", type: "int", pk: false, fk: true, ak: false, nullable: true, references: "User.id", onDelete: "DTN" }
                            ]
                        },
                        {
                            name: "ReadHistory",
                            type: "karakteristiek",
                            attributes: [
                                { name: "id", type: "int", pk: true, fk: false, ak: false, nullable: false },
                                { name: "bookId", type: "int", pk: false, fk: true, ak: false, nullable: false, references: "Book.id", onDelete: "DTR" },
                                { name: "userId", type: "int", pk: false, fk: true, ak: false, nullable: false, references: "User.id", onDelete: "DTC" },
                                { name: "start", type: "datetime", pk: false, fk: false, ak: false, nullable: false },
                                { name: "completed", type: "datetime", pk: false, fk: false, ak: false, nullable: true }
                            ]
                        }
                    ],
                    relationships: [
                        { from: "Author", to: "BookAuthor", multiplicity: "1:N", description: "Een auteur kan meerdere boeken schrijven", onDelete: "DTR" },
                        { from: "Book", to: "BookAuthor", multiplicity: "1:N", description: "Een boek kan door verschillende auteurs geschreven zijn", onDelete: "DTR" },
                        { from: "Author", to: "User", multiplicity: "0..1:0..*", description: "Een auteur heeft eventueel een geverifieerde gebruikersaccount", onDelete: "DTN" },
                        { from: "Book", to: "Review", multiplicity: "1:N", description: "Een review is steeds geschreven voor één boek", onDelete: "DTR" },
                        { from: "Book", to: "Publisher", multiplicity: "N:1", description: "Een boek is steeds gepubliceerd door één uitgever", onDelete: "DTR" },
                        { from: "Shelve", to: "Shelved", multiplicity: "1:N", description: "Een boekschap kan meerdere boeken bevatten", onDelete: "DTC" },
                        { from: "Book", to: "Shelved", multiplicity: "1:N", description: "Een boek kan op verschillende boekenschappen geplaatst worden", onDelete: "DTR" },
                        { from: "User", to: "ReadHistory", multiplicity: "1:N", description: "Een gebruiker kan verschillende boeken lezen", onDelete: "DTC" },
                        { from: "Book", to: "ReadHistory", multiplicity: "1:N", description: "Een boek kan meerdere keren gelezen worden door eenzelfde gebruiker", onDelete: "DTR" },
                        { from: "User", to: "Shelve", multiplicity: "1:N", description: "Een boekenschap behoort tot één gebruiker", onDelete: "DTC" },
                        { from: "User", to: "Review", multiplicity: "0..1:0..*", description: "Een review is steeds geschreven door één gebruiker", onDelete: "DTN" }
                    ]
                };

                // ERD Builder Class
                class ERDBuilder {
                    constructor() {
                        this.entities = [];
                        this.relationships = [];
                        this.currentMode = 'select';
                        this.selectedEntity = null;
                        this.relationshipStart = null;
                        this.entityCounter = 0;
                        this.relationshipCounter = 0;
                        this.init();
                    }

                    init() {
                        this.canvas = document.getElementById('erd-canvas');
                        this.svg = document.getElementById('erd-svg');
                        if (!this.canvas || !this.svg) return;
                        this.setupEventListeners();

                        // Rerender model solution on resize for proper scaling
                        window.addEventListener('resize', () => {
                            const content = document.getElementById('model-solution-content');
                            if (content && !content.classList.contains('hidden')) {
                                this.renderModelSolution();
                            }
                        });
                    }

                    setupEventListeners() {
                        // Toolbar buttons
                        document.querySelectorAll('.erd-toolbar-btn[data-mode]').forEach(btn => {
                            btn.addEventListener('click', () => {
                                const mode = btn.dataset.mode;
                                this.setMode(mode);
                            });
                        });

                        // Special buttons - remove existing listeners first
                        const addEntityBtn = document.getElementById('erd-btn-add-entity');
                        if (addEntityBtn) {
                            addEntityBtn.replaceWith(addEntityBtn.cloneNode(true));
                            document.getElementById('erd-btn-add-entity').addEventListener('click', () => this.addEntity());
                        }

                        const validateBtn = document.getElementById('erd-btn-validate');
                        if (validateBtn) {
                            validateBtn.replaceWith(validateBtn.cloneNode(true));
                            document.getElementById('erd-btn-validate').addEventListener('click', () => this.validate());
                        }

                        const resetBtn = document.getElementById('erd-btn-reset');
                        if (resetBtn) {
                            resetBtn.replaceWith(resetBtn.cloneNode(true));
                            document.getElementById('erd-btn-reset').addEventListener('click', () => this.reset());
                        }

                        const exportBtn = document.getElementById('erd-btn-export');
                        if (exportBtn) {
                            exportBtn.replaceWith(exportBtn.cloneNode(true));
                            document.getElementById('erd-btn-export').addEventListener('click', () => this.exportJSON());
                        }

                        const editorCloseBtn = document.getElementById('erd-editor-close');
                        if (editorCloseBtn) {
                            editorCloseBtn.replaceWith(editorCloseBtn.cloneNode(true));
                            document.getElementById('erd-editor-close').addEventListener('click', () => this.closeEditor());
                        }

                        const saveEntityBtn = document.getElementById('erd-btn-save-entity');
                        if (saveEntityBtn) {
                            saveEntityBtn.replaceWith(saveEntityBtn.cloneNode(true));
                            document.getElementById('erd-btn-save-entity').addEventListener('click', (e) => {
                                e.preventDefault();
                                e.stopPropagation();
                                this.saveEntity();
                            });
                        }

                        const addAttrBtn = document.getElementById('erd-btn-add-attribute');
                        if (addAttrBtn) {
                            addAttrBtn.replaceWith(addAttrBtn.cloneNode(true));
                            document.getElementById('erd-btn-add-attribute').addEventListener('click', () => this.addAttributeRow());
                        }

                        const relSaveBtn = document.getElementById('rel-btn-save');
                        if (relSaveBtn) {
                            relSaveBtn.replaceWith(relSaveBtn.cloneNode(true));
                            document.getElementById('rel-btn-save').addEventListener('click', (e) => {
                                e.preventDefault();
                                e.stopPropagation();
                                this.saveRelationship();
                            });
                        }

                        const relCancelBtn = document.getElementById('rel-btn-cancel');
                        if (relCancelBtn) {
                            relCancelBtn.replaceWith(relCancelBtn.cloneNode(true));
                            document.getElementById('rel-btn-cancel').addEventListener('click', () => this.cancelRelationship());
                        }

                        const toggleSolutionBtn = document.getElementById('toggle-model-solution');
                        if (toggleSolutionBtn) {
                            toggleSolutionBtn.replaceWith(toggleSolutionBtn.cloneNode(true));
                            document.getElementById('toggle-model-solution').addEventListener('click', () => this.toggleModelSolution());
                        }

                        // Canvas click handlers
                        if (this.canvas) {
                            this.canvas.addEventListener('click', (e) => this.handleCanvasClick(e));
                            this.canvas.addEventListener('dblclick', (e) => this.handleCanvasDoubleClick(e));
                        }
                    }

                    setMode(mode) {
                        // Toggle off ANY mode including select → neutral 'none'
                        if (this.currentMode === mode) {
                            mode = 'none';
                        }

                        this.currentMode = mode;
                        document.querySelectorAll('.erd-toolbar-btn[data-mode]').forEach(btn => {
                            btn.classList.toggle('active', btn.dataset.mode === mode);
                        });
                        if (this.canvas) {
                            this.canvas.classList.remove('select-mode', 'relationship-mode');
                            if (mode === 'select') {
                                this.canvas.classList.add('select-mode');
                            } else if (mode === 'relationship') {
                                this.canvas.classList.add('relationship-mode');
                            } else {
                                // none: clear transient state
                                this.relationshipStart = null;
                            }
                            // Clear any previous relationship selection highlights when leaving relationship mode
                            if (mode !== 'relationship') {
                                this.canvas.querySelectorAll('.erd-entity').forEach(el => {
                                    el.classList.remove('relationship-selected');
                                });
                            }
                        }
                    }

                    addEntity() {
                        if (!this.canvas) return;

                        // Grid-gebaseerde plaatsing
                        const gridCols = 3;
                        const spacingX = 250;
                        const spacingY = 200;
                        const startX = 50;
                        const startY = 50;

                        const col = this.entities.length % gridCols;
                        const row = Math.floor(this.entities.length / gridCols);
                        const x = startX + col * spacingX;
                        const y = startY + row * spacingY;

                        const entity = {
                            id: `entity-${++this.entityCounter}`,
                            name: `Entiteit${this.entityCounter}`,
                            type: '',
                            x: x,
                            y: y,
                            attributes: []
                        };

                        this.entities.push(entity);
                        this.render();
                        this.openEditor(entity);
                    }

                    render() {
                        if (!this.canvas) return;

                        // Clear canvas
                        this.canvas.querySelectorAll('.erd-entity').forEach(el => el.remove());

                        // Calculate canvas dimensions based on entities
                        if (this.entities.length > 0) {
                            const gridCols = 3;
                            const spacingX = 250;
                            const spacingY = 200;
                            const startX = 50;
                            const startY = 50;
                            const entityWidth = 200;
                            const entityHeight = 150;

                            // Calculate based on grid
                            const rows = Math.ceil(this.entities.length / gridCols);
                            const gridWidth = startX + gridCols * spacingX + entityWidth;
                            const gridHeight = startY + rows * spacingY + entityHeight;

                            // Calculate based on actual entity positions
                            const maxX = Math.max(...this.entities.map(e => (e.x || 0) + entityWidth));
                            const maxY = Math.max(...this.entities.map(e => (e.y || 0) + entityHeight));

                            // Use the maximum of grid and actual positions
                            const calculatedWidth = Math.max(gridWidth, maxX + 50);
                            const calculatedHeight = Math.max(600, Math.max(gridHeight, maxY + 50));

                            this.canvas.style.minHeight = calculatedHeight + 'px';
                            // Ensure width is at least 100% but can grow
                            const currentWidth = this.canvas.offsetWidth || this.canvas.clientWidth || 0;
                            if (calculatedWidth > currentWidth) {
                                this.canvas.style.minWidth = calculatedWidth + 'px';
                            } else {
                                this.canvas.style.minWidth = '100%';
                            }
                        } else {
                            this.canvas.style.minHeight = '600px';
                            this.canvas.style.minWidth = '100%';
                        }

                        // Render entities
                        this.entities.forEach(entity => {
                            const entityEl = this.createEntityElement(entity);
                            this.canvas.appendChild(entityEl);
                            // Store reference for relationship selection
                            entity.element = entityEl;
                        });

                        // Render relationships
                        this.renderRelationships();
                    }

                    createEntityElement(entity) {
                        const div = document.createElement('div');
                        div.className = 'erd-entity';
                        div.id = entity.id;
                        div.style.left = entity.x + 'px';
                        div.style.top = entity.y + 'px';
                        div.style.position = 'absolute';

                        const header = document.createElement('div');
                        header.className = 'erd-entity-header';
                        const typeBadge = entity.type ? `<span class="erd-entity-type-badge ${entity.type}">${entity.type}</span>` : '';
                        header.innerHTML = `<span>${entity.name}</span>${typeBadge}`;

                        const attributes = document.createElement('div');
                        attributes.className = 'erd-entity-attributes';
                        entity.attributes.forEach(attr => {
                            const attrEl = document.createElement('div');
                            attrEl.className = 'erd-attribute';
                            if (attr.pk) attrEl.classList.add('pk');
                            if (attr.fk) attrEl.classList.add('fk');
                            if (attr.ak) attrEl.classList.add('ak');

                            let attrText = attr.name;
                            if (attr.type) attrText += `: ${attr.type}`;
                            if (attr.nullable === false) attrText += ' {NNA}';
                            else if (attr.nullable === true) attrText += ' {NA}';

                            attrEl.textContent = attrText;
                            attributes.appendChild(attrEl);
                        });

                        div.appendChild(header);
                        div.appendChild(attributes);

                        // Make draggable
                        this.makeDraggable(div, entity);

                        return div;
                    }

                    makeDraggable(element, entity) {
                        // Store drag state on the element itself to avoid conflicts
                        if (element.dataset.dragInitialized === 'true') return;
                        element.dataset.dragInitialized = 'true';

                        element.addEventListener('mousedown', (e) => {
                            // Only allow dragging in select mode
                            if (this.currentMode !== 'select') return;

                            // Don't drag if clicking on input/button elements or their children
                            if (e.target.closest('input') || e.target.closest('button') || e.target.closest('select')) return;

                            let isDragging = true;
                            const startX = e.clientX;
                            const startY = e.clientY;
                            const startLeft = entity.x;
                            const startTop = entity.y;
                            element.classList.add('selected');
                            this.selectedEntity = entity;

                            const moveHandler = (e) => {
                                if (!isDragging) return;
                                const dx = e.clientX - startX;
                                const dy = e.clientY - startY;
                                entity.x = startLeft + dx;
                                entity.y = startTop + dy;
                                element.style.left = entity.x + 'px';
                                element.style.top = entity.y + 'px';
                                this.renderRelationships();

                                // Update canvas size if entity moves outside current bounds
                                const entityWidth = 200;
                                const entityHeight = 150;
                                const currentMaxX = entity.x + entityWidth;
                                const currentMaxY = entity.y + entityHeight;
                                const canvasMaxX = this.canvas.offsetWidth;
                                const canvasMaxY = parseInt(this.canvas.style.minHeight) || 600;

                                if (currentMaxX > canvasMaxX - 50) {
                                    this.canvas.style.minWidth = (currentMaxX + 50) + 'px';
                                }
                                if (currentMaxY > canvasMaxY - 50) {
                                    this.canvas.style.minHeight = (currentMaxY + 50) + 'px';
                                }
                            };

                            const upHandler = () => {
                                isDragging = false;
                                element.classList.remove('selected');
                                document.removeEventListener('mousemove', moveHandler);
                                document.removeEventListener('mouseup', upHandler);
                            };

                            document.addEventListener('mousemove', moveHandler);
                            document.addEventListener('mouseup', upHandler);
                            e.preventDefault();
                            e.stopPropagation();
                        });
                    }

                    renderRelationships() {
                        if (!this.svg || !this.canvas) return;

                        // Clear existing relationship lines
                        this.svg.querySelectorAll('.erd-relationship-line, text').forEach(el => el.remove());

                        this.relationships.forEach(rel => {
                            const fromEntity = this.entities.find(e => e.id === rel.from);
                            const toEntity = this.entities.find(e => e.id === rel.to);
                            if (!fromEntity || !toEntity) return;

                            const fromEl = document.getElementById(fromEntity.id);
                            const toEl = document.getElementById(toEntity.id);
                            if (!fromEl || !toEl) return;

                            const fromRect = fromEl.getBoundingClientRect();
                            const toRect = toEl.getBoundingClientRect();
                            const canvasRect = this.canvas.getBoundingClientRect();

                            const x1 = fromRect.left - canvasRect.left + fromRect.width / 2;
                            const y1 = fromRect.top - canvasRect.top + fromRect.height / 2;
                            const x2 = toRect.left - canvasRect.left + toRect.width / 2;
                            const y2 = toRect.top - canvasRect.top + toRect.height / 2;

                            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                            line.setAttribute('x1', x1);
                            line.setAttribute('y1', y1);
                            line.setAttribute('x2', x2);
                            line.setAttribute('y2', y2);
                            line.setAttribute('class', 'erd-relationship-line');
                            line.setAttribute('data-relationship-id', rel.id);

                            this.svg.appendChild(line);

                            // Add label
                            const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                            text.setAttribute('x', (x1 + x2) / 2);
                            text.setAttribute('y', (y1 + y2) / 2 - 5);
                            text.setAttribute('class', 'erd-relationship-label');
                            text.textContent = rel.multiplicity || '';
                            this.svg.appendChild(text);
                        });
                    }

                    handleCanvasClick(e) {
                        if (this.currentMode === 'relationship') {
                            const clickedEntity = e.target.closest('.erd-entity');
                            if (clickedEntity) {
                                const entityId = clickedEntity.id;
                                if (!this.relationshipStart || typeof this.relationshipStart === 'string' && this.relationshipStart.length === 0) {
                                    // First entity selected (store its id as string temporarily)
                                    this.relationshipStart = entityId;
                                    clickedEntity.classList.add('relationship-selected');
                                } else if (typeof this.relationshipStart === 'string' && this.relationshipStart !== entityId) {
                                    // Second entity selected - open editor and keep selection until save/cancel
                                    clickedEntity.classList.add('relationship-selected');
                                    this.openRelationshipEditor(this.relationshipStart, entityId);
                                    // Do NOT clear relationshipStart here; editor sets correct object {fromId,toId}
                                } else if (this.relationshipStart === entityId) {
                                    // Same entity clicked - deselect
                                    clickedEntity.classList.remove('relationship-selected');
                                    this.relationshipStart = null;
                                }
                            }
                        } else if (this.currentMode === 'delete') {
                            const clickedEntity = e.target.closest('.erd-entity');
                            if (clickedEntity) {
                                const entityId = clickedEntity.id;
                                this.deleteEntity(entityId);
                            }
                        }
                    }

                    handleCanvasDoubleClick(e) {
                        const clickedEntity = e.target.closest('.erd-entity');
                        if (clickedEntity) {
                            const entityId = clickedEntity.id;
                            const entity = this.entities.find(e => e.id === entityId);
                            if (entity) {
                                this.openEditor(entity);
                            }
                        }
                    }

                    openEditor(entity) {
                        this.selectedEntity = entity;
                        const nameInput = document.getElementById('erd-entity-name');
                        const typeSelect = document.getElementById('erd-entity-type');
                        if (nameInput) nameInput.value = entity.name;
                        if (typeSelect) typeSelect.value = entity.type || '';

                        const attributesList = document.getElementById('erd-attributes-list');
                        if (attributesList) {
                            attributesList.innerHTML = '';
                            entity.attributes.forEach((attr, index) => {
                                attributesList.appendChild(this.createAttributeRow(attr, index));
                            });
                        }

                        const editorPanel = document.getElementById('erd-editor-panel');
                        if (editorPanel) editorPanel.classList.add('open');
                    }

                    createAttributeRow(attr, index) {
                        const div = document.createElement('div');
                        div.className = 'border border-slate-300 rounded p-2 space-y-2';
                        div.innerHTML = `
                            <div class="flex gap-2">
                                <input type="text" class="attr-name flex-1 p-1 border rounded" value="${attr.name || ''}" placeholder="Naam">
                                <select class="attr-type p-1 border rounded">
                                    <option value="int" ${attr.type === 'int' ? 'selected' : ''}>int</option>
                                    <option value="string" ${attr.type === 'string' ? 'selected' : ''}>string</option>
                                    <option value="date" ${attr.type === 'date' ? 'selected' : ''}>date</option>
                                    <option value="datetime" ${attr.type === 'datetime' ? 'selected' : ''}>datetime</option>
                                    <option value="boolean" ${attr.type === 'boolean' ? 'selected' : ''}>boolean</option>
                                </select>
                            </div>
                            <div class="flex gap-2 text-sm">
                                <label><input type="checkbox" class="attr-pk" ${attr.pk ? 'checked' : ''}> PK</label>
                                <label><input type="checkbox" class="attr-fk" ${attr.fk ? 'checked' : ''}> FK</label>
                                <label><input type="checkbox" class="attr-ak" ${attr.ak ? 'checked' : ''}> AK</label>
                                <label><input type="checkbox" class="attr-nullable" ${attr.nullable !== false ? 'checked' : ''}> NA</label>
                                <button class="attr-delete text-red-600 hover:text-red-800">Verwijder</button>
                            </div>
                        `;

                        div.querySelector('.attr-delete').addEventListener('click', () => {
                            div.remove();
                        });

                        return div;
                    }

                    addAttributeRow() {
                        const attributesList = document.getElementById('erd-attributes-list');
                        if (!attributesList) return;
                        const newAttr = { name: '', type: 'string', pk: false, fk: false, ak: false, nullable: true };
                        attributesList.appendChild(this.createAttributeRow(newAttr, attributesList.children.length));
                    }

                    saveEntity() {
                        if (!this.selectedEntity) {
                            alert('Geen entiteit geselecteerd');
                            return;
                        }

                        // Find the entity in the array to ensure we're updating the right one
                        const entityIndex = this.entities.findIndex(e => e.id === this.selectedEntity.id);
                        if (entityIndex === -1) {
                            alert('Entiteit niet gevonden in array');
                            return;
                        }
                        const entity = this.entities[entityIndex];

                        const nameInput = document.getElementById('erd-entity-name');
                        if (!nameInput) {
                            alert('Naam input niet gevonden');
                            return;
                        }

                        const name = nameInput.value.trim();
                        if (!name) {
                            alert('Geef een naam op voor de entiteit');
                            return;
                        }

                        // Update entity name directly in array
                        entity.name = name;

                        // Update entity type
                        const typeSelect = document.getElementById('erd-entity-type');
                        if (typeSelect) {
                            entity.type = typeSelect.value;
                        }

                        // Collect attributes
                        const attributes = [];
                        const attributesList = document.getElementById('erd-attributes-list');
                        if (attributesList) {
                            attributesList.querySelectorAll(':scope > div').forEach(row => {
                                const attrName = row.querySelector('.attr-name')?.value.trim();
                                if (attrName) {
                                    attributes.push({
                                        name: attrName,
                                        type: row.querySelector('.attr-type')?.value || 'string',
                                        pk: row.querySelector('.attr-pk')?.checked || false,
                                        fk: row.querySelector('.attr-fk')?.checked || false,
                                        ak: row.querySelector('.attr-ak')?.checked || false,
                                        nullable: row.querySelector('.attr-nullable')?.checked !== false
                                    });
                                }
                            });
                        }

                        // Update entity attributes directly in array
                        entity.attributes = attributes;

                        // Update selectedEntity reference
                        this.selectedEntity = entity;

                        // Close editor first to avoid conflicts
                        this.closeEditor();

                        // Re-render to show updated entity
                        this.render();
                    }

                    closeEditor() {
                        const editorPanel = document.getElementById('erd-editor-panel');
                        if (editorPanel) editorPanel.classList.remove('open');
                        this.selectedEntity = null;
                    }

                    openRelationshipEditor(fromId, toId) {
                        const fromEntity = this.entities.find(e => e.id === fromId);
                        const toEntity = this.entities.find(e => e.id === toId);
                        if (!fromEntity || !toEntity) {
                            alert('Een of beide entiteiten niet gevonden');
                            return;
                        }

                        const relFrom = document.getElementById('rel-from');
                        const relTo = document.getElementById('rel-to');
                        if (relFrom) relFrom.value = fromEntity.name;
                        if (relTo) relTo.value = toEntity.name;

                        const relMultiplicity = document.getElementById('rel-multiplicity');
                        const relDescription = document.getElementById('rel-description');
                        const relOnDelete = document.getElementById('rel-ondelete');
                        if (relMultiplicity) relMultiplicity.value = '1:N';
                        if (relDescription) relDescription.value = '';
                        if (relOnDelete) relOnDelete.value = 'DTR';

                        // Store both IDs properly
                        this.relationshipStart = { fromId: fromId, toId: toId };

                        const modal = document.getElementById('erd-relationship-modal');
                        if (modal) modal.classList.remove('hidden');
                    }

                    saveRelationship() {
                        if (!this.relationshipStart || !this.relationshipStart.fromId || !this.relationshipStart.toId) {
                            alert('Geen relatie geselecteerd');
                            return;
                        }

                        const relMultiplicity = document.getElementById('rel-multiplicity');
                        const relDescription = document.getElementById('rel-description');
                        const relOnDelete = document.getElementById('rel-ondelete');

                        if (!relMultiplicity || !relOnDelete) {
                            alert('Relatie editor elementen niet gevonden');
                            return;
                        }

                        const rel = {
                            id: `rel-${++this.relationshipCounter}`,
                            from: this.relationshipStart.fromId,
                            to: this.relationshipStart.toId,
                            multiplicity: relMultiplicity.value || '1:N',
                            description: relDescription?.value || '',
                            onDelete: relOnDelete.value || 'DTR'
                        };

                        this.relationships.push(rel);
                        this.render();
                        this.cancelRelationship();
                    }

                    cancelRelationship() {
                        const modal = document.getElementById('erd-relationship-modal');
                        if (modal) modal.classList.add('hidden');
                        // Clear selection highlights
                        if (this.canvas) {
                            this.canvas.querySelectorAll('.erd-entity.relationship-selected').forEach(el => el.classList.remove('relationship-selected'));
                        }
                        this.relationshipStart = null;
                        this.setMode('select');
                    }

                    deleteEntity(entityId) {
                        this.entities = this.entities.filter(e => e.id !== entityId);
                        this.relationships = this.relationships.filter(r => r.from !== entityId && r.to !== entityId);
                        this.render();
                    }

                    exportJSON() {
                        const data = {
                            entities: this.entities,
                            relationships: this.relationships
                        };
                        const json = JSON.stringify(data, null, 2);
                        const blob = new Blob([json], { type: 'application/json' });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = 'erd-model.json';
                        a.click();
                        URL.revokeObjectURL(url);
                    }

                    reset() {
                        if (confirm('Weet je zeker dat je het hele model wilt resetten?')) {
                            this.entities = [];
                            this.relationships = [];
                            this.entityCounter = 0;
                            this.relationshipCounter = 0;
                            this.render();
                        }
                    }

                    getModelData() {
                        return {
                            entities: this.entities,
                            relationships: this.relationships
                        };
                    }

                    validate() {
                        const validationEngine = new ValidationEngine();
                        const result = validationEngine.validate(this.getModelData(), bookNetworkModel);
                        const feedbackRenderer = new FeedbackRenderer();
                        feedbackRenderer.render(result);

                        // Show feedback section
                        const feedbackSection = document.getElementById('examen-feedback');
                        if (feedbackSection) {
                            feedbackSection.classList.remove('hidden');
                            feedbackSection.scrollIntoView({ behavior: 'smooth' });
                        }

                        // Show model solution section
                        const solutionSection = document.getElementById('examen-model-solution');
                        if (solutionSection) {
                            solutionSection.classList.remove('hidden');
                        }
                    }

                    toggleModelSolution() {
                        const content = document.getElementById('model-solution-content');
                        const btn = document.getElementById('toggle-model-solution');
                        if (!content || !btn) return;

                        const isHidden = content.classList.contains('hidden');

                        if (isHidden) {
                            content.classList.remove('hidden');
                            btn.textContent = 'Verberg Model Oplossing';
                            this.renderModelSolution();
                        } else {
                            content.classList.add('hidden');
                            btn.textContent = 'Toon Model Oplossing';
                        }
                    }

                    renderModelSolution() {
                        const solutionCanvas = document.getElementById('model-solution-erd');
                        const solutionImage = document.getElementById('model-solution-image');
                        if (!solutionCanvas) return;

                        // Always show image on both mobile and desktop
                        if (solutionImage) {
                            solutionImage.classList.remove('hidden');
                        }

                        // Desktop: also render interactive ERD
                        if (window.innerWidth >= 768) {
                            solutionCanvas.classList.remove('hidden');
                            solutionCanvas.innerHTML = '';

                            // Define positions from BookNetwork.drawio (adjusted for better spacing)
                            const entityPositions = {
                                'Author': { x: 30, y: 10 },
                                'BookAuthor': { x: 315, y: 40 },
                                'Book': { x: 590, y: 10 },
                                'Review': { x: 590, y: 300 },
                                'Publisher': { x: 940, y: 160 },
                                'Shelve': { x: 20, y: 250 },
                                'Shelved': { x: 315, y: 270 },
                                'User': { x: 315, y: 500 },
                                'ReadHistory': { x: 680, y: 500 }
                            };

                            // Calculate canvas dimensions based on entity positions
                            const entityWidth = 200;
                            const entityHeight = 200;
                            const maxX = Math.max(...Object.values(entityPositions).map(pos => pos.x + entityWidth));
                            const maxY = Math.max(...Object.values(entityPositions).map(pos => pos.y + entityHeight));
                            const calculatedWidth = maxX + 100;
                            const calculatedHeight = maxY + 100;

                            solutionCanvas.style.minHeight = calculatedHeight + 'px';
                            // Ensure width is at least 100% but can grow
                            const currentWidth = solutionCanvas.offsetWidth || solutionCanvas.clientWidth || 0;
                            if (calculatedWidth > currentWidth || currentWidth === 0) {
                                solutionCanvas.style.minWidth = calculatedWidth + 'px';
                            } else {
                                solutionCanvas.style.minWidth = '100%';
                            }

                            // Create SVG for relationships
                            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                            svg.id = 'model-solution-svg';
                            svg.style.position = 'absolute';
                            svg.style.top = '0';
                            svg.style.left = '0';
                            svg.style.width = '100%';
                            svg.style.height = '100%';
                            svg.style.pointerEvents = 'none';
                            svg.setAttribute('viewBox', `0 0 ${calculatedWidth} ${calculatedHeight}`);
                            svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');
                            solutionCanvas.appendChild(svg);

                            // Render entities from model solution
                            bookNetworkModel.entities.forEach((entity) => {
                                const pos = entityPositions[entity.name];
                                if (pos) {
                                    const entityDiv = this.createModelEntityElement(entity, pos.x, pos.y);
                                    solutionCanvas.appendChild(entityDiv);
                                }
                            });

                            // Render relationships with correct positions and better visibility
                            bookNetworkModel.relationships.forEach(rel => {
                                const fromPos = entityPositions[rel.from];
                                const toPos = entityPositions[rel.to];
                                if (!fromPos || !toPos) return;

                                // Calculate center points of entities (assuming ~180px width, ~150px height)
                                const x1 = fromPos.x + 90;
                                const y1 = fromPos.y + 75;
                                const x2 = toPos.x + 90;
                                const y2 = toPos.y + 75;

                                // Add arrowhead marker definition (only once)
                                let defs = svg.querySelector('defs');
                                if (!defs) {
                                    defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
                                    svg.insertBefore(defs, svg.firstChild);
                                    const marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
                                    marker.setAttribute('id', 'arrowhead');
                                    marker.setAttribute('markerWidth', '10');
                                    marker.setAttribute('markerHeight', '10');
                                    marker.setAttribute('refX', '9');
                                    marker.setAttribute('refY', '3');
                                    marker.setAttribute('orient', 'auto');
                                    const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                                    polygon.setAttribute('points', '0 0, 10 3, 0 6');
                                    polygon.setAttribute('fill', '#1e293b');
                                    marker.appendChild(polygon);
                                    defs.appendChild(marker);
                                }

                                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                                line.setAttribute('x1', x1);
                                line.setAttribute('y1', y1);
                                line.setAttribute('x2', x2);
                                line.setAttribute('y2', y2);
                                line.setAttribute('class', 'erd-relationship-line');
                                line.setAttribute('stroke', '#1e293b');
                                line.setAttribute('stroke-width', '3');
                                line.setAttribute('marker-end', 'url(#arrowhead)');
                                svg.appendChild(line);

                                // Add label with background
                                const textGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');

                                text.setAttribute('x', (x1 + x2) / 2);
                                text.setAttribute('y', (y1 + y2) / 2 - 5);
                                text.setAttribute('class', 'erd-relationship-label');
                                text.setAttribute('fill', '#1e293b');
                                text.setAttribute('font-size', '14');
                                text.setAttribute('font-weight', 'bold');
                                text.setAttribute('text-anchor', 'middle');
                                text.textContent = rel.multiplicity || '';

                                // Add background rectangle for better visibility
                                // Estimate size based on text length
                                const textLength = (rel.multiplicity || '').length;
                                const estimatedWidth = textLength * 8 + 6;
                                const estimatedHeight = 18;
                                const textBg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                                textBg.setAttribute('x', (x1 + x2) / 2 - estimatedWidth / 2);
                                textBg.setAttribute('y', (y1 + y2) / 2 - estimatedHeight);
                                textBg.setAttribute('width', estimatedWidth);
                                textBg.setAttribute('height', estimatedHeight);
                                textBg.setAttribute('fill', 'white');
                                textBg.setAttribute('stroke', '#1e293b');
                                textBg.setAttribute('stroke-width', '1');
                                textBg.setAttribute('rx', '3');

                                textGroup.appendChild(textBg);
                                textGroup.appendChild(text);
                                svg.appendChild(textGroup);
                            });
                        } else {
                            // Mobile: hide interactive ERD
                            solutionCanvas.classList.add('hidden');
                        }
                    }

                    calculateEntityPositions(entities) {
                        // This method is no longer used, but kept for compatibility
                        const positions = [];
                        entities.forEach((entity, index) => {
                            const entityPositions = {
                                'Author': { x: 30, y: 10 },
                                'BookAuthor': { x: 315, y: 40 },
                                'Book': { x: 590, y: 10 },
                                'Review': { x: 590, y: 280 },
                                'Publisher': { x: 940, y: 160 },
                                'Shelve': { x: 20, y: 250 },
                                'Shelved': { x: 315, y: 270 },
                                'User': { x: 315, y: 450 },
                                'ReadHistory': { x: 680, y: 450 }
                            };
                            positions.push(entityPositions[entity.name] || { x: 50 + (index % 3) * 250, y: 50 + Math.floor(index / 3) * 200 });
                        });
                        return positions;
                    }

                    createModelEntityElement(entity, x, y) {
                        const div = document.createElement('div');
                        div.className = 'erd-entity';
                        div.style.left = x + 'px';
                        div.style.top = y + 'px';
                        div.style.position = 'absolute';

                        const header = document.createElement('div');
                        header.className = 'erd-entity-header';
                        const typeBadge = entity.type ? `<span class="erd-entity-type-badge ${entity.type}">${entity.type}</span>` : '';
                        header.innerHTML = `<span>${entity.name}</span>${typeBadge}`;

                        const attributes = document.createElement('div');
                        attributes.className = 'erd-entity-attributes';
                        entity.attributes.forEach(attr => {
                            const attrEl = document.createElement('div');
                            attrEl.className = 'erd-attribute';
                            if (attr.pk) attrEl.classList.add('pk');
                            if (attr.fk) attrEl.classList.add('fk');
                            if (attr.ak) attrEl.classList.add('ak');

                            let attrText = attr.name;
                            if (attr.type) attrText += `: ${attr.type}`;
                            if (attr.nullable === false) attrText += ' {NNA}';
                            else if (attr.nullable === true) attrText += ' {NA}';
                            if (attr.onDelete) attrText += `, ${attr.onDelete}`;

                            attrEl.textContent = attrText;
                            attributes.appendChild(attrEl);
                        });

                        div.appendChild(header);
                        div.appendChild(attributes);

                        return div;
                    }
                }

                // Validation Engine Class
                class ValidationEngine {
                    validate(studentModel, correctModel) {
                        const result = {
                            entities: this.validateEntities(studentModel.entities, correctModel.entities),
                            attributes: this.validateAttributes(studentModel.entities, correctModel.entities),
                            relationships: this.validateRelationships(studentModel.relationships, correctModel.relationships, studentModel.entities, correctModel.entities),
                            constraints: this.validateConstraints(studentModel.entities, correctModel.entities),
                            entityTypes: this.validateEntityTypes(studentModel.entities, correctModel.entities),
                            overallRules: this.validateOverallRules(studentModel)
                        };

                        result.totalScore = this.calculateTotalScore(result);

                        return result;
                    }

                    validateEntities(studentEntities, correctEntities) {
                        const studentNames = studentEntities.map(e => e.name.toLowerCase());
                        const correctNames = correctEntities.map(e => e.name.toLowerCase());

                        const missing = correctNames.filter(name => !studentNames.includes(name));
                        const extra = studentNames.filter(name => !correctNames.includes(name));
                        const correct = correctNames.filter(name => studentNames.includes(name));

                        return {
                            correct: correct.length,
                            total: correctNames.length,
                            missing: missing,
                            extra: extra,
                            details: correctEntities.map(entity => {
                                const studentEntity = studentEntities.find(e => e.name.toLowerCase() === entity.name.toLowerCase());
                                return {
                                    name: entity.name,
                                    found: !!studentEntity,
                                    studentName: studentEntity?.name
                                };
                            })
                        };
                    }

                    validateAttributes(studentEntities, correctEntities) {
                        let totalCorrect = 0;
                        let totalExpected = 0;
                        const details = [];

                        correctEntities.forEach(correctEntity => {
                            const studentEntity = studentEntities.find(e => e.name.toLowerCase() === correctEntity.name.toLowerCase());
                            if (!studentEntity) return;

                            totalExpected += correctEntity.attributes.length;
                            const attrResults = [];

                            correctEntity.attributes.forEach(correctAttr => {
                                const studentAttr = studentEntity.attributes.find(a =>
                                    a.name.toLowerCase() === correctAttr.name.toLowerCase()
                                );

                                if (studentAttr) {
                                    let attrCorrect = true;
                                    const errors = [];

                                    if (studentAttr.type !== correctAttr.type) {
                                        attrCorrect = false;
                                        errors.push(`Verkeerd datatype: verwacht ${correctAttr.type}, gevonden ${studentAttr.type || 'geen'}`);
                                    }
                                    if (studentAttr.pk !== correctAttr.pk) {
                                        attrCorrect = false;
                                        errors.push(`PK markering incorrect`);
                                    }
                                    if (studentAttr.fk !== correctAttr.fk) {
                                        attrCorrect = false;
                                        errors.push(`FK markering incorrect`);
                                    }
                                    if (studentAttr.ak !== correctAttr.ak) {
                                        attrCorrect = false;
                                        errors.push(`AK markering incorrect`);
                                    }
                                    if (studentAttr.nullable !== correctAttr.nullable) {
                                        attrCorrect = false;
                                        errors.push(`NA/NNA constraint incorrect`);
                                    }

                                    if (attrCorrect) totalCorrect++;
                                    attrResults.push({
                                        name: correctAttr.name,
                                        correct: attrCorrect,
                                        errors: errors
                                    });
                                } else {
                                    attrResults.push({
                                        name: correctAttr.name,
                                        correct: false,
                                        errors: ['Attribuut ontbreekt']
                                    });
                                }
                            });

                            details.push({
                                entity: correctEntity.name,
                                attributes: attrResults
                            });
                        });

                        return {
                            correct: totalCorrect,
                            total: totalExpected,
                            details: details
                        };
                    }

                    validateRelationships(studentRels, correctRels, studentEntities, correctEntities) {
                        let correct = 0;
                        const details = [];

                        correctRels.forEach(correctRel => {
                            const fromEntity = correctEntities.find(e => e.name === correctRel.from);
                            const toEntity = correctEntities.find(e => e.name === correctRel.to);

                            if (!fromEntity || !toEntity) return;

                            const studentFrom = studentEntities.find(e => e.name.toLowerCase() === fromEntity.name.toLowerCase());
                            const studentTo = studentEntities.find(e => e.name.toLowerCase() === toEntity.name.toLowerCase());

                            if (!studentFrom || !studentTo) {
                                details.push({
                                    from: correctRel.from,
                                    to: correctRel.to,
                                    found: false,
                                    errors: ['Een of beide entiteiten ontbreken']
                                });
                                return;
                            }

                            const studentRel = studentRels.find(r =>
                                (r.from === studentFrom.id && r.to === studentTo.id) ||
                                (r.from === studentTo.id && r.to === studentFrom.id)
                            );

                            if (studentRel) {
                                let relCorrect = true;
                                const errors = [];

                                if (studentRel.multiplicity !== correctRel.multiplicity) {
                                    relCorrect = false;
                                    errors.push(`Multipliciteit incorrect: verwacht ${correctRel.multiplicity}, gevonden ${studentRel.multiplicity}`);
                                }

                                if (relCorrect) correct++;
                                details.push({
                                    from: correctRel.from,
                                    to: correctRel.to,
                                    found: true,
                                    correct: relCorrect,
                                    errors: errors
                                });
                            } else {
                                details.push({
                                    from: correctRel.from,
                                    to: correctRel.to,
                                    found: false,
                                    errors: ['Relatie ontbreekt']
                                });
                            }
                        });

                        return {
                            correct: correct,
                            total: correctRels.length,
                            details: details
                        };
                    }

                    validateConstraints(studentEntities, correctEntities) {
                        let correct = 0;
                        let total = 0;
                        const details = [];

                        correctEntities.forEach(correctEntity => {
                            const studentEntity = studentEntities.find(e => e.name.toLowerCase() === correctEntity.name.toLowerCase());
                            if (!studentEntity) return;

                            correctEntity.attributes.forEach(correctAttr => {
                                if (correctAttr.fk) {
                                    total++;
                                    const studentAttr = studentEntity.attributes.find(a =>
                                        a.name.toLowerCase() === correctAttr.name.toLowerCase()
                                    );

                                    if (studentAttr && studentAttr.fk) {
                                        if (correctAttr.onDelete && studentAttr.onDelete !== correctAttr.onDelete) {
                                            details.push({
                                                entity: correctEntity.name,
                                                attribute: correctAttr.name,
                                                correct: false,
                                                error: `ON DELETE constraint incorrect: verwacht ${correctAttr.onDelete}, gevonden ${studentAttr.onDelete || 'geen'}`
                                            });
                                        } else {
                                            correct++;
                                            details.push({
                                                entity: correctEntity.name,
                                                attribute: correctAttr.name,
                                                correct: true
                                            });
                                        }
                                    } else {
                                        details.push({
                                            entity: correctEntity.name,
                                            attribute: correctAttr.name,
                                            correct: false,
                                            error: 'FK constraint ontbreekt'
                                        });
                                    }
                                }
                            });
                        });

                        return {
                            correct: correct,
                            total: total,
                            details: details
                        };
                    }

                    validateEntityTypes(studentEntities, correctEntities) {
                        const typeCounts = { kern: 0, karakteristiek: 0, associatie: 0 };
                        const studentTypeCounts = { kern: 0, karakteristiek: 0, associatie: 0 };

                        correctEntities.forEach(entity => {
                            if (entity.type) typeCounts[entity.type]++;
                        });

                        studentEntities.forEach(entity => {
                            if (entity.type && typeCounts[entity.type] !== undefined) {
                                studentTypeCounts[entity.type]++;
                            }
                        });

                        const hasAllTypes = typeCounts.kern > 0 && typeCounts.karakteristiek > 0 && typeCounts.associatie > 0;
                        const studentHasAllTypes = studentTypeCounts.kern > 0 && studentTypeCounts.karakteristiek > 0 && studentTypeCounts.associatie > 0;

                        return {
                            correct: studentHasAllTypes ? 1 : 0,
                            total: 1,
                            hasAllTypes: studentHasAllTypes,
                            typeCounts: studentTypeCounts,
                            requiredCounts: typeCounts
                        };
                    }

                    validateOverallRules(studentModel) {
                        const errors = [];
                        const warnings = [];

                        const directMN = studentModel.relationships.filter(r => r.multiplicity === 'N:M').length;
                        if (directMN > 1) {
                            errors.push(`Te veel directe M:N relaties: ${directMN} gevonden, maximaal 1 toegestaan`);
                        }

                        const studentNames = studentModel.entities.map(e => e.name.toLowerCase());
                        const allowedNames = bookNetworkModel.entities.map(e => e.name.toLowerCase());
                        const extra = studentNames.filter(name => !allowedNames.includes(name));
                        if (extra.length > 0) {
                            warnings.push(`Extra entiteiten gevonden: ${extra.join(', ')}. Beperk je tot de gevraagde entiteiten.`);
                        }

                        return {
                            errors: errors,
                            warnings: warnings,
                            correct: errors.length === 0 ? 1 : 0,
                            total: 1
                        };
                    }

                    calculateTotalScore(result) {
                        const weights = {
                            entities: 0.2,
                            attributes: 0.3,
                            relationships: 0.2,
                            constraints: 0.15,
                            entityTypes: 0.1,
                            overallRules: 0.05
                        };

                        let totalScore = 0;
                        let totalMax = 0;

                        Object.keys(weights).forEach(key => {
                            if (result[key] && result[key].total !== undefined && result[key].total > 0) {
                                totalScore += (result[key].correct / result[key].total) * weights[key] * 100;
                                totalMax += weights[key] * 100;
                            }
                        });

                        return {
                            score: Math.round(totalScore),
                            max: Math.round(totalMax),
                            percentage: Math.round((totalScore / totalMax) * 100)
                        };
                    }
                }

                // Feedback Renderer Class
                class FeedbackRenderer {
                    render(result) {
                        this.renderDashboard(result);
                        this.renderDetails(result);
                    }

                    renderDashboard(result) {
                        const totalScoreEl = document.getElementById('feedback-total-score');
                        const totalProgressEl = document.getElementById('feedback-total-progress');
                        if (totalScoreEl) totalScoreEl.textContent = `${result.totalScore.score}/${result.totalScore.max}`;
                        if (totalProgressEl) totalProgressEl.style.width = `${result.totalScore.percentage}%`;

                        const entitiesScoreEl = document.getElementById('feedback-entities-score');
                        const entitiesProgressEl = document.getElementById('feedback-entities-progress');
                        if (entitiesScoreEl) entitiesScoreEl.textContent = `${result.entities.correct}/${result.entities.total}`;
                        if (entitiesProgressEl && result.entities.total > 0) {
                            entitiesProgressEl.style.width = `${(result.entities.correct / result.entities.total) * 100}%`;
                        }

                        const attributesScoreEl = document.getElementById('feedback-attributes-score');
                        const attributesProgressEl = document.getElementById('feedback-attributes-progress');
                        if (attributesScoreEl) attributesScoreEl.textContent = `${result.attributes.correct}/${result.attributes.total}`;
                        if (attributesProgressEl && result.attributes.total > 0) {
                            attributesProgressEl.style.width = `${(result.attributes.correct / result.attributes.total) * 100}%`;
                        }

                        const relationshipsScoreEl = document.getElementById('feedback-relationships-score');
                        const relationshipsProgressEl = document.getElementById('feedback-relationships-progress');
                        if (relationshipsScoreEl) relationshipsScoreEl.textContent = `${result.relationships.correct}/${result.relationships.total}`;
                        if (relationshipsProgressEl && result.relationships.total > 0) {
                            relationshipsProgressEl.style.width = `${(result.relationships.correct / result.relationships.total) * 100}%`;
                        }
                    }

                    renderDetails(result) {
                        // Entities detail
                        if (result.entities.missing.length > 0 || result.entities.extra.length > 0) {
                            const detailEl = document.getElementById('feedback-entities-detail');
                            const contentEl = document.getElementById('feedback-entities-content');
                            if (detailEl) detailEl.classList.remove('hidden');
                            if (contentEl) {
                                let html = '<div class="space-y-2">';
                                if (result.entities.missing.length > 0) {
                                    html += `<div class="p-3 bg-red-50 border border-red-200 rounded"><strong>Ontbrekende entiteiten:</strong> ${result.entities.missing.join(', ')}</div>`;
                                }
                                if (result.entities.extra.length > 0) {
                                    html += `<div class="p-3 bg-yellow-50 border border-yellow-200 rounded"><strong>Extra entiteiten:</strong> ${result.entities.extra.join(', ')}</div>`;
                                }
                                html += '</div>';
                                contentEl.innerHTML = html;
                            }
                        }

                        // Attributes detail
                        if (result.attributes.details.length > 0) {
                            const detailEl = document.getElementById('feedback-attributes-detail');
                            const contentEl = document.getElementById('feedback-attributes-content');
                            if (detailEl) detailEl.classList.remove('hidden');
                            if (contentEl) {
                                let html = '<div class="space-y-4">';
                                result.attributes.details.forEach(entityDetail => {
                                    const incorrect = entityDetail.attributes.filter(a => !a.correct);
                                    if (incorrect.length > 0) {
                                        html += `<div class="p-3 border border-slate-300 rounded"><strong>${entityDetail.entity}:</strong><ul class="mt-2 space-y-1">`;
                                        incorrect.forEach(attr => {
                                            html += `<li class="text-sm text-red-600">${attr.name}: ${attr.errors.join(', ')}</li>`;
                                        });
                                        html += '</ul></div>';
                                    }
                                });
                                html += '</div>';
                                contentEl.innerHTML = html;
                            }
                        }

                        // Relationships detail
                        if (result.relationships.details.length > 0) {
                            const detailEl = document.getElementById('feedback-relationships-detail');
                            const contentEl = document.getElementById('feedback-relationships-content');
                            if (detailEl) detailEl.classList.remove('hidden');
                            if (contentEl) {
                                let html = '<div class="space-y-2">';
                                result.relationships.details.forEach(rel => {
                                    if (!rel.found || (rel.errors && rel.errors.length > 0)) {
                                        html += `<div class="p-3 bg-red-50 border border-red-200 rounded"><strong>${rel.from} → ${rel.to}:</strong> ${rel.errors.join(', ')}</div>`;
                                    }
                                });
                                html += '</div>';
                                contentEl.innerHTML = html;
                            }
                        }

                        // Overall rules
                        if (result.overallRules.errors.length > 0 || result.overallRules.warnings.length > 0) {
                            const detailEl = document.getElementById('feedback-rules-detail');
                            const contentEl = document.getElementById('feedback-rules-content');
                            if (detailEl) detailEl.classList.remove('hidden');
                            if (contentEl) {
                                let html = '<div class="space-y-2">';
                                result.overallRules.errors.forEach(error => {
                                    html += `<div class="p-3 bg-red-50 border border-red-200 rounded">${error}</div>`;
                                });
                                result.overallRules.warnings.forEach(warning => {
                                    html += `<div class="p-3 bg-yellow-50 border border-yellow-200 rounded">${warning}</div>`;
                                });
                                html += '</div>';
                                contentEl.innerHTML = html;
                            }
                        }
                    }
                }

                // Initialize ERD Builder when page loads
                let erdBuilder;
                document.addEventListener('DOMContentLoaded', () => {
                    erdBuilder = new ERDBuilder();
                });
            </script>

</body>

</html>